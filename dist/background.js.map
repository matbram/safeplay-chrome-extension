{"version":3,"file":"background.js","mappings":"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","sources":["webpack://safeplay-chrome-extension/./src/utils/storage.ts","webpack://safeplay-chrome-extension/./src/types/index.ts","webpack://safeplay-chrome-extension/webpack/bootstrap","webpack://safeplay-chrome-extension/webpack/runtime/define property getters","webpack://safeplay-chrome-extension/webpack/runtime/hasOwnProperty shorthand","webpack://safeplay-chrome-extension/./src/api/client.ts","webpack://safeplay-chrome-extension/./src/background/index.ts"],"sourcesContent":["import {\n  UserPreferences,\n  DEFAULT_PREFERENCES,\n  Transcript,\n  CreditInfo,\n  SubscriptionTier,\n  UserProfile,\n  UserSubscription,\n  UserCredits,\n} from '../types';\n\nconst STORAGE_KEYS = {\n  PREFERENCES: 'safeplay_preferences',\n  AUTH_TOKEN: 'safeplay_auth_token',\n  REFRESH_TOKEN: 'safeplay_refresh_token',\n  TOKEN_EXPIRES_AT: 'safeplay_token_expires_at',\n  USER_ID: 'safeplay_user_id',\n  SUBSCRIPTION_TIER: 'safeplay_subscription_tier',\n  CREDIT_INFO: 'safeplay_credit_info',\n  CREDIT_CACHE_TIME: 'safeplay_credit_cache_time',\n  CACHED_TRANSCRIPTS: 'safeplay_cached_transcripts',\n  FILTERED_VIDEOS: 'safeplay_filtered_videos',\n  USER_PROFILE: 'safeplay_user_profile',\n  USER_SUBSCRIPTION: 'safeplay_user_subscription',\n  USER_CREDITS: 'safeplay_user_credits',\n  PROFILE_CACHE_TIME: 'safeplay_profile_cache_time',\n} as const;\n\n// API base URL for token refresh\nconst API_BASE_URL = 'https://trysafeplay.com';\n\n// Token refresh buffer - refresh 5 minutes before expiry\nconst TOKEN_REFRESH_BUFFER_MS = 5 * 60 * 1000;\n\n// Credit cache duration in milliseconds (5 minutes)\nconst CREDIT_CACHE_DURATION = 5 * 60 * 1000;\n\n// Cache limits\nconst MAX_CACHED_TRANSCRIPTS = 15; // Keep only 15 most recent transcripts\n\nexport async function getPreferences(): Promise<UserPreferences> {\n  const result = await chrome.storage.local.get(STORAGE_KEYS.PREFERENCES);\n  return result[STORAGE_KEYS.PREFERENCES] || DEFAULT_PREFERENCES;\n}\n\nexport async function setPreferences(\n  preferences: Partial<UserPreferences>\n): Promise<UserPreferences> {\n  const current = await getPreferences();\n  const updated = { ...current, ...preferences };\n  await chrome.storage.local.set({ [STORAGE_KEYS.PREFERENCES]: updated });\n  return updated;\n}\n\n// Refresh the auth token by getting fresh session from website\nexport async function refreshAuthToken(): Promise<string | null> {\n  try {\n    const extensionId = chrome.runtime.id;\n    const url = `${API_BASE_URL}/api/extension/session?extensionId=${extensionId}`;\n\n    console.log('[SafePlay Storage] üîÑ Refreshing token via website session...');\n    console.log('[SafePlay Storage] Endpoint:', url);\n\n    const response = await fetch(url, {\n      method: 'GET',\n      credentials: 'include',  // Include cookies for session\n    });\n\n    console.log('[SafePlay Storage] Response status:', response.status);\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      console.log('[SafePlay Storage] ‚ùå Session fetch failed:', {\n        status: response.status,\n        statusText: response.statusText,\n        body: errorText.substring(0, 200),\n      });\n      return null;\n    }\n\n    const data = await response.json();\n\n    console.log('[SafePlay Storage] Response data:', {\n      authenticated: data.authenticated,\n      hasToken: !!data.token,\n      tokenLength: data.token?.length,\n      hasRefreshToken: !!data.refreshToken,\n      refreshTokenLength: data.refreshToken?.length,\n      expiresAt: data.expiresAt,\n      expiresAtDate: data.expiresAt ? new Date(data.expiresAt).toISOString() : null,\n    });\n\n    if (!data.authenticated) {\n      console.log('[SafePlay Storage] ‚ùå User not authenticated on website - clearing local tokens');\n      // Clear local tokens since website session is gone\n      await chrome.storage.local.remove([\n        STORAGE_KEYS.AUTH_TOKEN,\n        STORAGE_KEYS.REFRESH_TOKEN,\n        STORAGE_KEYS.TOKEN_EXPIRES_AT,\n      ]);\n      return null;\n    }\n\n    // Store the new tokens\n    const expiresAtSeconds = Math.floor(data.expiresAt / 1000);\n    await chrome.storage.local.set({\n      [STORAGE_KEYS.AUTH_TOKEN]: data.token,\n      [STORAGE_KEYS.REFRESH_TOKEN]: data.refreshToken,\n      [STORAGE_KEYS.TOKEN_EXPIRES_AT]: expiresAtSeconds,\n    });\n\n    console.log('[SafePlay Storage] ‚úÖ Token refreshed successfully via website session');\n    console.log('[SafePlay Storage] New token expires:', new Date(expiresAtSeconds * 1000).toISOString());\n\n    return data.token;\n  } catch (error) {\n    console.log('[SafePlay Storage] ‚ùå Session refresh error:', error);\n    return null;\n  }\n}\n\n// Get auth token - automatically refreshes if expired\nexport async function getAuthToken(): Promise<string | null> {\n  const result = await chrome.storage.local.get([\n    STORAGE_KEYS.AUTH_TOKEN,\n    STORAGE_KEYS.REFRESH_TOKEN,\n    STORAGE_KEYS.TOKEN_EXPIRES_AT,\n  ]);\n\n  const token = result[STORAGE_KEYS.AUTH_TOKEN];\n  const refreshToken = result[STORAGE_KEYS.REFRESH_TOKEN];\n  const expiresAt = result[STORAGE_KEYS.TOKEN_EXPIRES_AT];\n\n  if (!token) {\n    return null;\n  }\n\n  // Check if token is expired or expiring soon\n  if (expiresAt) {\n    const now = Date.now();\n    // expiresAt should be stored in seconds (normalized in setAuthToken)\n    // But handle both cases for safety\n    let expiresAtMs = expiresAt;\n    if (expiresAt < 10000000000) {\n      // It's in seconds, convert to milliseconds\n      expiresAtMs = expiresAt * 1000;\n    }\n    // else it's already in milliseconds (legacy data)\n\n    const timeUntilExpiry = expiresAtMs - now;\n    const isExpired = timeUntilExpiry < 0;\n    const isExpiringSoon = timeUntilExpiry < TOKEN_REFRESH_BUFFER_MS;\n\n    // If token is completely expired (past expiry time)\n    if (isExpired) {\n      console.log('[SafePlay Storage] Token expired:', {\n        expiresAt,\n        expiresAtMs,\n        now,\n        expiredAgo: Math.abs(timeUntilExpiry) / 1000 + ' seconds',\n        hasRefreshToken: !!refreshToken,\n        refreshTokenLength: refreshToken?.length,\n      });\n\n      if (refreshToken) {\n        const newToken = await refreshAuthToken();\n        if (newToken) {\n          return newToken;\n        }\n      }\n\n      // Refresh failed and token is expired - clear access token but keep refresh for manual retry\n      console.log('[SafePlay Storage] Token expired and refresh failed');\n      await chrome.storage.local.remove([STORAGE_KEYS.AUTH_TOKEN]);\n      return null;\n    }\n\n    // If token is expiring soon (within buffer) but not yet expired, try to refresh\n    // but still return the current token if refresh fails\n    if (isExpiringSoon) {\n      console.log('[SafePlay Storage] Token expiring soon:', {\n        expiresIn: timeUntilExpiry / 1000 + ' seconds',\n        hasRefreshToken: !!refreshToken,\n      });\n\n      if (refreshToken) {\n        const newToken = await refreshAuthToken();\n        if (newToken) {\n          return newToken;\n        }\n        // Refresh failed but token is still valid - use it anyway\n        console.log('[SafePlay Storage] Proactive refresh failed but token still valid, using existing token');\n      }\n    }\n  }\n\n  return token;\n}\n\n// Get raw auth token without refresh check (for internal use)\nexport async function getAuthTokenRaw(): Promise<string | null> {\n  const result = await chrome.storage.local.get(STORAGE_KEYS.AUTH_TOKEN);\n  return result[STORAGE_KEYS.AUTH_TOKEN] || null;\n}\n\n// Check if a refresh token exists locally (for checking if user has explicit session)\nexport async function hasRefreshToken(): Promise<boolean> {\n  const result = await chrome.storage.local.get(STORAGE_KEYS.REFRESH_TOKEN);\n  return !!result[STORAGE_KEYS.REFRESH_TOKEN];\n}\n\nexport async function setAuthToken(token: string, refreshToken?: string, expiresAt?: number): Promise<void> {\n  // Detailed logging to diagnose token storage issues\n  console.log('[SafePlay Storage] setAuthToken called:', {\n    hasToken: !!token,\n    tokenLength: token?.length,\n    hasRefreshToken: !!refreshToken,\n    refreshTokenLength: refreshToken?.length,\n    refreshTokenPreview: refreshToken ? `${refreshToken.substring(0, 10)}...` : 'none',\n    expiresAt,\n    expiresAtType: typeof expiresAt,\n  });\n\n  const data: Record<string, unknown> = {\n    [STORAGE_KEYS.AUTH_TOKEN]: token,\n  };\n\n  if (refreshToken) {\n    data[STORAGE_KEYS.REFRESH_TOKEN] = refreshToken;\n  }\n\n  if (expiresAt) {\n    // Normalize expiresAt to seconds\n    // If the value is > 10 billion, it's likely in milliseconds (ms timestamps are ~13 digits)\n    // If the value is < 10 billion, it's likely in seconds (second timestamps are ~10 digits)\n    let expiresAtSeconds = expiresAt;\n    if (expiresAt > 10000000000) {\n      console.log('[SafePlay Storage] expiresAt appears to be in milliseconds, converting to seconds');\n      expiresAtSeconds = Math.floor(expiresAt / 1000);\n    }\n    data[STORAGE_KEYS.TOKEN_EXPIRES_AT] = expiresAtSeconds;\n    console.log('[SafePlay Storage] Storing expiresAt:', expiresAtSeconds, '(seconds), expires:', new Date(expiresAtSeconds * 1000).toISOString());\n  }\n\n  await chrome.storage.local.set(data);\n  console.log('[SafePlay Storage] Auth tokens stored successfully');\n}\n\nexport async function clearAuthToken(): Promise<void> {\n  await chrome.storage.local.remove([\n    STORAGE_KEYS.AUTH_TOKEN,\n    STORAGE_KEYS.REFRESH_TOKEN,\n    STORAGE_KEYS.TOKEN_EXPIRES_AT,\n  ]);\n}\n\nexport async function getUserId(): Promise<string | null> {\n  const result = await chrome.storage.local.get(STORAGE_KEYS.USER_ID);\n  return result[STORAGE_KEYS.USER_ID] || null;\n}\n\nexport async function setUserId(userId: string): Promise<void> {\n  await chrome.storage.local.set({ [STORAGE_KEYS.USER_ID]: userId });\n}\n\nexport async function getSubscriptionTier(): Promise<SubscriptionTier | null> {\n  const result = await chrome.storage.local.get(STORAGE_KEYS.SUBSCRIPTION_TIER);\n  return result[STORAGE_KEYS.SUBSCRIPTION_TIER] || null;\n}\n\nexport async function setSubscriptionTier(tier: SubscriptionTier): Promise<void> {\n  await chrome.storage.local.set({ [STORAGE_KEYS.SUBSCRIPTION_TIER]: tier });\n}\n\n// Credit Info storage with caching\nexport async function getCreditInfo(): Promise<CreditInfo | null> {\n  try {\n    const result = await chrome.storage.local.get([\n      STORAGE_KEYS.CREDIT_INFO,\n      STORAGE_KEYS.CREDIT_CACHE_TIME,\n    ]);\n\n    const cacheTime = result[STORAGE_KEYS.CREDIT_CACHE_TIME];\n    const creditInfo = result[STORAGE_KEYS.CREDIT_INFO];\n\n    // Check if cache is valid\n    if (cacheTime && creditInfo && Date.now() - cacheTime < CREDIT_CACHE_DURATION) {\n      return creditInfo;\n    }\n\n    return null; // Cache expired or not present\n  } catch (error) {\n    console.error('[SafePlay Storage] Error getting credit info:', error);\n    return null;\n  }\n}\n\nexport async function setCreditInfo(creditInfo: CreditInfo): Promise<void> {\n  try {\n    await chrome.storage.local.set({\n      [STORAGE_KEYS.CREDIT_INFO]: creditInfo,\n      [STORAGE_KEYS.CREDIT_CACHE_TIME]: Date.now(),\n    });\n  } catch (error) {\n    console.error('[SafePlay Storage] Error setting credit info:', error);\n  }\n}\n\nexport async function clearCreditInfo(): Promise<void> {\n  await chrome.storage.local.remove([\n    STORAGE_KEYS.CREDIT_INFO,\n    STORAGE_KEYS.CREDIT_CACHE_TIME,\n  ]);\n}\n\n// Update credit info after a filter operation (optimistic update)\nexport async function updateCreditsAfterFilter(creditCost: number): Promise<void> {\n  try {\n    const currentInfo = await getCreditInfo();\n    if (currentInfo) {\n      const updatedInfo: CreditInfo = {\n        ...currentInfo,\n        available: Math.max(0, currentInfo.available - creditCost),\n        used_this_period: currentInfo.used_this_period + creditCost,\n        percent_consumed: Math.min(\n          100,\n          ((currentInfo.used_this_period + creditCost) / currentInfo.plan_allocation) * 100\n        ),\n      };\n      await setCreditInfo(updatedInfo);\n    }\n  } catch (error) {\n    console.error('[SafePlay Storage] Error updating credits after filter:', error);\n  }\n}\n\ninterface CachedTranscriptEntry {\n  transcript: Transcript;\n  timestamp: number;\n}\n\ninterface TranscriptCache {\n  [youtubeId: string]: CachedTranscriptEntry;\n}\n\nexport async function getCachedTranscript(\n  youtubeId: string\n): Promise<Transcript | null> {\n  try {\n    const result = await chrome.storage.local.get(STORAGE_KEYS.CACHED_TRANSCRIPTS);\n    const cache = result[STORAGE_KEYS.CACHED_TRANSCRIPTS] || {};\n    const entry = cache[youtubeId];\n\n    if (!entry) return null;\n\n    // Handle both old format (direct transcript) and new format (with timestamp)\n    if (entry.transcript) {\n      // New format with timestamp\n      entry.timestamp = Date.now();\n      await chrome.storage.local.set({ [STORAGE_KEYS.CACHED_TRANSCRIPTS]: cache });\n      return entry.transcript;\n    } else if (entry.segments) {\n      // Old format - transcript stored directly, migrate to new format\n      const transcript = entry as Transcript;\n      cache[youtubeId] = { transcript, timestamp: Date.now() };\n      await chrome.storage.local.set({ [STORAGE_KEYS.CACHED_TRANSCRIPTS]: cache });\n      return transcript;\n    }\n\n    return null;\n  } catch (error) {\n    console.error('[SafePlay Storage] Error getting cached transcript:', error);\n    return null;\n  }\n}\n\nexport async function setCachedTranscript(\n  youtubeId: string,\n  transcript: Transcript\n): Promise<void> {\n  try {\n    const result = await chrome.storage.local.get(STORAGE_KEYS.CACHED_TRANSCRIPTS);\n    let cache: TranscriptCache = result[STORAGE_KEYS.CACHED_TRANSCRIPTS] || {};\n\n    // Add new entry with timestamp\n    cache[youtubeId] = {\n      transcript,\n      timestamp: Date.now(),\n    };\n\n    // Enforce cache limit - remove oldest entries if over limit\n    const entries = Object.entries(cache);\n    if (entries.length > MAX_CACHED_TRANSCRIPTS) {\n      // Sort by timestamp (oldest first) and keep only the newest\n      entries.sort((a, b) => a[1].timestamp - b[1].timestamp);\n      const toKeep = entries.slice(-MAX_CACHED_TRANSCRIPTS);\n      cache = Object.fromEntries(toKeep);\n      console.log(`[SafePlay Storage] Trimmed transcript cache to ${MAX_CACHED_TRANSCRIPTS} entries`);\n    }\n\n    await chrome.storage.local.set({ [STORAGE_KEYS.CACHED_TRANSCRIPTS]: cache });\n  } catch (error: unknown) {\n    // Handle quota exceeded error\n    if (error instanceof Error && error.message.includes('quota')) {\n      console.warn('[SafePlay Storage] Quota exceeded, clearing transcript cache...');\n      await clearCachedTranscripts();\n      // Retry with fresh cache\n      try {\n        const freshCache: TranscriptCache = {\n          [youtubeId]: { transcript, timestamp: Date.now() }\n        };\n        await chrome.storage.local.set({ [STORAGE_KEYS.CACHED_TRANSCRIPTS]: freshCache });\n        console.log('[SafePlay Storage] Cache cleared and new transcript saved');\n      } catch (retryError) {\n        console.error('[SafePlay Storage] Failed to save transcript after clearing cache:', retryError);\n      }\n    } else {\n      console.error('[SafePlay Storage] Error caching transcript:', error);\n    }\n  }\n}\n\nexport async function clearCachedTranscripts(): Promise<void> {\n  await chrome.storage.local.remove(STORAGE_KEYS.CACHED_TRANSCRIPTS);\n}\n\nexport async function clearAllData(): Promise<void> {\n  await chrome.storage.local.clear();\n}\n\nexport async function isAuthenticated(): Promise<boolean> {\n  const token = await getAuthToken();\n  return token !== null;\n}\n\n/**\n * Check if user is authenticated WITHOUT triggering any auto-refresh.\n * This is a strict check that only looks at local storage.\n * Use this when you need to verify auth state without potentially\n * re-authenticating via website cookies.\n */\nexport async function isAuthenticatedStrict(): Promise<boolean> {\n  const token = await getAuthTokenRaw();\n  if (!token) {\n    return false;\n  }\n\n  // Also check if token is expired\n  const result = await chrome.storage.local.get(STORAGE_KEYS.TOKEN_EXPIRES_AT);\n  const expiresAt = result[STORAGE_KEYS.TOKEN_EXPIRES_AT];\n\n  if (expiresAt) {\n    const now = Date.now();\n    let expiresAtMs = expiresAt;\n    if (expiresAt < 10000000000) {\n      // It's in seconds, convert to milliseconds\n      expiresAtMs = expiresAt * 1000;\n    }\n\n    // Token is expired\n    if (expiresAtMs < now) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n// Filtered Videos Storage - tracks which videos have been filtered\nexport async function getFilteredVideos(): Promise<string[]> {\n  try {\n    const result = await chrome.storage.local.get(STORAGE_KEYS.FILTERED_VIDEOS);\n    return result[STORAGE_KEYS.FILTERED_VIDEOS] || [];\n  } catch (error) {\n    console.error('[SafePlay Storage] Error getting filtered videos:', error);\n    return [];\n  }\n}\n\nexport async function addFilteredVideo(youtubeId: string): Promise<void> {\n  try {\n    const videos = await getFilteredVideos();\n    if (!videos.includes(youtubeId)) {\n      videos.push(youtubeId);\n      // Keep only last 500 videos to prevent storage bloat\n      const trimmedVideos = videos.slice(-500);\n      await chrome.storage.local.set({ [STORAGE_KEYS.FILTERED_VIDEOS]: trimmedVideos });\n    }\n  } catch (error) {\n    console.error('[SafePlay Storage] Error adding filtered video:', error);\n  }\n}\n\nexport async function isVideoFiltered(youtubeId: string): Promise<boolean> {\n  try {\n    const videos = await getFilteredVideos();\n    return videos.includes(youtubeId);\n  } catch (error) {\n    console.error('[SafePlay Storage] Error checking if video filtered:', error);\n    return false;\n  }\n}\n\nexport async function removeFilteredVideo(youtubeId: string): Promise<void> {\n  const videos = await getFilteredVideos();\n  const filtered = videos.filter(id => id !== youtubeId);\n  await chrome.storage.local.set({ [STORAGE_KEYS.FILTERED_VIDEOS]: filtered });\n}\n\nexport async function clearFilteredVideos(): Promise<void> {\n  await chrome.storage.local.remove(STORAGE_KEYS.FILTERED_VIDEOS);\n}\n\n// Profile cache duration in milliseconds (10 minutes)\nconst PROFILE_CACHE_DURATION = 10 * 60 * 1000;\n\n// User Profile Storage\nexport async function getUserProfile(): Promise<UserProfile | null> {\n  try {\n    const result = await chrome.storage.local.get([\n      STORAGE_KEYS.USER_PROFILE,\n      STORAGE_KEYS.PROFILE_CACHE_TIME,\n    ]);\n\n    const cacheTime = result[STORAGE_KEYS.PROFILE_CACHE_TIME];\n    const profile = result[STORAGE_KEYS.USER_PROFILE];\n\n    // Check if cache is valid\n    if (cacheTime && profile && Date.now() - cacheTime < PROFILE_CACHE_DURATION) {\n      return profile;\n    }\n\n    return null;\n  } catch (error) {\n    console.error('[SafePlay Storage] Error getting user profile:', error);\n    return null;\n  }\n}\n\nexport async function setUserProfile(profile: UserProfile): Promise<void> {\n  try {\n    await chrome.storage.local.set({\n      [STORAGE_KEYS.USER_PROFILE]: profile,\n      [STORAGE_KEYS.PROFILE_CACHE_TIME]: Date.now(),\n    });\n  } catch (error) {\n    console.error('[SafePlay Storage] Error setting user profile:', error);\n  }\n}\n\nexport async function getUserSubscription(): Promise<UserSubscription | null> {\n  try {\n    const result = await chrome.storage.local.get(STORAGE_KEYS.USER_SUBSCRIPTION);\n    return result[STORAGE_KEYS.USER_SUBSCRIPTION] || null;\n  } catch (error) {\n    console.error('[SafePlay Storage] Error getting user subscription:', error);\n    return null;\n  }\n}\n\nexport async function setUserSubscription(subscription: UserSubscription | null): Promise<void> {\n  try {\n    if (subscription) {\n      await chrome.storage.local.set({ [STORAGE_KEYS.USER_SUBSCRIPTION]: subscription });\n    } else {\n      await chrome.storage.local.remove(STORAGE_KEYS.USER_SUBSCRIPTION);\n    }\n  } catch (error) {\n    console.error('[SafePlay Storage] Error setting user subscription:', error);\n  }\n}\n\nexport async function getUserCredits(): Promise<UserCredits | null> {\n  try {\n    const result = await chrome.storage.local.get(STORAGE_KEYS.USER_CREDITS);\n    return result[STORAGE_KEYS.USER_CREDITS] || null;\n  } catch (error) {\n    console.error('[SafePlay Storage] Error getting user credits:', error);\n    return null;\n  }\n}\n\nexport async function setUserCredits(credits: UserCredits | null): Promise<void> {\n  try {\n    if (credits) {\n      await chrome.storage.local.set({ [STORAGE_KEYS.USER_CREDITS]: credits });\n    } else {\n      await chrome.storage.local.remove(STORAGE_KEYS.USER_CREDITS);\n    }\n  } catch (error) {\n    console.error('[SafePlay Storage] Error setting user credits:', error);\n  }\n}\n\n// Clear all auth-related data (for logout)\nexport async function clearAuthData(): Promise<void> {\n  try {\n    await chrome.storage.local.remove([\n      STORAGE_KEYS.AUTH_TOKEN,\n      STORAGE_KEYS.REFRESH_TOKEN,\n      STORAGE_KEYS.TOKEN_EXPIRES_AT,\n      STORAGE_KEYS.USER_ID,\n      STORAGE_KEYS.SUBSCRIPTION_TIER,\n      STORAGE_KEYS.CREDIT_INFO,\n      STORAGE_KEYS.CREDIT_CACHE_TIME,\n      STORAGE_KEYS.USER_PROFILE,\n      STORAGE_KEYS.USER_SUBSCRIPTION,\n      STORAGE_KEYS.USER_CREDITS,\n      STORAGE_KEYS.PROFILE_CACHE_TIME,\n    ]);\n    console.log('[SafePlay Storage] Auth data cleared');\n  } catch (error) {\n    console.error('[SafePlay Storage] Error clearing auth data:', error);\n  }\n}\n\n// Get full auth state\nexport async function getFullAuthState(): Promise<{\n  isAuthenticated: boolean;\n  profile: UserProfile | null;\n  subscription: UserSubscription | null;\n  credits: UserCredits | null;\n  token: string | null;\n}> {\n  const token = await getAuthToken();\n  const profile = await getUserProfile();\n  const subscription = await getUserSubscription();\n  const credits = await getUserCredits();\n\n  return {\n    isAuthenticated: token !== null,\n    profile,\n    subscription,\n    credits,\n    token,\n  };\n}\n","// API Response Types\n\nexport interface TranscriptSegment {\n  text: string;\n  start_time: number;\n  end_time: number;\n}\n\nexport interface Transcript {\n  id: string;\n  youtube_id?: string; // May be set from context\n  full_text?: string;\n  segments: TranscriptSegment[];\n  duration?: number;\n  language?: string;\n  created_at?: string;\n}\n\n// Video metadata from preview endpoint\nexport interface VideoMetadata {\n  youtube_id: string;\n  title: string;\n  duration: number; // in seconds\n  thumbnail?: string;\n  channel?: string;\n}\n\n// Credit system types\nexport interface CreditInfo {\n  available: number;\n  used_this_period: number;\n  plan_allocation: number;\n  percent_consumed: number;\n  plan?: 'free' | 'base' | 'professional' | 'unlimited';\n  reset_date?: string;\n}\n\n// Preview response - check cost before filtering (matches actual API format)\nexport interface PreviewResponse {\n  youtube_id: string;\n  title: string;\n  channel_name?: string;\n  duration_seconds: number;\n  thumbnail_url?: string;\n  credit_cost: number;\n  user_credits: number;\n  has_sufficient_credits: boolean;\n  cached: boolean;\n  has_transcript: boolean;\n  credit_cost_note?: string; // Note when duration/cost is unknown\n  error?: string;\n  error_code?: 'AGE_RESTRICTED' | 'VIDEO_UNAVAILABLE' | 'UNAUTHORIZED' | string;\n}\n\n// Credit balance response\nexport interface CreditBalanceResponse {\n  success: boolean;\n  credits: CreditInfo;\n  error?: string;\n}\n\n// Filter start response\nexport interface FilterStartResponse {\n  success: boolean;\n  status: 'completed' | 'processing' | 'failed';\n  cached?: boolean;\n  transcript?: Transcript;\n  job_id?: string;\n  message?: string;\n  error?: string;\n  error_code?: 'INSUFFICIENT_CREDITS' | 'AGE_RESTRICTED' | 'VIDEO_UNAVAILABLE' | 'UNAUTHORIZED' | string;\n  credits_required?: number;\n  credits_available?: number;\n}\n\n// Job status response\nexport interface JobStatusResponse {\n  status: 'pending' | 'downloading' | 'transcribing' | 'completed' | 'failed';\n  progress: number;\n  message?: string;\n  transcript?: Transcript;\n  error?: string;\n  error_code?: 'AGE_RESTRICTED' | 'VIDEO_UNAVAILABLE' | string;\n  video?: {\n    youtube_id: string;\n    title?: string;\n  };\n}\n\n// Legacy FilterResponse - kept for compatibility during migration\nexport interface FilterResponse {\n  status: 'completed' | 'processing' | 'failed';\n  cached?: boolean;\n  transcript?: Transcript;\n  job_id?: string;\n  message?: string;\n  error?: string;\n  error_code?: string;  // 'AGE_RESTRICTED', 'VIDEO_UNAVAILABLE', etc.\n}\n\n// Button state for UX\nexport type ButtonState =\n  | 'idle'\n  | 'connecting'\n  | 'downloading'\n  | 'transcribing'\n  | 'processing'\n  | 'filtering'\n  | 'paused'  // Filter is paused (user can re-enable)\n  | 'error'\n  | 'age-restricted';  // Video is age-restricted and cannot be filtered\n\nexport interface ButtonStateInfo {\n  state: ButtonState;\n  text: string;\n  progress?: number;\n  intervalCount?: number;\n  error?: string;\n  videoId?: string; // Track which video this state belongs to (for Shorts)\n}\n\n// Profanity Types\n\nexport type SeverityLevel = 'mild' | 'moderate' | 'severe' | 'religious';\n\nexport interface ProfanityWord {\n  word: string;\n  severity: SeverityLevel;\n}\n\nexport interface MuteInterval {\n  start: number;\n  end: number;\n  word: string;\n  severity: SeverityLevel;\n}\n\nexport interface ProfanityMatch {\n  segmentIndex: number;\n  word: string;\n  severity: SeverityLevel;\n  startTime: number;\n  endTime: number;\n  isPartialMatch: boolean;\n  matchedPortion?: string;\n}\n\n// User Preferences\n\nexport type FilterMode = 'mute' | 'bleep';\n\nexport interface UserPreferences {\n  enabled: boolean;\n  filterMode: FilterMode;\n  severityLevels: {\n    mild: boolean;\n    moderate: boolean;\n    severe: boolean;\n    religious: boolean;\n  };\n  customBlacklist: string[];\n  customWhitelist: string[];\n  paddingMs: number; // Legacy/fallback symmetric padding\n  paddingBeforeMs?: number; // Padding before word starts (catches attack)\n  paddingAfterMs?: number; // Padding after word ends (catches release)\n  mergeThresholdMs: number;\n  autoEnableForFilteredVideos: boolean; // Auto-enable filter for previously filtered videos\n}\n\nexport const DEFAULT_PREFERENCES: UserPreferences = {\n  enabled: true,\n  filterMode: 'mute',\n  severityLevels: {\n    mild: false,\n    moderate: true,\n    severe: true,\n    religious: false, // Off by default - user opt-in\n  },\n  customBlacklist: [],\n  customWhitelist: [],\n  paddingMs: 50, // Legacy/fallback symmetric padding\n  paddingBeforeMs: 100, // Padding before word - smooth fade adds ~130ms effective lead time\n  paddingAfterMs: 30, // Padding after word ends\n  mergeThresholdMs: 100,\n  autoEnableForFilteredVideos: true, // Auto-enable filter for previously filtered videos\n};\n\n// Storage Types\n\nexport type SubscriptionTier = 'free' | 'base' | 'professional' | 'unlimited';\n\nexport interface StorageData {\n  preferences: UserPreferences;\n  authToken?: string;\n  userId?: string;\n  subscriptionTier?: SubscriptionTier;\n  creditInfo?: CreditInfo;\n  cachedTranscripts: Record<string, Transcript>;\n}\n\n// Message Types (between content script and background)\n\nexport type MessageType =\n  | 'GET_FILTER'\n  | 'GET_PREVIEW'\n  | 'START_FILTER'\n  | 'CHECK_JOB'\n  | 'GET_CREDITS'\n  | 'GET_PREFERENCES'\n  | 'SET_PREFERENCES'\n  | 'GET_AUTH_STATUS'\n  | 'CHECK_AUTH_STRICT'\n  | 'GET_USER_PROFILE'\n  | 'LOGOUT'\n  | 'OPEN_LOGIN'\n  | 'CLEAR_CACHE';\n\nexport interface Message<T = unknown> {\n  type: MessageType;\n  payload?: T;\n}\n\nexport interface MessageResponse<T = unknown> {\n  success: boolean;\n  data?: T;\n  error?: string;\n}\n\n// Preview data passed to content script\nexport interface PreviewData {\n  video: VideoMetadata;\n  creditCost: number;\n  creditCostNote?: string; // Note when cost is unknown (e.g., \"~1 credit per minute\")\n  creditCostUnknown?: boolean; // True when duration unavailable\n  userCredits: number;\n  hasSufficientCredits: boolean;\n  isCached: boolean;\n}\n\n// Filter confirmation payload from content script\nexport interface FilterConfirmPayload {\n  youtubeId: string;\n  filterType?: 'mute' | 'bleep';\n  customWords?: string[];\n  creditCost?: number;\n}\n\n// User Profile Types\nexport interface UserProfile {\n  id: string;\n  email: string;\n  full_name?: string;\n  avatar_url?: string;\n  created_at?: string;\n}\n\nexport interface UserSubscription {\n  id: string;\n  user_id: string;\n  plan_id: string;\n  status: 'active' | 'canceled' | 'past_due' | 'paused';\n  current_period_start?: string;\n  current_period_end?: string;\n  plans?: {\n    id: string;\n    name: string;\n    monthly_credits: number;\n  };\n}\n\nexport interface UserCredits {\n  user_id: string;\n  available_credits: number;\n  used_this_period: number;\n  rollover_credits: number;\n  updated_at?: string;\n}\n\nexport interface UserProfileResponse {\n  user: UserProfile;\n  subscription: UserSubscription | null;\n  credits: UserCredits | null;\n}\n\nexport interface AuthState {\n  isAuthenticated: boolean;\n  user: UserProfile | null;\n  subscription: UserSubscription | null;\n  credits: UserCredits | null;\n  token: string | null;\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import {\n  FilterStartResponse,\n  JobStatusResponse,\n  Transcript,\n  PreviewResponse,\n  CreditBalanceResponse,\n  UserProfileResponse,\n} from '../types';\nimport { getAuthToken, refreshAuthToken, clearAuthData, hasRefreshToken } from '../utils/storage';\n\n// API URL for the SafePlay website API\nconst API_BASE_URL = 'https://trysafeplay.com';\n\n// Verbose logging\nfunction logApi(...args: unknown[]): void {\n  console.log('[SafePlay API]', ...args);\n}\n\ninterface RequestOptions {\n  method?: 'GET' | 'POST' | 'PUT' | 'DELETE';\n  body?: unknown;\n  requiresAuth?: boolean;\n  _isRetry?: boolean; // Internal flag to prevent infinite retry loops\n}\n\nexport class ApiError extends Error {\n  constructor(\n    message: string,\n    public statusCode: number,\n    public response?: unknown,\n    public errorCode?: string  // 'AGE_RESTRICTED', 'VIDEO_UNAVAILABLE', 'INSUFFICIENT_CREDITS', etc.\n  ) {\n    super(message);\n    this.name = 'ApiError';\n  }\n}\n\nasync function request<T>(\n  endpoint: string,\n  options: RequestOptions = {}\n): Promise<T> {\n  const { method = 'GET', body, requiresAuth = true, _isRetry = false } = options;\n  const url = `${API_BASE_URL}${endpoint}`;\n\n  logApi(`>>> ${method} ${url}`, body ? JSON.stringify(body) : '');\n\n  const headers: Record<string, string> = {\n    'Content-Type': 'application/json',\n  };\n\n  if (requiresAuth) {\n    const token = await getAuthToken();\n    logApi('Auth token:', token ? `${token.substring(0, 20)}...` : 'none');\n    if (token) {\n      headers['Authorization'] = `Bearer ${token}`;\n    }\n  }\n\n  try {\n    const response = await fetch(url, {\n      method,\n      headers,\n      body: body ? JSON.stringify(body) : undefined,\n    });\n\n    logApi(`<<< ${response.status} ${response.statusText}`);\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      logApi('Error response body:', errorText);\n\n      let errorData: Record<string, unknown> = {};\n      try {\n        errorData = JSON.parse(errorText);\n      } catch {\n        errorData = { rawError: errorText };\n      }\n\n      // Handle 401 Unauthorized - try to refresh token and retry\n      if (response.status === 401 && requiresAuth && !_isRetry) {\n        logApi('Got 401, checking if refresh is possible...');\n\n        // Only attempt refresh if we have a stored refresh token\n        // This prevents silently re-authenticating via website cookies\n        // when the user has explicitly logged out from the extension\n        const canRefresh = await hasRefreshToken();\n\n        if (canRefresh) {\n          logApi('Has refresh token, attempting token refresh...');\n          const newToken = await refreshAuthToken();\n\n          if (newToken) {\n            logApi('Token refreshed, retrying request...');\n            // Retry the request with the new token\n            return request<T>(endpoint, { ...options, _isRetry: true });\n          }\n        } else {\n          logApi('No refresh token stored - user is logged out, skipping refresh');\n        }\n\n        logApi('Token refresh failed or skipped, clearing auth data and notifying UI');\n        // Clear auth data so UI updates to show sign-in state\n        await clearAuthData();\n\n        // Broadcast logout to all tabs so UI updates\n        if (typeof chrome !== 'undefined' && chrome.tabs) {\n          chrome.tabs.query({}).then(tabs => {\n            for (const tab of tabs) {\n              if (tab.id) {\n                chrome.tabs.sendMessage(tab.id, {\n                  type: 'AUTH_STATE_CHANGED',\n                  payload: { isAuthenticated: false },\n                }).catch(() => {});\n              }\n            }\n          });\n        }\n\n        throw new ApiError(\n          'Session expired. Please sign in again.',\n          401,\n          errorData,\n          'SESSION_EXPIRED'\n        );\n      }\n\n      throw new ApiError(\n        errorData.message as string || errorData.error as string || `Request failed with status ${response.status}`,\n        response.status,\n        errorData,\n        errorData.error_code as string\n      );\n    }\n\n    const data = await response.json();\n    logApi('Response data:', JSON.stringify(data).substring(0, 500));\n    return data;\n  } catch (error) {\n    if (error instanceof ApiError) {\n      throw error;\n    }\n\n    // Network or other error\n    const message = error instanceof Error ? error.message : 'Network error';\n    logApi('Request failed:', message);\n    throw new ApiError(message, 0, { networkError: true, originalError: String(error) });\n  }\n}\n\n/**\n * Get video preview - retrieves video metadata and credit cost before filtering\n * This should be called first to check if the user has enough credits\n */\nexport async function getPreview(youtubeId: string): Promise<PreviewResponse> {\n  logApi('=== getPreview ===', youtubeId);\n  return request<PreviewResponse>('/api/filter/preview', {\n    method: 'POST',\n    body: { youtube_id: youtubeId },\n    requiresAuth: true,\n  });\n}\n\n/**\n * Get user's credit balance\n */\nexport async function getCreditBalance(): Promise<CreditBalanceResponse> {\n  logApi('=== getCreditBalance ===');\n  return request<CreditBalanceResponse>('/api/credits/balance', {\n    method: 'GET',\n    requiresAuth: true,\n  });\n}\n\n/**\n * Get user profile including subscription and credits\n */\nexport async function getUserProfile(): Promise<UserProfileResponse> {\n  logApi('=== getUserProfile ===');\n  return request<UserProfileResponse>('/api/user/profile', {\n    method: 'GET',\n    requiresAuth: true,\n  });\n}\n\n/**\n * Start filtering a video - initiates transcription if not cached\n * Credits are deducted upon completion\n */\nexport async function startFilter(\n  youtubeId: string,\n  filterType: 'mute' | 'bleep' = 'mute',\n  customWords?: string[]\n): Promise<FilterStartResponse> {\n  logApi('=== startFilter ===', youtubeId, filterType);\n  return request<FilterStartResponse>('/api/filter/start', {\n    method: 'POST',\n    body: {\n      youtube_id: youtubeId,\n      filter_type: filterType,\n      custom_words: customWords,\n    },\n    requiresAuth: true,\n  });\n}\n\n/**\n * Check job status - poll for transcription progress\n */\nexport async function checkJobStatus(jobId: string): Promise<JobStatusResponse> {\n  logApi('=== checkJobStatus ===', jobId);\n  return request<JobStatusResponse>(`/api/filter/status/${jobId}`, {\n    method: 'GET',\n    requiresAuth: true,\n  });\n}\n\n/**\n * Get cached transcript by YouTube ID\n * @deprecated Use getPreview and startFilter instead\n */\nexport async function getTranscript(youtubeId: string): Promise<Transcript> {\n  logApi('=== getTranscript ===', youtubeId);\n  return request<Transcript>(`/api/transcript/${youtubeId}`, {\n    requiresAuth: true,\n  });\n}\n\n/**\n * Poll for transcript completion with progress updates\n */\nexport async function pollForTranscript(\n  jobId: string,\n  onProgress?: (progress: number, message?: string) => void,\n  maxAttempts = 120,\n  intervalMs = 2000\n): Promise<Transcript> {\n  logApi('=== pollForTranscript ===', jobId);\n  let attempts = 0;\n\n  while (attempts < maxAttempts) {\n    const status = await checkJobStatus(jobId);\n\n    if (onProgress) {\n      onProgress(status.progress, status.message);\n    }\n\n    if (status.status === 'completed' && status.transcript) {\n      logApi('Poll completed, got transcript');\n      return status.transcript;\n    }\n\n    if (status.status === 'failed') {\n      logApi('Poll failed:', status.error, 'error_code:', status.error_code);\n      throw new ApiError(\n        status.error || 'Transcription failed',\n        500,\n        status,\n        status.error_code\n      );\n    }\n\n    logApi(`Poll attempt ${attempts + 1}/${maxAttempts}, status: ${status.status}, progress: ${status.progress}`);\n    await new Promise((resolve) => setTimeout(resolve, intervalMs));\n    attempts++;\n  }\n\n  throw new ApiError('Transcription timed out', 408);\n}\n\n/**\n * Main entry point for filtering - handles preview, credit check, and starting filter\n * Use this for new integrations instead of the legacy requestFilter\n */\nexport async function getOrRequestTranscript(\n  youtubeId: string,\n  onProgress?: (progress: number, message?: string) => void,\n  skipPreview = false\n): Promise<{ transcript: Transcript; creditCost: number; wasCached: boolean }> {\n  logApi('=== getOrRequestTranscript ===', youtubeId);\n\n  // Step 1: Get preview (unless skipped, e.g., for cached videos)\n  if (!skipPreview) {\n    const preview = await getPreview(youtubeId);\n\n    // Check for error in response\n    if (preview.error || preview.error_code) {\n      throw new ApiError(\n        preview.error || 'Failed to get video preview',\n        400,\n        preview,\n        preview.error_code\n      );\n    }\n\n    if (!preview.has_sufficient_credits) {\n      throw new ApiError(\n        `Insufficient credits. Need ${preview.credit_cost}, have ${preview.user_credits}`,\n        402,\n        preview,\n        'INSUFFICIENT_CREDITS'\n      );\n    }\n  }\n\n  // Step 2: Start filtering\n  const response = await startFilter(youtubeId);\n\n  if (!response.success) {\n    throw new ApiError(\n      response.error || 'Failed to start filter',\n      400,\n      response,\n      response.error_code\n    );\n  }\n\n  if (response.status === 'completed' && response.transcript) {\n    logApi('Got completed/cached transcript');\n    return {\n      transcript: response.transcript,\n      creditCost: 0, // Cached transcripts don't cost credits\n      wasCached: response.cached || false,\n    };\n  }\n\n  if (response.status === 'processing' && response.job_id) {\n    logApi('Processing started, job_id:', response.job_id);\n    const transcript = await pollForTranscript(response.job_id, onProgress);\n    return {\n      transcript,\n      creditCost: 1, // Credits deducted after completion\n      wasCached: false,\n    };\n  }\n\n  throw new ApiError('Unexpected response from filter API', 500, response);\n}\n\n// Legacy function for backwards compatibility during migration\nexport async function requestFilter(youtubeId: string): Promise<{\n  status: 'completed' | 'processing' | 'failed';\n  cached?: boolean;\n  transcript?: Transcript;\n  job_id?: string;\n  error?: string;\n  error_code?: string;\n}> {\n  logApi('=== requestFilter (legacy) ===', youtubeId);\n  try {\n    const response = await startFilter(youtubeId);\n    return {\n      status: response.status,\n      cached: response.cached,\n      transcript: response.transcript,\n      job_id: response.job_id,\n      error: response.error,\n      error_code: response.error_code,\n    };\n  } catch (error) {\n    if (error instanceof ApiError) {\n      return {\n        status: 'failed',\n        error: error.message,\n        error_code: error.errorCode,\n      };\n    }\n    throw error;\n  }\n}\n\n/**\n * Record history for a cached video (fire and forget)\n * This is called when serving from local cache to keep server history in sync\n */\nexport interface RecordHistoryParams {\n  youtubeId: string;\n  title?: string;\n  channelName?: string;\n  durationSeconds?: number;\n  filterType?: 'mute' | 'bleep';\n  customWords?: string[];\n}\n\nexport async function recordCachedHistory(params: RecordHistoryParams): Promise<void> {\n  logApi('=== recordCachedHistory ===', params.youtubeId);\n\n  try {\n    await request<{ success: boolean; history_id?: string }>('/api/filter/record-history', {\n      method: 'POST',\n      body: {\n        youtube_id: params.youtubeId,\n        title: params.title || null,\n        channel_name: params.channelName || null,\n        duration_seconds: params.durationSeconds || null,\n        filter_type: params.filterType || 'mute',\n        custom_words: params.customWords || [],\n      },\n      requiresAuth: true,\n    });\n    logApi('History recorded successfully for:', params.youtubeId);\n  } catch (error) {\n    // Non-critical - don't let this affect user experience\n    // Just log and continue\n    logApi('Failed to record history (non-critical):', error instanceof Error ? error.message : error);\n  }\n}\n\nexport { ApiError as default };\n","// SafePlay Background Service Worker\nimport {\n  Message,\n  MessageResponse,\n  Transcript,\n  UserPreferences,\n  JobStatusResponse,\n  CreditInfo,\n  PreviewData,\n  FilterConfirmPayload,\n  AuthState,\n} from '../types';\nimport {\n  getPreferences,\n  setPreferences,\n  getCachedTranscript,\n  setCachedTranscript,\n  getAuthToken,\n  clearCachedTranscripts,\n  isAuthenticated,\n  getCreditInfo,\n  setCreditInfo,\n  clearAuthData,\n  setUserProfile,\n  setUserSubscription,\n  setUserCredits,\n  getFullAuthState,\n  updateCreditsAfterFilter,\n} from '../utils/storage';\nimport {\n  requestFilter,\n  checkJobStatus,\n  getPreview,\n  startFilter,\n  getCreditBalance,\n  getUserProfile,\n  recordCachedHistory,\n} from '../api/client';\n\nfunction log(...args: unknown[]): void {\n  // Always log for debugging\n  console.log('[SafePlay BG]', ...args);\n}\n\nfunction logError(...args: unknown[]): void {\n  console.error('[SafePlay BG ERROR]', ...args);\n}\n\n// Badge management - shows remaining credits on extension icon\nfunction updateBadge(creditInfo: CreditInfo | null): void {\n  if (!creditInfo) {\n    chrome.action.setBadgeText({ text: '' });\n    return;\n  }\n\n  const { available } = creditInfo;\n  const text = available.toString();\n\n  chrome.action.setBadgeText({ text });\n\n  // Color-code: green for healthy, orange for low, red for empty\n  let color: string;\n  if (available === 0) {\n    color = '#F44336'; // Red\n  } else if (available <= 5) {\n    color = '#FF9800'; // Orange\n  } else {\n    color = '#4CAF50'; // Green\n  }\n  chrome.action.setBadgeBackgroundColor({ color });\n}\n\nfunction clearBadge(): void {\n  chrome.action.setBadgeText({ text: '' });\n}\n\n// Listen for credit info changes in storage to keep badge in sync\nchrome.storage.onChanged.addListener((changes, areaName) => {\n  if (areaName !== 'local') return;\n\n  if (changes.safeplay_credit_info) {\n    const newValue = changes.safeplay_credit_info.newValue as CreditInfo | undefined;\n    updateBadge(newValue || null);\n  }\n});\n\n// Restore badge from storage on every service worker wake-up.\n// Reads directly from storage ignoring cache TTL ‚Äî even \"stale\" data is better than an empty badge.\n// This is fast (local storage only, no network) so it completes before the worker can be killed.\nchrome.storage.local.get('safeplay_credit_info').then((result) => {\n  const creditInfo = result['safeplay_credit_info'] as CreditInfo | undefined;\n  if (creditInfo) {\n    updateBadge(creditInfo);\n  }\n});\n\n// Full initialization: fetch fresh credits from API if authenticated.\n// Called from onInstalled/onStartup event handlers where Chrome keeps the worker alive.\nasync function initBadge(): Promise<void> {\n  try {\n    const token = await getAuthToken();\n    if (!token) {\n      clearBadge();\n      return;\n    }\n\n    const response = await getCreditBalance();\n    if (response.success && response.credits) {\n      await setCreditInfo(response.credits);\n    }\n  } catch {\n    // Ignore errors ‚Äî badge will update on next alarm or credit fetch\n  }\n}\n\n// Periodic credit refresh via chrome.alarms ‚Äî keeps badge accurate in real-time\nconst CREDIT_REFRESH_ALARM = 'safeplay_credit_refresh';\nconst CREDIT_REFRESH_INTERVAL_MIN = 2; // Every 2 minutes\n\nchrome.alarms.create(CREDIT_REFRESH_ALARM, {\n  periodInMinutes: CREDIT_REFRESH_INTERVAL_MIN,\n});\n\nchrome.alarms.onAlarm.addListener(async (alarm) => {\n  if (alarm.name !== CREDIT_REFRESH_ALARM) return;\n\n  const token = await getAuthToken();\n  if (!token) return;\n\n  log('Alarm: refreshing credits');\n  await refreshCredits();\n});\n\n// Message handler\nchrome.runtime.onMessage.addListener(\n  (message: Message, sender, sendResponse: (response: MessageResponse) => void) => {\n    handleMessage(message, sender)\n      .then(sendResponse)\n      .catch((error) => sendResponse({ success: false, error: String(error) }));\n    return true; // Keep channel open for async\n  }\n);\n\nasync function handleMessage(\n  message: Message,\n  _sender: chrome.runtime.MessageSender\n): Promise<MessageResponse> {\n  log('Received message:', message.type);\n\n  try {\n    switch (message.type) {\n      case 'GET_FILTER':\n        return await handleGetFilter(message.payload as { youtubeId: string });\n\n      case 'GET_PREVIEW':\n        return await handleGetPreview(message.payload as { youtubeId: string });\n\n      case 'START_FILTER':\n        return await handleStartFilter(message.payload as FilterConfirmPayload);\n\n      case 'CHECK_JOB':\n        return await handleCheckJob(message.payload as { jobId: string });\n\n      case 'GET_CREDITS':\n        return await handleGetCredits();\n\n      case 'GET_PREFERENCES':\n        return await handleGetPreferences();\n\n      case 'SET_PREFERENCES':\n        return await handleSetPreferences(\n          message.payload as Partial<UserPreferences>\n        );\n\n      case 'GET_AUTH_STATUS':\n        return await handleGetAuthStatus();\n\n      case 'CHECK_AUTH_STRICT':\n        return await handleCheckAuthStrict();\n\n      case 'GET_USER_PROFILE':\n        return await handleGetUserProfile();\n\n      case 'LOGOUT':\n        return await handleLogout();\n\n      case 'OPEN_LOGIN':\n        return await handleOpenLogin();\n\n      case 'CLEAR_CACHE':\n        return await handleClearCache();\n\n      default:\n        return { success: false, error: 'Unknown message type' };\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n    log('Message handler error:', errorMessage);\n    return { success: false, error: errorMessage };\n  }\n}\n\n// Handle video preview request - check credits and get video info\nasync function handleGetPreview(\n  payload: { youtubeId: string }\n): Promise<MessageResponse<PreviewData>> {\n  const { youtubeId } = payload;\n  log('handleGetPreview called with youtubeId:', youtubeId);\n\n  // Check local cache first\n  const cached = await getCachedTranscript(youtubeId);\n  if (cached) {\n    log('Found in local cache, preview shows 0 cost');\n    // Get current credit info for display\n    let userCredits = 0;\n    const creditInfo = await getCreditInfo();\n    if (creditInfo) {\n      userCredits = creditInfo.available;\n    }\n\n    return {\n      success: true,\n      data: {\n        video: {\n          youtube_id: youtubeId,\n          title: 'Cached Video',\n          duration: 0,\n        },\n        creditCost: 0,\n        userCredits,\n        hasSufficientCredits: true,\n        isCached: true,\n      },\n    };\n  }\n\n  log('Not in local cache, fetching preview from API...');\n\n  try {\n    const preview = await getPreview(youtubeId);\n    log('Preview response:', JSON.stringify(preview).substring(0, 300));\n\n    // Check for error response\n    if (preview.error || preview.error_code) {\n      return {\n        success: false,\n        error: preview.error || `Error: ${preview.error_code}`,\n        data: undefined,\n      };\n    }\n\n    // Update cached credit info\n    if (preview.user_credits !== undefined) {\n      const existingInfo = await getCreditInfo();\n      if (existingInfo) {\n        await setCreditInfo({\n          ...existingInfo,\n          available: preview.user_credits,\n        });\n      }\n    }\n\n    // Convert API response format to PreviewData format\n    // Note: credit_cost === 0 with no transcript means unknown duration, not free\n    const isUnknownCost = preview.credit_cost === 0 && !preview.cached && !preview.has_transcript;\n\n    return {\n      success: true,\n      data: {\n        video: {\n          youtube_id: preview.youtube_id,\n          title: preview.title,\n          duration: preview.duration_seconds,\n          thumbnail: preview.thumbnail_url,\n          channel: preview.channel_name,\n        },\n        creditCost: preview.credit_cost,\n        creditCostNote: preview.credit_cost_note,\n        creditCostUnknown: isUnknownCost,\n        userCredits: preview.user_credits,\n        hasSufficientCredits: preview.has_sufficient_credits,\n        isCached: preview.cached || preview.has_transcript,\n      },\n    };\n  } catch (error) {\n    logError('handleGetPreview error:', error);\n    const errorMessage = error instanceof Error ? error.message : 'Failed to get preview';\n    return { success: false, error: errorMessage };\n  }\n}\n\n// Handle start filter request - actually start the filtering process\nasync function handleStartFilter(\n  payload: FilterConfirmPayload\n): Promise<MessageResponse<{ status: string; transcript?: Transcript; jobId?: string; error?: string; error_code?: string }>> {\n  const { youtubeId, filterType = 'mute', customWords, creditCost } = payload;\n  log('handleStartFilter called:', { youtubeId, filterType, creditCost });\n\n  // Check local cache first\n  const cached = await getCachedTranscript(youtubeId);\n  if (cached) {\n    log('Found in local cache, returning cached transcript');\n\n    // Record history for cached video (fire and forget - don't await)\n    recordCachedHistory({\n      youtubeId,\n      filterType,\n      customWords,\n    }).catch(() => {\n      // Silently ignore - already logged in the function\n    });\n\n    return {\n      success: true,\n      data: { status: 'cached', transcript: cached },\n    };\n  }\n\n  try {\n    const response = await startFilter(youtubeId, filterType, customWords);\n    log('Start filter response:', JSON.stringify(response).substring(0, 300));\n\n    // Check for explicit failure or error\n    if (response.status === 'failed' || response.error) {\n      return {\n        success: true,\n        data: {\n          status: 'failed',\n          error: response.error,\n          error_code: response.error_code,\n        },\n      };\n    }\n\n    // Optimistic badge update: deduct credits immediately so the badge reflects\n    // the cost without waiting for the API balance endpoint (which may lag).\n    if (creditCost && creditCost > 0) {\n      await updateCreditsAfterFilter(creditCost);\n    }\n\n    if (response.status === 'completed' && response.transcript) {\n      log('API returned completed/cached transcript, saving locally');\n      await setCachedTranscript(youtubeId, response.transcript);\n      // Also refresh from API for accuracy (corrects the optimistic update if needed)\n      await refreshCredits();\n      return {\n        success: true,\n        data: { status: 'completed', transcript: response.transcript },\n      };\n    }\n\n    if (response.status === 'processing' && response.job_id) {\n      log('API returned processing status, job_id:', response.job_id);\n      return {\n        success: true,\n        data: { status: 'processing', jobId: response.job_id },\n      };\n    }\n\n    return {\n      success: true,\n      data: {\n        status: 'failed',\n        error: response.error || 'Unexpected response',\n        error_code: response.error_code,\n      },\n    };\n  } catch (error) {\n    logError('handleStartFilter error:', error);\n    const errorMessage = error instanceof Error ? error.message : 'Failed to start filter';\n    return { success: false, error: errorMessage };\n  }\n}\n\n// Handle initial filter request (legacy) - returns cached transcript or job_id for polling\nasync function handleGetFilter(\n  payload: { youtubeId: string }\n): Promise<MessageResponse<{ status: string; transcript?: Transcript; jobId?: string; error?: string; error_code?: string }>> {\n  const { youtubeId } = payload;\n  log('handleGetFilter called with youtubeId:', youtubeId);\n\n  // Check local cache first\n  const cached = await getCachedTranscript(youtubeId);\n  if (cached) {\n    log('Found in local cache, returning cached transcript');\n\n    // Record history for cached video (fire and forget - don't await)\n    recordCachedHistory({\n      youtubeId,\n    }).catch(() => {\n      // Silently ignore - already logged in the function\n    });\n\n    return {\n      success: true,\n      data: { status: 'cached', transcript: cached },\n    };\n  }\n\n  log('Not in local cache, making API request...');\n\n  try {\n    // Make initial request to API\n    log('Calling requestFilter API...');\n    const response = await requestFilter(youtubeId);\n    log('API response:', JSON.stringify(response).substring(0, 200));\n\n    if (response.status === 'completed' && response.transcript) {\n      log('API returned completed/cached transcript, saving locally');\n\n      // Log transcript structure\n      const t = response.transcript;\n      log('Transcript structure:', {\n        id: t.id,\n        segmentCount: t.segments?.length,\n        firstSegment: t.segments?.[0] ? {\n          text: t.segments[0].text,\n          start_time: t.segments[0].start_time,\n          end_time: t.segments[0].end_time,\n        } : null,\n      });\n\n      await setCachedTranscript(youtubeId, response.transcript);\n      await refreshCredits();\n      return {\n        success: true,\n        data: { status: 'completed', transcript: response.transcript },\n      };\n    }\n\n    if (response.status === 'processing' && response.job_id) {\n      log('API returned processing status, job_id:', response.job_id);\n      return {\n        success: true,\n        data: { status: 'processing', jobId: response.job_id },\n      };\n    }\n\n    // Handle failed status (e.g., age-restricted videos)\n    if (response.status === 'failed') {\n      log('API returned failed status, error_code:', response.error_code);\n      return {\n        success: true,\n        data: {\n          status: 'failed',\n          error: response.error,\n          error_code: response.error_code,\n        },\n      };\n    }\n\n    logError('Unexpected API response:', response);\n    return { success: false, error: 'Unexpected API response: ' + JSON.stringify(response) };\n  } catch (error) {\n    logError('handleGetFilter error:', error);\n    const errorMessage = error instanceof Error ? error.message : 'Failed to request filter';\n    return { success: false, error: errorMessage };\n  }\n}\n\n// Handle job status polling\nasync function handleCheckJob(\n  payload: { jobId: string }\n): Promise<MessageResponse<JobStatusResponse>> {\n  const { jobId } = payload;\n  log('handleCheckJob called with jobId:', jobId);\n\n  try {\n    log('Calling checkJobStatus API...');\n    const status = await checkJobStatus(jobId);\n    log('Job status response:', JSON.stringify(status).substring(0, 300));\n\n    // If completed, cache the transcript and update credits\n    if (status.status === 'completed' && status.transcript) {\n      const cacheKey = status.video?.youtube_id || status.transcript.id;\n      log('Job completed, caching transcript for:', cacheKey);\n\n      // Log transcript structure\n      const t = status.transcript;\n      log('Job transcript structure:', {\n        id: t.id,\n        segmentCount: t.segments?.length,\n        firstSegment: t.segments?.[0] ? {\n          text: t.segments[0].text,\n          start_time: t.segments[0].start_time,\n          end_time: t.segments[0].end_time,\n        } : null,\n      });\n\n      await setCachedTranscript(cacheKey, status.transcript);\n\n      // Fetch fresh credit balance from server so badge reflects actual remaining credits\n      await refreshCredits();\n    }\n\n    return { success: true, data: status };\n  } catch (error) {\n    logError('handleCheckJob error:', error);\n    const errorMessage = error instanceof Error ? error.message : 'Failed to check job status';\n    return { success: false, error: errorMessage };\n  }\n}\n\n// Fetch fresh credit balance from API and update storage (which updates the badge)\nasync function refreshCredits(): Promise<void> {\n  try {\n    const response = await getCreditBalance();\n    if (response.success && response.credits) {\n      await setCreditInfo(response.credits);\n      log('Credits refreshed from API:', response.credits.available);\n    }\n  } catch (error) {\n    log('Failed to refresh credits:', error);\n  }\n}\n\n// Handle get credits request\nasync function handleGetCredits(): Promise<MessageResponse<CreditInfo>> {\n  log('handleGetCredits called');\n\n  // Check cache first\n  const cachedInfo = await getCreditInfo();\n  if (cachedInfo) {\n    log('Returning cached credit info:', cachedInfo);\n    return { success: true, data: cachedInfo };\n  }\n\n  // Fetch from API\n  try {\n    const response = await getCreditBalance();\n    log('Credit balance response:', JSON.stringify(response));\n\n    if (!response.success) {\n      return { success: false, error: response.error || 'Failed to get credits' };\n    }\n\n    // Cache the credit info\n    await setCreditInfo(response.credits);\n\n    return { success: true, data: response.credits };\n  } catch (error) {\n    logError('handleGetCredits error:', error);\n    const errorMessage = error instanceof Error ? error.message : 'Failed to get credits';\n    return { success: false, error: errorMessage };\n  }\n}\n\nasync function handleGetPreferences(): Promise<MessageResponse<UserPreferences>> {\n  const preferences = await getPreferences();\n  return { success: true, data: preferences };\n}\n\nasync function handleSetPreferences(\n  payload: Partial<UserPreferences>\n): Promise<MessageResponse<UserPreferences>> {\n  const updated = await setPreferences(payload);\n\n  // Broadcast to all YouTube tabs\n  const tabs = await chrome.tabs.query({ url: '*://www.youtube.com/*' });\n  for (const tab of tabs) {\n    if (tab.id) {\n      chrome.tabs.sendMessage(tab.id, {\n        type: 'PREFERENCES_UPDATED',\n        payload: updated,\n      }).catch(() => {});\n    }\n  }\n\n  return { success: true, data: updated };\n}\n\nasync function handleGetAuthStatus(): Promise<\n  MessageResponse<{ authenticated: boolean; token?: string }>\n> {\n  const authenticated = await isAuthenticated();\n  const token = authenticated ? (await getAuthToken()) || undefined : undefined;\n  return { success: true, data: { authenticated, token } };\n}\n\n/**\n * Strict auth check - first checks local token validity, then attempts\n * a token refresh if the token is expired but a refresh token exists.\n * This ensures users with valid sessions aren't asked to re-authenticate\n * just because their access token expired.\n */\nasync function handleCheckAuthStrict(): Promise<\n  MessageResponse<{ authenticated: boolean }>\n> {\n  // Single source of truth: use getAuthToken() which handles expiry, refresh, etc.\n  // This is the same path the popup and alarm use, so auth behaves consistently.\n  const token = await getAuthToken();\n  const authenticated = token !== null;\n  log('handleCheckAuthStrict:', authenticated);\n  return { success: true, data: { authenticated } };\n}\n\nasync function handleClearCache(): Promise<MessageResponse> {\n  await clearCachedTranscripts();\n  return { success: true };\n}\n\n// Handle get user profile request - fetches profile from API and caches it\nasync function handleGetUserProfile(): Promise<MessageResponse<AuthState>> {\n  log('handleGetUserProfile called');\n\n  // First check if authenticated\n  const token = await getAuthToken();\n  if (!token) {\n    log('Not authenticated, returning empty auth state');\n    return {\n      success: true,\n      data: {\n        isAuthenticated: false,\n        user: null,\n        subscription: null,\n        credits: null,\n        token: null,\n      },\n    };\n  }\n\n  try {\n    // Fetch fresh profile from API\n    const response = await getUserProfile();\n    log('User profile response:', JSON.stringify(response).substring(0, 300));\n\n    // Store the profile data\n    if (response.user) {\n      await setUserProfile(response.user);\n    }\n    if (response.subscription) {\n      await setUserSubscription(response.subscription);\n    }\n    if (response.credits) {\n      await setUserCredits(response.credits);\n\n      // Also update the credit info for compatibility with existing credit display\n      const planName = response.subscription?.plans?.name?.toLowerCase() || 'free';\n      const planAllocation = response.subscription?.plans?.monthly_credits || 30;\n      const available = response.credits.available_credits;\n      const usedThisPeriod = response.credits.used_this_period;\n\n      await setCreditInfo({\n        available,\n        used_this_period: usedThisPeriod,\n        plan_allocation: planAllocation,\n        percent_consumed: planAllocation > 0 ? (usedThisPeriod / planAllocation) * 100 : 0,\n        plan: planName as 'free' | 'base' | 'professional' | 'unlimited',\n      });\n    }\n\n    return {\n      success: true,\n      data: {\n        isAuthenticated: true,\n        user: response.user,\n        subscription: response.subscription,\n        credits: response.credits,\n        token,\n      },\n    };\n  } catch (error) {\n    logError('handleGetUserProfile error:', error);\n\n    // If token is invalid, clear auth data\n    if (error instanceof Error && error.message.includes('401')) {\n      log('Token invalid, clearing auth data');\n      await clearAuthData();\n      return {\n        success: true,\n        data: {\n          isAuthenticated: false,\n          user: null,\n          subscription: null,\n          credits: null,\n          token: null,\n        },\n      };\n    }\n\n    // Return cached data on other errors\n    const cachedState = await getFullAuthState();\n    return {\n      success: true,\n      data: {\n        isAuthenticated: cachedState.isAuthenticated,\n        user: cachedState.profile,\n        subscription: cachedState.subscription,\n        credits: cachedState.credits,\n        token: cachedState.token,\n      },\n    };\n  }\n}\n\n// Handle logout - clears all auth data\nasync function handleLogout(): Promise<MessageResponse> {\n  log('handleLogout called');\n\n  await clearAuthData();\n  clearBadge();\n\n  // Broadcast logout to all tabs\n  const tabs = await chrome.tabs.query({});\n  for (const tab of tabs) {\n    if (tab.id) {\n      chrome.tabs.sendMessage(tab.id, {\n        type: 'AUTH_STATE_CHANGED',\n        payload: { isAuthenticated: false },\n      }).catch(() => {});\n    }\n  }\n\n  return { success: true };\n}\n\n// Handle open login - opens the website extension auth page\nconst WEBSITE_BASE_URL = 'https://trysafeplay.com';\n\nasync function handleOpenLogin(): Promise<MessageResponse> {\n  log('handleOpenLogin called');\n\n  // Get the extension ID for the callback\n  const extensionId = chrome.runtime.id;\n\n  // Open the dedicated extension auth page\n  // This page will check if user is already logged in:\n  // - If logged in: sends token to extension immediately\n  // - If not logged in: redirects to login with extension callback\n  const authUrl = `${WEBSITE_BASE_URL}/extension/auth?extensionId=${extensionId}`;\n\n  await chrome.tabs.create({ url: authUrl });\n\n  return { success: true };\n}\n\n// Handle extension icon click\nchrome.action.onClicked.addListener((_tab) => {\n  log('Extension icon clicked');\n});\n\n// Handle installation/update ‚Äî initialize badge within event handler so worker stays alive\nchrome.runtime.onInstalled.addListener(async (details) => {\n  log('Extension installed/updated:', details.reason);\n  await initBadge();\n});\n\n// Handle browser startup ‚Äî also initialize badge\nchrome.runtime.onStartup.addListener(async () => {\n  log('Browser started');\n  await initBadge();\n});\n\n// Handle auth callback from website (deep-link auth flow)\nchrome.runtime.onMessageExternal.addListener(\n  (message, sender, sendResponse) => {\n    const allowedOrigins = [\n      'https://trysafeplay.com',\n      'https://safeplay.app',\n      'http://localhost:3000', // Development\n    ];\n\n    if (allowedOrigins.includes(sender.origin || '')) {\n      if (message.type === 'AUTH_TOKEN') {\n        log('Received AUTH_TOKEN from website');\n        // Detailed logging to diagnose token issues\n        log('Message token details:', {\n          hasToken: !!message.token,\n          tokenLength: message.token?.length,\n          hasRefreshToken: !!message.refreshToken,\n          refreshTokenLength: message.refreshToken?.length,\n          refreshTokenPreview: message.refreshToken ? `${String(message.refreshToken).substring(0, 15)}...` : 'none',\n          hasExpiresAt: !!message.expiresAt,\n          expiresAt: message.expiresAt,\n          expiresAtType: typeof message.expiresAt,\n          hasUserId: !!message.userId,\n          userId: message.userId,\n        });\n\n        import('../utils/storage').then(async ({\n          setAuthToken,\n          setUserId,\n          setSubscriptionTier,\n          setCreditInfo,\n          setUserProfile,\n          setUserSubscription,\n          setUserCredits,\n        }) => {\n          try {\n            // Store auth data including refresh token and expiry\n            // Note: setAuthToken will normalize expiresAt to seconds if it's in milliseconds\n            await setAuthToken(\n              message.token,\n              message.refreshToken,  // Refresh token for auto-refresh\n              message.expiresAt      // Token expiry timestamp (auto-detected: seconds or milliseconds)\n            );\n\n            if (message.userId) {\n              await setUserId(message.userId);\n            }\n\n            if (message.tier) {\n              await setSubscriptionTier(message.tier);\n            }\n\n            if (message.credits) {\n              await setCreditInfo(message.credits);\n            }\n\n            // Store user profile if provided\n            if (message.user) {\n              await setUserProfile(message.user);\n            }\n\n            if (message.subscription) {\n              await setUserSubscription(message.subscription);\n            }\n\n            if (message.userCredits) {\n              await setUserCredits(message.userCredits);\n            }\n\n            // Broadcast auth state change to all tabs\n            const tabs = await chrome.tabs.query({});\n            for (const tab of tabs) {\n              if (tab.id) {\n                chrome.tabs.sendMessage(tab.id, {\n                  type: 'AUTH_STATE_CHANGED',\n                  payload: {\n                    isAuthenticated: true,\n                    user: message.user,\n                  },\n                }).catch(() => {});\n              }\n            }\n\n            log('Auth data stored successfully');\n            sendResponse({ success: true });\n          } catch (error) {\n            logError('Error storing auth data:', error);\n            sendResponse({ success: false, error: 'Failed to store auth data' });\n          }\n        });\n        return true;\n      }\n\n      // Handle credit update messages from website\n      if (message.type === 'CREDIT_UPDATE') {\n        import('../utils/storage').then(({ setCreditInfo }) => {\n          setCreditInfo(message.credits).then(() => {\n            // Broadcast credit update\n            chrome.tabs.query({}).then(tabs => {\n              for (const tab of tabs) {\n                if (tab.id) {\n                  chrome.tabs.sendMessage(tab.id, {\n                    type: 'CREDIT_UPDATE',\n                    payload: message.credits,\n                  }).catch(() => {});\n                }\n              }\n            });\n            sendResponse({ success: true });\n          });\n        });\n        return true;\n      }\n\n      // Handle logout from website\n      if (message.type === 'LOGOUT') {\n        log('Received LOGOUT from website');\n        handleLogout().then(() => {\n          sendResponse({ success: true });\n        });\n        return true;\n      }\n    }\n    return false;\n  }\n);\n\nlog('SafePlay background service worker initialized');\n"],"names":["STORAGE_KEYS","async","getPreferences","chrome","storage","local","get","setPreferences","preferences","updated","set","refreshAuthToken","url","runtime","id","console","log","response","fetch","method","credentials","status","ok","errorText","text","statusText","body","substring","data","json","authenticated","hasToken","token","tokenLength","length","hasRefreshToken","refreshToken","refreshTokenLength","expiresAt","expiresAtDate","Date","toISOString","remove","expiresAtSeconds","Math","floor","error","getAuthToken","result","now","expiresAtMs","timeUntilExpiry","isExpiringSoon","expiredAgo","abs","newToken","expiresIn","setAuthToken","refreshTokenPreview","expiresAtType","setUserId","userId","setSubscriptionTier","tier","getCreditInfo","cacheTime","creditInfo","setCreditInfo","updateCreditsAfterFilter","creditCost","currentInfo","updatedInfo","available","max","used_this_period","percent_consumed","min","plan_allocation","getCachedTranscript","youtubeId","cache","entry","transcript","timestamp","segments","setCachedTranscript","entries","Object","sort","a","b","toKeep","slice","fromEntries","Error","message","includes","warn","clearCachedTranscripts","freshCache","retryError","isAuthenticated","setUserProfile","profile","setUserSubscription","subscription","setUserCredits","credits","clearAuthData","getFullAuthState","getUserProfile","getUserSubscription","getUserCredits","DEFAULT_PREFERENCES","enabled","filterMode","severityLevels","mild","moderate","severe","religious","customBlacklist","customWhitelist","paddingMs","paddingBeforeMs","paddingAfterMs","mergeThresholdMs","autoEnableForFilteredVideos","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","d","definition","key","o","defineProperty","enumerable","obj","prop","prototype","hasOwnProperty","call","logApi","args","ApiError","constructor","statusCode","errorCode","super","this","name","request","endpoint","options","requiresAuth","_isRetry","JSON","stringify","headers","errorData","parse","rawError","tabs","query","then","tab","sendMessage","type","payload","catch","error_code","networkError","originalError","String","getCreditBalance","startFilter","filterType","customWords","youtube_id","filter_type","custom_words","recordCachedHistory","params","title","channel_name","channelName","duration_seconds","durationSeconds","logError","updateBadge","action","setBadgeText","toString","color","setBadgeBackgroundColor","clearBadge","initBadge","success","onChanged","addListener","changes","areaName","safeplay_credit_info","newValue","CREDIT_REFRESH_ALARM","refreshCredits","handleLogout","alarms","create","periodInMinutes","onAlarm","alarm","onMessage","sender","sendResponse","cached","job_id","requestFilter","t","segmentCount","firstSegment","start_time","end_time","jobId","handleGetFilter","userCredits","video","duration","hasSufficientCredits","isCached","preview","getPreview","user_credits","existingInfo","isUnknownCost","credit_cost","has_transcript","thumbnail","thumbnail_url","channel","creditCostNote","credit_cost_note","creditCostUnknown","has_sufficient_credits","handleGetPreview","handleStartFilter","checkJobStatus","cacheKey","handleCheckJob","cachedInfo","handleGetCredits","handleGetPreferences","handleSetPreferences","handleGetAuthStatus","handleCheckAuthStrict","user","planName","plans","toLowerCase","planAllocation","monthly_credits","available_credits","usedThisPeriod","plan","cachedState","handleGetUserProfile","extensionId","authUrl","WEBSITE_BASE_URL","handleOpenLogin","handleClearCache","errorMessage","handleMessage","onClicked","_tab","onInstalled","details","reason","onStartup","onMessageExternal","origin","hasExpiresAt","hasUserId"],"ignoreList":[],"sourceRoot":""}