{"version":3,"file":"background.js","mappings":"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","sources":["webpack://safeplay-chrome-extension/./src/utils/storage.ts","webpack://safeplay-chrome-extension/./src/types/index.ts","webpack://safeplay-chrome-extension/webpack/bootstrap","webpack://safeplay-chrome-extension/webpack/runtime/define property getters","webpack://safeplay-chrome-extension/webpack/runtime/hasOwnProperty shorthand","webpack://safeplay-chrome-extension/./src/api/client.ts","webpack://safeplay-chrome-extension/./src/background/index.ts"],"sourcesContent":["import {\n  StorageData,\n  UserPreferences,\n  DEFAULT_PREFERENCES,\n  Transcript,\n} from '../types';\n\nconst STORAGE_KEYS = {\n  PREFERENCES: 'safeplay_preferences',\n  AUTH_TOKEN: 'safeplay_auth_token',\n  USER_ID: 'safeplay_user_id',\n  SUBSCRIPTION_TIER: 'safeplay_subscription_tier',\n  CACHED_TRANSCRIPTS: 'safeplay_cached_transcripts',\n  FILTERED_VIDEOS: 'safeplay_filtered_videos',\n} as const;\n\n// Cache limits\nconst MAX_CACHED_TRANSCRIPTS = 15; // Keep only 15 most recent transcripts\n\nexport async function getPreferences(): Promise<UserPreferences> {\n  const result = await chrome.storage.local.get(STORAGE_KEYS.PREFERENCES);\n  return result[STORAGE_KEYS.PREFERENCES] || DEFAULT_PREFERENCES;\n}\n\nexport async function setPreferences(\n  preferences: Partial<UserPreferences>\n): Promise<UserPreferences> {\n  const current = await getPreferences();\n  const updated = { ...current, ...preferences };\n  await chrome.storage.local.set({ [STORAGE_KEYS.PREFERENCES]: updated });\n  return updated;\n}\n\nexport async function getAuthToken(): Promise<string | null> {\n  const result = await chrome.storage.local.get(STORAGE_KEYS.AUTH_TOKEN);\n  return result[STORAGE_KEYS.AUTH_TOKEN] || null;\n}\n\nexport async function setAuthToken(token: string): Promise<void> {\n  await chrome.storage.local.set({ [STORAGE_KEYS.AUTH_TOKEN]: token });\n}\n\nexport async function clearAuthToken(): Promise<void> {\n  await chrome.storage.local.remove(STORAGE_KEYS.AUTH_TOKEN);\n}\n\nexport async function getUserId(): Promise<string | null> {\n  const result = await chrome.storage.local.get(STORAGE_KEYS.USER_ID);\n  return result[STORAGE_KEYS.USER_ID] || null;\n}\n\nexport async function setUserId(userId: string): Promise<void> {\n  await chrome.storage.local.set({ [STORAGE_KEYS.USER_ID]: userId });\n}\n\nexport async function getSubscriptionTier(): Promise<\n  StorageData['subscriptionTier'] | null\n> {\n  const result = await chrome.storage.local.get(STORAGE_KEYS.SUBSCRIPTION_TIER);\n  return result[STORAGE_KEYS.SUBSCRIPTION_TIER] || null;\n}\n\nexport async function setSubscriptionTier(\n  tier: StorageData['subscriptionTier']\n): Promise<void> {\n  await chrome.storage.local.set({ [STORAGE_KEYS.SUBSCRIPTION_TIER]: tier });\n}\n\ninterface CachedTranscriptEntry {\n  transcript: Transcript;\n  timestamp: number;\n}\n\ninterface TranscriptCache {\n  [youtubeId: string]: CachedTranscriptEntry;\n}\n\nexport async function getCachedTranscript(\n  youtubeId: string\n): Promise<Transcript | null> {\n  try {\n    const result = await chrome.storage.local.get(STORAGE_KEYS.CACHED_TRANSCRIPTS);\n    const cache = result[STORAGE_KEYS.CACHED_TRANSCRIPTS] || {};\n    const entry = cache[youtubeId];\n\n    if (!entry) return null;\n\n    // Handle both old format (direct transcript) and new format (with timestamp)\n    if (entry.transcript) {\n      // New format with timestamp\n      entry.timestamp = Date.now();\n      await chrome.storage.local.set({ [STORAGE_KEYS.CACHED_TRANSCRIPTS]: cache });\n      return entry.transcript;\n    } else if (entry.segments) {\n      // Old format - transcript stored directly, migrate to new format\n      const transcript = entry as Transcript;\n      cache[youtubeId] = { transcript, timestamp: Date.now() };\n      await chrome.storage.local.set({ [STORAGE_KEYS.CACHED_TRANSCRIPTS]: cache });\n      return transcript;\n    }\n\n    return null;\n  } catch (error) {\n    console.error('[SafePlay Storage] Error getting cached transcript:', error);\n    return null;\n  }\n}\n\nexport async function setCachedTranscript(\n  youtubeId: string,\n  transcript: Transcript\n): Promise<void> {\n  try {\n    const result = await chrome.storage.local.get(STORAGE_KEYS.CACHED_TRANSCRIPTS);\n    let cache: TranscriptCache = result[STORAGE_KEYS.CACHED_TRANSCRIPTS] || {};\n\n    // Add new entry with timestamp\n    cache[youtubeId] = {\n      transcript,\n      timestamp: Date.now(),\n    };\n\n    // Enforce cache limit - remove oldest entries if over limit\n    const entries = Object.entries(cache);\n    if (entries.length > MAX_CACHED_TRANSCRIPTS) {\n      // Sort by timestamp (oldest first) and keep only the newest\n      entries.sort((a, b) => a[1].timestamp - b[1].timestamp);\n      const toKeep = entries.slice(-MAX_CACHED_TRANSCRIPTS);\n      cache = Object.fromEntries(toKeep);\n      console.log(`[SafePlay Storage] Trimmed transcript cache to ${MAX_CACHED_TRANSCRIPTS} entries`);\n    }\n\n    await chrome.storage.local.set({ [STORAGE_KEYS.CACHED_TRANSCRIPTS]: cache });\n  } catch (error: unknown) {\n    // Handle quota exceeded error\n    if (error instanceof Error && error.message.includes('quota')) {\n      console.warn('[SafePlay Storage] Quota exceeded, clearing transcript cache...');\n      await clearCachedTranscripts();\n      // Retry with fresh cache\n      try {\n        const freshCache: TranscriptCache = {\n          [youtubeId]: { transcript, timestamp: Date.now() }\n        };\n        await chrome.storage.local.set({ [STORAGE_KEYS.CACHED_TRANSCRIPTS]: freshCache });\n        console.log('[SafePlay Storage] Cache cleared and new transcript saved');\n      } catch (retryError) {\n        console.error('[SafePlay Storage] Failed to save transcript after clearing cache:', retryError);\n      }\n    } else {\n      console.error('[SafePlay Storage] Error caching transcript:', error);\n    }\n  }\n}\n\nexport async function clearCachedTranscripts(): Promise<void> {\n  await chrome.storage.local.remove(STORAGE_KEYS.CACHED_TRANSCRIPTS);\n}\n\nexport async function clearAllData(): Promise<void> {\n  await chrome.storage.local.clear();\n}\n\nexport async function isAuthenticated(): Promise<boolean> {\n  const token = await getAuthToken();\n  return token !== null;\n}\n\n// Filtered Videos Storage - tracks which videos have been filtered\nexport async function getFilteredVideos(): Promise<string[]> {\n  try {\n    const result = await chrome.storage.local.get(STORAGE_KEYS.FILTERED_VIDEOS);\n    return result[STORAGE_KEYS.FILTERED_VIDEOS] || [];\n  } catch (error) {\n    console.error('[SafePlay Storage] Error getting filtered videos:', error);\n    return [];\n  }\n}\n\nexport async function addFilteredVideo(youtubeId: string): Promise<void> {\n  try {\n    const videos = await getFilteredVideos();\n    if (!videos.includes(youtubeId)) {\n      videos.push(youtubeId);\n      // Keep only last 500 videos to prevent storage bloat\n      const trimmedVideos = videos.slice(-500);\n      await chrome.storage.local.set({ [STORAGE_KEYS.FILTERED_VIDEOS]: trimmedVideos });\n    }\n  } catch (error) {\n    console.error('[SafePlay Storage] Error adding filtered video:', error);\n  }\n}\n\nexport async function isVideoFiltered(youtubeId: string): Promise<boolean> {\n  try {\n    const videos = await getFilteredVideos();\n    return videos.includes(youtubeId);\n  } catch (error) {\n    console.error('[SafePlay Storage] Error checking if video filtered:', error);\n    return false;\n  }\n}\n\nexport async function removeFilteredVideo(youtubeId: string): Promise<void> {\n  const videos = await getFilteredVideos();\n  const filtered = videos.filter(id => id !== youtubeId);\n  await chrome.storage.local.set({ [STORAGE_KEYS.FILTERED_VIDEOS]: filtered });\n}\n\nexport async function clearFilteredVideos(): Promise<void> {\n  await chrome.storage.local.remove(STORAGE_KEYS.FILTERED_VIDEOS);\n}\n","// API Response Types\n\nexport interface CharacterTiming {\n  char: string;\n  start: number;\n  end: number;\n}\n\nexport interface TranscriptSegment {\n  text: string;\n  start_time: number;\n  end_time: number;\n  characters: CharacterTiming[];\n}\n\nexport interface Transcript {\n  id: string;\n  youtube_id?: string; // May be set from context\n  full_text?: string;\n  segments: TranscriptSegment[];\n  duration?: number;\n  language?: string;\n  created_at?: string;\n}\n\nexport interface FilterResponse {\n  status: 'completed' | 'processing' | 'failed';\n  cached?: boolean;\n  transcript?: Transcript;\n  job_id?: string;\n  message?: string;\n  error?: string;\n  error_code?: string;  // 'AGE_RESTRICTED', 'VIDEO_UNAVAILABLE', etc.\n}\n\nexport interface JobStatusResponse {\n  status: 'pending' | 'downloading' | 'transcribing' | 'completed' | 'failed';\n  progress: number;\n  transcript?: Transcript;\n  error?: string;\n  error_code?: string;  // 'AGE_RESTRICTED', 'VIDEO_UNAVAILABLE', etc.\n  video?: {\n    youtube_id: string;\n    title?: string;\n  };\n}\n\n// Button state for UX\nexport type ButtonState =\n  | 'idle'\n  | 'connecting'\n  | 'downloading'\n  | 'transcribing'\n  | 'processing'\n  | 'filtering'\n  | 'paused'  // Filter is paused (user can re-enable)\n  | 'error'\n  | 'age-restricted';  // Video is age-restricted and cannot be filtered\n\nexport interface ButtonStateInfo {\n  state: ButtonState;\n  text: string;\n  progress?: number;\n  intervalCount?: number;\n  error?: string;\n  videoId?: string; // Track which video this state belongs to (for Shorts)\n}\n\n// Profanity Types\n\nexport type SeverityLevel = 'mild' | 'moderate' | 'severe' | 'religious';\n\nexport interface ProfanityWord {\n  word: string;\n  severity: SeverityLevel;\n}\n\nexport interface MuteInterval {\n  start: number;\n  end: number;\n  word: string;\n  severity: SeverityLevel;\n}\n\nexport interface ProfanityMatch {\n  segmentIndex: number;\n  word: string;\n  severity: SeverityLevel;\n  startTime: number;\n  endTime: number;\n  isPartialMatch: boolean;\n  matchedPortion?: string;\n}\n\n// User Preferences\n\nexport type FilterMode = 'mute' | 'bleep';\n\nexport interface UserPreferences {\n  enabled: boolean;\n  filterMode: FilterMode;\n  severityLevels: {\n    mild: boolean;\n    moderate: boolean;\n    severe: boolean;\n    religious: boolean;\n  };\n  customBlacklist: string[];\n  customWhitelist: string[];\n  paddingMs: number; // Legacy/fallback symmetric padding\n  paddingBeforeMs?: number; // Padding before word starts (catches attack)\n  paddingAfterMs?: number; // Padding after word ends (catches release)\n  mergeThresholdMs: number;\n  autoEnableForFilteredVideos: boolean; // Auto-enable filter for previously filtered videos\n}\n\nexport const DEFAULT_PREFERENCES: UserPreferences = {\n  enabled: true,\n  filterMode: 'mute',\n  severityLevels: {\n    mild: false,\n    moderate: true,\n    severe: true,\n    religious: false, // Off by default - user opt-in\n  },\n  customBlacklist: [],\n  customWhitelist: [],\n  paddingMs: 50, // Legacy/fallback symmetric padding\n  paddingBeforeMs: 100, // Padding before word - smooth fade adds ~130ms effective lead time\n  paddingAfterMs: 30, // Padding after word ends\n  mergeThresholdMs: 100,\n  autoEnableForFilteredVideos: true, // Auto-enable filter for previously filtered videos\n};\n\n// Storage Types\n\nexport interface StorageData {\n  preferences: UserPreferences;\n  authToken?: string;\n  userId?: string;\n  subscriptionTier?: 'free' | 'basic' | 'professional' | 'unlimited';\n  cachedTranscripts: Record<string, Transcript>;\n}\n\n// Message Types (between content script and background)\n\nexport type MessageType =\n  | 'GET_FILTER'\n  | 'CHECK_JOB'\n  | 'GET_PREFERENCES'\n  | 'SET_PREFERENCES'\n  | 'GET_AUTH_STATUS'\n  | 'CLEAR_CACHE';\n\nexport interface Message<T = unknown> {\n  type: MessageType;\n  payload?: T;\n}\n\nexport interface MessageResponse<T = unknown> {\n  success: boolean;\n  data?: T;\n  error?: string;\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import { FilterResponse, JobStatusResponse, Transcript } from '../types';\nimport { getAuthToken } from '../utils/storage';\n\n// API URL for the orchestration service\nconst API_BASE_URL = 'https://safeplay-orchestrator-production.up.railway.app';\n\n// Verbose logging\nfunction logApi(...args: unknown[]): void {\n  console.log('[SafePlay API]', ...args);\n}\n\ninterface RequestOptions {\n  method?: 'GET' | 'POST' | 'PUT' | 'DELETE';\n  body?: unknown;\n  requiresAuth?: boolean;\n}\n\nclass ApiError extends Error {\n  constructor(\n    message: string,\n    public statusCode: number,\n    public response?: unknown,\n    public errorCode?: string  // 'AGE_RESTRICTED', 'VIDEO_UNAVAILABLE', etc.\n  ) {\n    super(message);\n    this.name = 'ApiError';\n  }\n}\n\nasync function request<T>(\n  endpoint: string,\n  options: RequestOptions = {}\n): Promise<T> {\n  const { method = 'GET', body, requiresAuth = true } = options;\n  const url = `${API_BASE_URL}${endpoint}`;\n\n  logApi(`>>> ${method} ${url}`, body ? JSON.stringify(body) : '');\n\n  const headers: Record<string, string> = {\n    'Content-Type': 'application/json',\n  };\n\n  if (requiresAuth) {\n    const token = await getAuthToken();\n    logApi('Auth token:', token ? `${token.substring(0, 20)}...` : 'none');\n    if (token) {\n      headers['Authorization'] = `Bearer ${token}`;\n    }\n  }\n\n  try {\n    const response = await fetch(url, {\n      method,\n      headers,\n      body: body ? JSON.stringify(body) : undefined,\n    });\n\n    logApi(`<<< ${response.status} ${response.statusText}`);\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      logApi('Error response body:', errorText);\n\n      let errorData: Record<string, unknown> = {};\n      try {\n        errorData = JSON.parse(errorText);\n      } catch {\n        errorData = { rawError: errorText };\n      }\n\n      throw new ApiError(\n        errorData.message as string || errorData.error as string || `Request failed with status ${response.status}`,\n        response.status,\n        errorData\n      );\n    }\n\n    const data = await response.json();\n    logApi('Response data:', JSON.stringify(data).substring(0, 500));\n    return data;\n  } catch (error) {\n    if (error instanceof ApiError) {\n      throw error;\n    }\n\n    // Network or other error\n    const message = error instanceof Error ? error.message : 'Network error';\n    logApi('Request failed:', message);\n    throw new ApiError(message, 0, { networkError: true, originalError: String(error) });\n  }\n}\n\nexport async function requestFilter(youtubeId: string): Promise<FilterResponse> {\n  logApi('=== requestFilter ===', youtubeId);\n  return request<FilterResponse>('/api/filter', {\n    method: 'POST',\n    body: { youtube_id: youtubeId },\n    requiresAuth: false, // Allow without auth for now\n  });\n}\n\nexport async function checkJobStatus(jobId: string): Promise<JobStatusResponse> {\n  logApi('=== checkJobStatus ===', jobId);\n  return request<JobStatusResponse>(`/api/jobs/${jobId}`, {\n    requiresAuth: false, // Allow without auth for now\n  });\n}\n\nexport async function getTranscript(youtubeId: string): Promise<Transcript> {\n  logApi('=== getTranscript ===', youtubeId);\n  return request<Transcript>(`/api/transcript/${youtubeId}`, {\n    requiresAuth: false,\n  });\n}\n\nexport async function pollForTranscript(\n  jobId: string,\n  onProgress?: (progress: number) => void,\n  maxAttempts = 120,\n  intervalMs = 2000\n): Promise<Transcript> {\n  logApi('=== pollForTranscript ===', jobId);\n  let attempts = 0;\n\n  while (attempts < maxAttempts) {\n    const status = await checkJobStatus(jobId);\n\n    if (onProgress) {\n      onProgress(status.progress);\n    }\n\n    if (status.status === 'completed' && status.transcript) {\n      logApi('Poll completed, got transcript');\n      return status.transcript;\n    }\n\n    if (status.status === 'failed') {\n      logApi('Poll failed:', status.error, 'error_code:', status.error_code);\n      throw new ApiError(\n        status.error || 'Transcription failed',\n        500,\n        status,\n        status.error_code  // Pass through the error code\n      );\n    }\n\n    logApi(`Poll attempt ${attempts + 1}/${maxAttempts}, status: ${status.status}, progress: ${status.progress}`);\n    await new Promise((resolve) => setTimeout(resolve, intervalMs));\n    attempts++;\n  }\n\n  throw new ApiError('Transcription timed out', 408);\n}\n\nexport async function getOrRequestTranscript(\n  youtubeId: string,\n  onProgress?: (progress: number) => void\n): Promise<Transcript> {\n  logApi('=== getOrRequestTranscript ===', youtubeId);\n  const response = await requestFilter(youtubeId);\n\n  if (response.status === 'completed' && response.transcript) {\n    logApi('Got completed/cached transcript');\n    return response.transcript;\n  }\n\n  if (response.status === 'processing' && response.job_id) {\n    logApi('Processing started, job_id:', response.job_id);\n    return pollForTranscript(response.job_id, onProgress);\n  }\n\n  throw new ApiError('Unexpected response from filter API', 500, response);\n}\n\nexport { ApiError };\n","// SafePlay Background Service Worker\nimport {\n  Message,\n  MessageResponse,\n  Transcript,\n  UserPreferences,\n  JobStatusResponse,\n} from '../types';\nimport {\n  getPreferences,\n  setPreferences,\n  getCachedTranscript,\n  setCachedTranscript,\n  getAuthToken,\n  clearCachedTranscripts,\n  isAuthenticated,\n} from '../utils/storage';\nimport { requestFilter, checkJobStatus } from '../api/client';\n\nfunction log(...args: unknown[]): void {\n  // Always log for debugging\n  console.log('[SafePlay BG]', ...args);\n}\n\nfunction logError(...args: unknown[]): void {\n  console.error('[SafePlay BG ERROR]', ...args);\n}\n\n// Message handler\nchrome.runtime.onMessage.addListener(\n  (message: Message, sender, sendResponse: (response: MessageResponse) => void) => {\n    handleMessage(message, sender).then(sendResponse);\n    return true; // Keep channel open for async\n  }\n);\n\nasync function handleMessage(\n  message: Message,\n  _sender: chrome.runtime.MessageSender\n): Promise<MessageResponse> {\n  log('Received message:', message.type);\n\n  try {\n    switch (message.type) {\n      case 'GET_FILTER':\n        return await handleGetFilter(message.payload as { youtubeId: string });\n\n      case 'CHECK_JOB':\n        return await handleCheckJob(message.payload as { jobId: string });\n\n      case 'GET_PREFERENCES':\n        return await handleGetPreferences();\n\n      case 'SET_PREFERENCES':\n        return await handleSetPreferences(\n          message.payload as Partial<UserPreferences>\n        );\n\n      case 'GET_AUTH_STATUS':\n        return await handleGetAuthStatus();\n\n      case 'CLEAR_CACHE':\n        return await handleClearCache();\n\n      default:\n        return { success: false, error: 'Unknown message type' };\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n    log('Message handler error:', errorMessage);\n    return { success: false, error: errorMessage };\n  }\n}\n\n// Handle initial filter request - returns cached transcript or job_id for polling\nasync function handleGetFilter(\n  payload: { youtubeId: string }\n): Promise<MessageResponse<{ status: string; transcript?: Transcript; jobId?: string; error?: string; error_code?: string }>> {\n  const { youtubeId } = payload;\n  log('handleGetFilter called with youtubeId:', youtubeId);\n\n  // Check local cache first\n  const cached = await getCachedTranscript(youtubeId);\n  if (cached) {\n    log('Found in local cache, returning cached transcript');\n    return {\n      success: true,\n      data: { status: 'cached', transcript: cached },\n    };\n  }\n\n  log('Not in local cache, making API request...');\n\n  try {\n    // Make initial request to API\n    log('Calling requestFilter API...');\n    const response = await requestFilter(youtubeId);\n    log('API response:', JSON.stringify(response).substring(0, 200));\n\n    if (response.status === 'completed' && response.transcript) {\n      log('API returned completed/cached transcript, saving locally');\n\n      // Log transcript structure to verify character-level data\n      const t = response.transcript;\n      log('Transcript structure:', {\n        id: t.id,\n        segmentCount: t.segments?.length,\n        firstSegment: t.segments?.[0] ? {\n          text: t.segments[0].text,\n          start_time: t.segments[0].start_time,\n          end_time: t.segments[0].end_time,\n          hasCharacters: !!t.segments[0].characters,\n          characterCount: t.segments[0].characters?.length,\n          firstChar: t.segments[0].characters?.[0],\n          lastChar: t.segments[0].characters?.[t.segments[0].characters?.length - 1],\n        } : null,\n      });\n\n      // Log a few segments to see character data\n      if (t.segments && t.segments.length > 0) {\n        for (let i = 0; i < Math.min(3, t.segments.length); i++) {\n          const seg = t.segments[i];\n          log(`Segment ${i}: \"${seg.text}\" (${seg.start_time}s - ${seg.end_time}s)`, {\n            characters: seg.characters?.slice(0, 5), // First 5 chars\n            totalChars: seg.characters?.length,\n          });\n        }\n      }\n\n      await setCachedTranscript(youtubeId, response.transcript);\n      return {\n        success: true,\n        data: { status: 'completed', transcript: response.transcript },\n      };\n    }\n\n    if (response.status === 'processing' && response.job_id) {\n      log('API returned processing status, job_id:', response.job_id);\n      return {\n        success: true,\n        data: { status: 'processing', jobId: response.job_id },\n      };\n    }\n\n    // Handle failed status (e.g., age-restricted videos)\n    if (response.status === 'failed') {\n      log('API returned failed status, error_code:', response.error_code);\n      return {\n        success: true,\n        data: {\n          status: 'failed',\n          error: response.error,\n          error_code: response.error_code,\n        },\n      };\n    }\n\n    logError('Unexpected API response:', response);\n    return { success: false, error: 'Unexpected API response: ' + JSON.stringify(response) };\n  } catch (error) {\n    logError('handleGetFilter error:', error);\n    const errorMessage = error instanceof Error ? error.message : 'Failed to request filter';\n    return { success: false, error: errorMessage };\n  }\n}\n\n// Handle job status polling\nasync function handleCheckJob(\n  payload: { jobId: string }\n): Promise<MessageResponse<JobStatusResponse>> {\n  const { jobId } = payload;\n  log('handleCheckJob called with jobId:', jobId);\n\n  try {\n    log('Calling checkJobStatus API...');\n    const status = await checkJobStatus(jobId);\n    log('Job status response:', JSON.stringify(status).substring(0, 300));\n\n    // If completed, cache the transcript\n    if (status.status === 'completed' && status.transcript) {\n      const cacheKey = status.video?.youtube_id || status.transcript.id;\n      log('Job completed, caching transcript for:', cacheKey);\n\n      // Log transcript structure to verify character-level data\n      const t = status.transcript;\n      log('Job transcript structure:', {\n        id: t.id,\n        segmentCount: t.segments?.length,\n        firstSegment: t.segments?.[0] ? {\n          text: t.segments[0].text,\n          start_time: t.segments[0].start_time,\n          end_time: t.segments[0].end_time,\n          hasCharacters: !!t.segments[0].characters,\n          characterCount: t.segments[0].characters?.length,\n          sampleChars: t.segments[0].characters?.slice(0, 3),\n        } : null,\n      });\n\n      await setCachedTranscript(cacheKey, status.transcript);\n    }\n\n    return { success: true, data: status };\n  } catch (error) {\n    logError('handleCheckJob error:', error);\n    const errorMessage = error instanceof Error ? error.message : 'Failed to check job status';\n    return { success: false, error: errorMessage };\n  }\n}\n\nasync function handleGetPreferences(): Promise<MessageResponse<UserPreferences>> {\n  const preferences = await getPreferences();\n  return { success: true, data: preferences };\n}\n\nasync function handleSetPreferences(\n  payload: Partial<UserPreferences>\n): Promise<MessageResponse<UserPreferences>> {\n  const updated = await setPreferences(payload);\n\n  // Broadcast to all YouTube tabs\n  const tabs = await chrome.tabs.query({ url: '*://www.youtube.com/*' });\n  for (const tab of tabs) {\n    if (tab.id) {\n      chrome.tabs.sendMessage(tab.id, {\n        type: 'PREFERENCES_UPDATED',\n        payload: updated,\n      }).catch(() => {});\n    }\n  }\n\n  return { success: true, data: updated };\n}\n\nasync function handleGetAuthStatus(): Promise<\n  MessageResponse<{ authenticated: boolean; token?: string }>\n> {\n  const authenticated = await isAuthenticated();\n  const token = authenticated ? (await getAuthToken()) || undefined : undefined;\n  return { success: true, data: { authenticated, token } };\n}\n\nasync function handleClearCache(): Promise<MessageResponse> {\n  await clearCachedTranscripts();\n  return { success: true };\n}\n\n// Handle extension icon click\nchrome.action.onClicked.addListener((_tab) => {\n  log('Extension icon clicked');\n});\n\n// Handle installation/update\nchrome.runtime.onInstalled.addListener((details) => {\n  log('Extension installed/updated:', details.reason);\n\n  if (details.reason === 'install') {\n    // First install - could open onboarding page\n    // chrome.tabs.create({ url: 'https://safeplay.app/welcome' });\n  }\n});\n\n// Handle auth callback from website (deep-link auth flow)\nchrome.runtime.onMessageExternal.addListener(\n  (message, sender, sendResponse) => {\n    if (sender.origin === 'https://safeplay.app') {\n      if (message.type === 'AUTH_TOKEN') {\n        import('../utils/storage').then(({ setAuthToken, setUserId, setSubscriptionTier }) => {\n          Promise.all([\n            setAuthToken(message.token),\n            setUserId(message.userId),\n            setSubscriptionTier(message.tier),\n          ]).then(() => {\n            sendResponse({ success: true });\n          });\n        });\n        return true;\n      }\n    }\n    return false;\n  }\n);\n\nlog('SafePlay background service worker initialized');\n"],"names":["STORAGE_KEYS","async","getPreferences","chrome","storage","local","get","setPreferences","preferences","updated","set","getAuthToken","setAuthToken","token","setUserId","userId","setSubscriptionTier","tier","getCachedTranscript","youtubeId","cache","entry","transcript","timestamp","Date","now","segments","error","console","setCachedTranscript","entries","Object","length","sort","a","b","toKeep","slice","fromEntries","log","Error","message","includes","warn","clearCachedTranscripts","freshCache","retryError","remove","isAuthenticated","DEFAULT_PREFERENCES","enabled","filterMode","severityLevels","mild","moderate","severe","religious","customBlacklist","customWhitelist","paddingMs","paddingBeforeMs","paddingAfterMs","mergeThresholdMs","autoEnableForFilteredVideos","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","d","definition","key","o","defineProperty","enumerable","obj","prop","prototype","hasOwnProperty","call","logApi","args","ApiError","constructor","statusCode","response","errorCode","super","this","name","request","endpoint","options","method","body","requiresAuth","url","JSON","stringify","headers","substring","fetch","status","statusText","ok","errorText","text","errorData","parse","rawError","data","json","networkError","originalError","String","logError","runtime","onMessage","addListener","sender","sendResponse","type","payload","cached","success","youtube_id","requestFilter","t","id","segmentCount","firstSegment","start_time","end_time","hasCharacters","characters","characterCount","firstChar","lastChar","i","Math","min","seg","totalChars","job_id","jobId","error_code","handleGetFilter","checkJobStatus","cacheKey","video","sampleChars","handleCheckJob","handleGetPreferences","tabs","query","tab","sendMessage","catch","handleSetPreferences","authenticated","handleGetAuthStatus","handleClearCache","errorMessage","handleMessage","then","action","onClicked","_tab","onInstalled","details","reason","onMessageExternal","origin","Promise","all"],"ignoreList":[],"sourceRoot":""}