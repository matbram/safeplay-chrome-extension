{"version":3,"file":"background.js","mappings":"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","sources":["webpack://safeplay-chrome-extension/./src/types/index.ts","webpack://safeplay-chrome-extension/./src/utils/storage.ts","webpack://safeplay-chrome-extension/webpack/bootstrap","webpack://safeplay-chrome-extension/webpack/runtime/define property getters","webpack://safeplay-chrome-extension/webpack/runtime/hasOwnProperty shorthand","webpack://safeplay-chrome-extension/./src/api/client.ts","webpack://safeplay-chrome-extension/./src/background/index.ts"],"sourcesContent":["// API Response Types\n\nexport interface CharacterTiming {\n  character: string;\n  start_time: number;\n  end_time: number;\n}\n\nexport interface TranscriptSegment {\n  text: string;\n  start_time: number;\n  end_time: number;\n  characters: CharacterTiming[];\n}\n\nexport interface Transcript {\n  youtube_id: string;\n  segments: TranscriptSegment[];\n  duration: number;\n  language: string;\n  created_at: string;\n}\n\nexport interface FilterResponse {\n  status: 'cached' | 'processing';\n  transcript?: Transcript;\n  job_id?: string;\n  message?: string;\n}\n\nexport interface JobStatusResponse {\n  status: 'pending' | 'processing' | 'completed' | 'failed';\n  progress: number;\n  transcript?: Transcript;\n  error?: string;\n}\n\n// Profanity Types\n\nexport type SeverityLevel = 'mild' | 'moderate' | 'severe';\n\nexport interface ProfanityWord {\n  word: string;\n  severity: SeverityLevel;\n}\n\nexport interface MuteInterval {\n  start: number;\n  end: number;\n  word: string;\n  severity: SeverityLevel;\n}\n\nexport interface ProfanityMatch {\n  segmentIndex: number;\n  word: string;\n  severity: SeverityLevel;\n  startTime: number;\n  endTime: number;\n  isPartialMatch: boolean;\n  matchedPortion?: string;\n}\n\n// User Preferences\n\nexport type FilterMode = 'mute' | 'bleep';\n\nexport interface UserPreferences {\n  enabled: boolean;\n  filterMode: FilterMode;\n  severityLevels: {\n    mild: boolean;\n    moderate: boolean;\n    severe: boolean;\n  };\n  customBlacklist: string[];\n  customWhitelist: string[];\n  paddingMs: number;\n  mergeThresholdMs: number;\n}\n\nexport const DEFAULT_PREFERENCES: UserPreferences = {\n  enabled: true,\n  filterMode: 'mute',\n  severityLevels: {\n    mild: false,\n    moderate: true,\n    severe: true,\n  },\n  customBlacklist: [],\n  customWhitelist: [],\n  paddingMs: 50,\n  mergeThresholdMs: 100,\n};\n\n// Storage Types\n\nexport interface StorageData {\n  preferences: UserPreferences;\n  authToken?: string;\n  userId?: string;\n  subscriptionTier?: 'free' | 'basic' | 'professional' | 'unlimited';\n  cachedTranscripts: Record<string, Transcript>;\n}\n\n// Message Types (between content script and background)\n\nexport type MessageType =\n  | 'GET_FILTER'\n  | 'CHECK_JOB'\n  | 'GET_PREFERENCES'\n  | 'SET_PREFERENCES'\n  | 'GET_AUTH_STATUS'\n  | 'CLEAR_CACHE';\n\nexport interface Message<T = unknown> {\n  type: MessageType;\n  payload?: T;\n}\n\nexport interface MessageResponse<T = unknown> {\n  success: boolean;\n  data?: T;\n  error?: string;\n}\n","import {\n  StorageData,\n  UserPreferences,\n  DEFAULT_PREFERENCES,\n  Transcript,\n} from '../types';\n\nconst STORAGE_KEYS = {\n  PREFERENCES: 'safeplay_preferences',\n  AUTH_TOKEN: 'safeplay_auth_token',\n  USER_ID: 'safeplay_user_id',\n  SUBSCRIPTION_TIER: 'safeplay_subscription_tier',\n  CACHED_TRANSCRIPTS: 'safeplay_cached_transcripts',\n} as const;\n\nexport async function getPreferences(): Promise<UserPreferences> {\n  const result = await chrome.storage.local.get(STORAGE_KEYS.PREFERENCES);\n  return result[STORAGE_KEYS.PREFERENCES] || DEFAULT_PREFERENCES;\n}\n\nexport async function setPreferences(\n  preferences: Partial<UserPreferences>\n): Promise<UserPreferences> {\n  const current = await getPreferences();\n  const updated = { ...current, ...preferences };\n  await chrome.storage.local.set({ [STORAGE_KEYS.PREFERENCES]: updated });\n  return updated;\n}\n\nexport async function getAuthToken(): Promise<string | null> {\n  const result = await chrome.storage.local.get(STORAGE_KEYS.AUTH_TOKEN);\n  return result[STORAGE_KEYS.AUTH_TOKEN] || null;\n}\n\nexport async function setAuthToken(token: string): Promise<void> {\n  await chrome.storage.local.set({ [STORAGE_KEYS.AUTH_TOKEN]: token });\n}\n\nexport async function clearAuthToken(): Promise<void> {\n  await chrome.storage.local.remove(STORAGE_KEYS.AUTH_TOKEN);\n}\n\nexport async function getUserId(): Promise<string | null> {\n  const result = await chrome.storage.local.get(STORAGE_KEYS.USER_ID);\n  return result[STORAGE_KEYS.USER_ID] || null;\n}\n\nexport async function setUserId(userId: string): Promise<void> {\n  await chrome.storage.local.set({ [STORAGE_KEYS.USER_ID]: userId });\n}\n\nexport async function getSubscriptionTier(): Promise<\n  StorageData['subscriptionTier'] | null\n> {\n  const result = await chrome.storage.local.get(STORAGE_KEYS.SUBSCRIPTION_TIER);\n  return result[STORAGE_KEYS.SUBSCRIPTION_TIER] || null;\n}\n\nexport async function setSubscriptionTier(\n  tier: StorageData['subscriptionTier']\n): Promise<void> {\n  await chrome.storage.local.set({ [STORAGE_KEYS.SUBSCRIPTION_TIER]: tier });\n}\n\nexport async function getCachedTranscript(\n  youtubeId: string\n): Promise<Transcript | null> {\n  const result = await chrome.storage.local.get(STORAGE_KEYS.CACHED_TRANSCRIPTS);\n  const cache = result[STORAGE_KEYS.CACHED_TRANSCRIPTS] || {};\n  return cache[youtubeId] || null;\n}\n\nexport async function setCachedTranscript(\n  youtubeId: string,\n  transcript: Transcript\n): Promise<void> {\n  const result = await chrome.storage.local.get(STORAGE_KEYS.CACHED_TRANSCRIPTS);\n  const cache = result[STORAGE_KEYS.CACHED_TRANSCRIPTS] || {};\n  cache[youtubeId] = transcript;\n  await chrome.storage.local.set({ [STORAGE_KEYS.CACHED_TRANSCRIPTS]: cache });\n}\n\nexport async function clearCachedTranscripts(): Promise<void> {\n  await chrome.storage.local.remove(STORAGE_KEYS.CACHED_TRANSCRIPTS);\n}\n\nexport async function clearAllData(): Promise<void> {\n  await chrome.storage.local.clear();\n}\n\nexport async function isAuthenticated(): Promise<boolean> {\n  const token = await getAuthToken();\n  return token !== null;\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import { FilterResponse, JobStatusResponse, Transcript } from '../types';\nimport { getAuthToken } from '../utils/storage';\n\nconst API_BASE_URL = 'https://api.safeplay.app';\n\ninterface RequestOptions {\n  method?: 'GET' | 'POST' | 'PUT' | 'DELETE';\n  body?: unknown;\n  requiresAuth?: boolean;\n}\n\nclass ApiError extends Error {\n  constructor(\n    message: string,\n    public statusCode: number,\n    public response?: unknown\n  ) {\n    super(message);\n    this.name = 'ApiError';\n  }\n}\n\nasync function request<T>(\n  endpoint: string,\n  options: RequestOptions = {}\n): Promise<T> {\n  const { method = 'GET', body, requiresAuth = true } = options;\n\n  const headers: Record<string, string> = {\n    'Content-Type': 'application/json',\n  };\n\n  if (requiresAuth) {\n    const token = await getAuthToken();\n    if (token) {\n      headers['Authorization'] = `Bearer ${token}`;\n    }\n  }\n\n  const response = await fetch(`${API_BASE_URL}${endpoint}`, {\n    method,\n    headers,\n    body: body ? JSON.stringify(body) : undefined,\n  });\n\n  if (!response.ok) {\n    const errorData = await response.json().catch(() => ({}));\n    throw new ApiError(\n      errorData.message || `Request failed with status ${response.status}`,\n      response.status,\n      errorData\n    );\n  }\n\n  return response.json();\n}\n\nexport async function requestFilter(youtubeId: string): Promise<FilterResponse> {\n  return request<FilterResponse>('/api/filter', {\n    method: 'POST',\n    body: { youtube_id: youtubeId },\n  });\n}\n\nexport async function checkJobStatus(jobId: string): Promise<JobStatusResponse> {\n  return request<JobStatusResponse>(`/api/jobs/${jobId}`);\n}\n\nexport async function getTranscript(youtubeId: string): Promise<Transcript> {\n  return request<Transcript>(`/api/transcript/${youtubeId}`);\n}\n\nexport async function pollForTranscript(\n  jobId: string,\n  onProgress?: (progress: number) => void,\n  maxAttempts = 120,\n  intervalMs = 2000\n): Promise<Transcript> {\n  let attempts = 0;\n\n  while (attempts < maxAttempts) {\n    const status = await checkJobStatus(jobId);\n\n    if (onProgress) {\n      onProgress(status.progress);\n    }\n\n    if (status.status === 'completed' && status.transcript) {\n      return status.transcript;\n    }\n\n    if (status.status === 'failed') {\n      throw new ApiError(\n        status.error || 'Transcription failed',\n        500,\n        status\n      );\n    }\n\n    await new Promise((resolve) => setTimeout(resolve, intervalMs));\n    attempts++;\n  }\n\n  throw new ApiError('Transcription timed out', 408);\n}\n\nexport async function getOrRequestTranscript(\n  youtubeId: string,\n  onProgress?: (progress: number) => void\n): Promise<Transcript> {\n  const response = await requestFilter(youtubeId);\n\n  if (response.status === 'cached' && response.transcript) {\n    return response.transcript;\n  }\n\n  if (response.status === 'processing' && response.job_id) {\n    return pollForTranscript(response.job_id, onProgress);\n  }\n\n  throw new ApiError('Unexpected response from filter API', 500, response);\n}\n\nexport { ApiError };\n","// SafePlay Background Service Worker\nimport {\n  Message,\n  MessageResponse,\n  Transcript,\n  UserPreferences,\n} from '../types';\nimport {\n  getPreferences,\n  setPreferences,\n  getCachedTranscript,\n  setCachedTranscript,\n  getAuthToken,\n  clearCachedTranscripts,\n  isAuthenticated,\n} from '../utils/storage';\nimport { getOrRequestTranscript } from '../api/client';\n\nconst DEBUG = true;\n\nfunction log(...args: unknown[]): void {\n  if (DEBUG) {\n    console.log('[SafePlay BG]', ...args);\n  }\n}\n\n// Track active jobs for progress reporting (reserved for future use)\n// const activeJobs = new Map<string, { tabId: number; youtubeId: string }>();\n\n// Message handler\nchrome.runtime.onMessage.addListener(\n  (message: Message, sender, sendResponse: (response: MessageResponse) => void) => {\n    handleMessage(message, sender).then(sendResponse);\n    return true; // Keep channel open for async\n  }\n);\n\nasync function handleMessage(\n  message: Message,\n  sender: chrome.runtime.MessageSender\n): Promise<MessageResponse> {\n  log('Received message:', message.type);\n\n  try {\n    switch (message.type) {\n      case 'GET_FILTER':\n        return await handleGetFilter(\n          message.payload as { youtubeId: string },\n          sender.tab?.id\n        );\n\n      case 'CHECK_JOB':\n        return await handleCheckJob(message.payload as { jobId: string });\n\n      case 'GET_PREFERENCES':\n        return await handleGetPreferences();\n\n      case 'SET_PREFERENCES':\n        return await handleSetPreferences(\n          message.payload as Partial<UserPreferences>\n        );\n\n      case 'GET_AUTH_STATUS':\n        return await handleGetAuthStatus();\n\n      case 'CLEAR_CACHE':\n        return await handleClearCache();\n\n      default:\n        return { success: false, error: 'Unknown message type' };\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n    log('Message handler error:', errorMessage);\n    return { success: false, error: errorMessage };\n  }\n}\n\nasync function handleGetFilter(\n  payload: { youtubeId: string },\n  tabId?: number\n): Promise<MessageResponse<{ status: string; transcript?: Transcript; progress?: number }>> {\n  const { youtubeId } = payload;\n\n  // Check local cache first\n  const cached = await getCachedTranscript(youtubeId);\n  if (cached) {\n    log('Returning cached transcript for:', youtubeId);\n    return {\n      success: true,\n      data: { status: 'cached', transcript: cached },\n    };\n  }\n\n  // Check if authenticated (for now, skip auth check - will implement later)\n  // const authenticated = await isAuthenticated();\n  // if (!authenticated) {\n  //   return { success: false, error: 'Authentication required' };\n  // }\n\n  try {\n    // Request from API with progress callback\n    const transcript = await getOrRequestTranscript(youtubeId, (progress) => {\n      // Send progress updates to content script\n      if (tabId) {\n        chrome.tabs.sendMessage(tabId, {\n          type: 'PROCESSING_PROGRESS',\n          payload: { progress },\n        }).catch(() => {\n          // Tab might be closed\n        });\n      }\n    });\n\n    // Cache the transcript locally\n    await setCachedTranscript(youtubeId, transcript);\n\n    // Notify content script\n    if (tabId) {\n      chrome.tabs.sendMessage(tabId, {\n        type: 'TRANSCRIPT_RECEIVED',\n        payload: { transcript },\n      }).catch(() => {});\n    }\n\n    return {\n      success: true,\n      data: { status: 'completed', transcript },\n    };\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'Failed to get transcript';\n\n    // Notify content script of error\n    if (tabId) {\n      chrome.tabs.sendMessage(tabId, {\n        type: 'PROCESSING_ERROR',\n        payload: { error: errorMessage },\n      }).catch(() => {});\n    }\n\n    return { success: false, error: errorMessage };\n  }\n}\n\nasync function handleCheckJob(\n  _payload: { jobId: string }\n): Promise<MessageResponse> {\n  // This is handled within pollForTranscript, but keeping for direct polling if needed\n  return { success: true, data: { message: 'Use GET_FILTER instead' } };\n}\n\nasync function handleGetPreferences(): Promise<MessageResponse<UserPreferences>> {\n  const preferences = await getPreferences();\n  return { success: true, data: preferences };\n}\n\nasync function handleSetPreferences(\n  payload: Partial<UserPreferences>\n): Promise<MessageResponse<UserPreferences>> {\n  const updated = await setPreferences(payload);\n\n  // Broadcast to all YouTube tabs\n  const tabs = await chrome.tabs.query({ url: '*://www.youtube.com/*' });\n  for (const tab of tabs) {\n    if (tab.id) {\n      chrome.tabs.sendMessage(tab.id, {\n        type: 'PREFERENCES_UPDATED',\n        payload: updated,\n      }).catch(() => {});\n    }\n  }\n\n  return { success: true, data: updated };\n}\n\nasync function handleGetAuthStatus(): Promise<\n  MessageResponse<{ authenticated: boolean; token?: string }>\n> {\n  const authenticated = await isAuthenticated();\n  const token = authenticated ? (await getAuthToken()) || undefined : undefined;\n  return { success: true, data: { authenticated, token } };\n}\n\nasync function handleClearCache(): Promise<MessageResponse> {\n  await clearCachedTranscripts();\n  return { success: true };\n}\n\n// Handle extension icon click\nchrome.action.onClicked.addListener((_tab) => {\n  // Open popup is handled by manifest, but we can add extra logic here if needed\n  log('Extension icon clicked');\n});\n\n// Handle installation/update\nchrome.runtime.onInstalled.addListener((details) => {\n  log('Extension installed/updated:', details.reason);\n\n  if (details.reason === 'install') {\n    // First install - could open onboarding page\n    // chrome.tabs.create({ url: 'https://safeplay.app/welcome' });\n  }\n});\n\n// Handle auth callback from website (deep-link auth flow)\n// This will be implemented when we build the website\nchrome.runtime.onMessageExternal.addListener(\n  (message, sender, sendResponse) => {\n    // Handle messages from safeplay.app for auth\n    if (sender.origin === 'https://safeplay.app') {\n      if (message.type === 'AUTH_TOKEN') {\n        // Store the auth token\n        import('../utils/storage').then(({ setAuthToken, setUserId, setSubscriptionTier }) => {\n          Promise.all([\n            setAuthToken(message.token),\n            setUserId(message.userId),\n            setSubscriptionTier(message.tier),\n          ]).then(() => {\n            sendResponse({ success: true });\n          });\n        });\n        return true;\n      }\n    }\n    return false;\n  }\n);\n\nlog('SafePlay background service worker initialized');\n"],"names":["DEFAULT_PREFERENCES","enabled","filterMode","severityLevels","mild","moderate","severe","customBlacklist","customWhitelist","paddingMs","mergeThresholdMs","STORAGE_KEYS","async","getPreferences","chrome","storage","local","get","setPreferences","preferences","updated","set","getAuthToken","setAuthToken","token","setUserId","userId","setSubscriptionTier","tier","getCachedTranscript","youtubeId","setCachedTranscript","transcript","cache","clearCachedTranscripts","remove","isAuthenticated","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","obj","prop","prototype","hasOwnProperty","call","ApiError","Error","constructor","message","statusCode","response","super","this","name","request","endpoint","options","method","body","requiresAuth","headers","fetch","JSON","stringify","ok","errorData","json","catch","status","checkJobStatus","jobId","log","args","console","runtime","onMessage","addListener","sender","sendResponse","type","payload","tabId","cached","success","data","onProgress","youtube_id","requestFilter","job_id","maxAttempts","intervalMs","attempts","progress","error","Promise","resolve","setTimeout","pollForTranscript","getOrRequestTranscript","tabs","sendMessage","errorMessage","handleGetFilter","tab","id","handleCheckJob","handleGetPreferences","query","url","handleSetPreferences","authenticated","handleGetAuthStatus","handleClearCache","handleMessage","then","action","onClicked","_tab","onInstalled","details","reason","onMessageExternal","origin","all"],"ignoreList":[],"sourceRoot":""}