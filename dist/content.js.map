{"version":3,"file":"content.js","mappings":"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","sources":["webpack://safeplay-chrome-extension/./src/content/resilient-injector.ts","webpack://safeplay-chrome-extension/./src/filter/audio-filter.ts","webpack://safeplay-chrome-extension/./src/filter/profanity-list.ts","webpack://safeplay-chrome-extension/./src/filter/transcript-parser.ts","webpack://safeplay-chrome-extension/./src/content/video-controller.ts","webpack://safeplay-chrome-extension/./src/content/smooth-progress.ts","webpack://safeplay-chrome-extension/./src/content/caption-filter.ts","webpack://safeplay-chrome-extension/./src/types/index.ts","webpack://safeplay-chrome-extension/./src/content/index.ts"],"sourcesContent":["// SafePlay Video Page Button Injector\n// Injects the SafePlay button next to the Subscribe button on YouTube watch pages\n\nimport { ButtonState, ButtonStateInfo } from '../types';\n\nexport interface InjectorOptions {\n  onButtonClick: (youtubeId: string) => void;\n  debug?: boolean;\n}\n\nconst PROCESSED_ATTR = 'data-safeplay-processed';\nconst BUTTON_CONTAINER_CLASS = 'safeplay-video-page-button-container';\n\n// Button state configurations with YouTube theme colors\nconst BUTTON_STATES: Record<ButtonState, { bg: string; hoverBg: string; text: string; shadow: string }> = {\n  idle: {\n    bg: '#ff0000', // YouTube red\n    hoverBg: '#cc0000',\n    text: 'SafePlay',\n    shadow: 'rgba(255, 0, 0, 0.3)',\n  },\n  connecting: {\n    bg: '#3f3f3f', // YouTube dark gray\n    hoverBg: '#4f4f4f',\n    text: 'Connecting...',\n    shadow: 'rgba(63, 63, 63, 0.3)',\n  },\n  downloading: {\n    bg: '#a855f7', // Purple processing\n    hoverBg: '#9333ea',\n    text: 'Analyzing...',\n    shadow: 'rgba(168, 85, 247, 0.4)',\n  },\n  transcribing: {\n    bg: '#a855f7', // Purple processing\n    hoverBg: '#9333ea',\n    text: 'Analyzing...',\n    shadow: 'rgba(168, 85, 247, 0.4)',\n  },\n  processing: {\n    bg: '#a855f7', // Purple processing\n    hoverBg: '#9333ea',\n    text: 'Analyzing...',\n    shadow: 'rgba(168, 85, 247, 0.4)',\n  },\n  filtering: {\n    bg: '#2ba640', // YouTube success green\n    hoverBg: '#239a36',\n    text: 'Active',\n    shadow: 'rgba(43, 166, 64, 0.4)',\n  },\n  error: {\n    bg: '#ff4e45', // YouTube error red-orange\n    hoverBg: '#e63e35',\n    text: 'Retry',\n    shadow: 'rgba(255, 78, 69, 0.4)',\n  },\n};\n\nexport class ResilientInjector {\n  private options: InjectorOptions;\n  private observer: MutationObserver | null = null;\n  private currentVideoId: string | null = null;\n  private injectionAttempts = 0;\n  private maxAttempts = 50;\n  private retryInterval: number | null = null;\n  private currentState: ButtonState = 'idle';\n\n  constructor(options: InjectorOptions) {\n    this.options = options;\n  }\n\n  // Start observing and injecting\n  start(): void {\n    this.log('Starting video page injector');\n\n    // Initial injection attempt\n    this.attemptInjection();\n\n    // Set up mutation observer for SPA navigation\n    this.setupMutationObserver();\n\n    // Listen for YouTube SPA navigation\n    this.setupNavigationListener();\n  }\n\n  // Stop observing\n  stop(): void {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = null;\n    }\n\n    if (this.retryInterval !== null) {\n      clearInterval(this.retryInterval);\n      this.retryInterval = null;\n    }\n\n    this.log('Stopped video page injector');\n  }\n\n  private isWatchPage(): boolean {\n    return window.location.pathname === '/watch' &&\n           window.location.search.includes('v=');\n  }\n\n  private getVideoId(): string | null {\n    const urlParams = new URLSearchParams(window.location.search);\n    return urlParams.get('v');\n  }\n\n  // Main injection function\n  private attemptInjection(): void {\n    if (!this.isWatchPage()) {\n      return;\n    }\n\n    const videoId = this.getVideoId();\n    if (!videoId) {\n      this.log('No video ID found');\n      return;\n    }\n\n    // Check if already injected for this video\n    if (this.currentVideoId === videoId && this.isButtonPresent()) {\n      this.log('Button already present for this video');\n      return;\n    }\n\n    // Try to find the subscribe button container\n    const subscribeButton = this.findSubscribeButton();\n\n    if (subscribeButton) {\n      this.injectButton(subscribeButton, videoId);\n      this.currentVideoId = videoId;\n      this.injectionAttempts = 0;\n      if (this.retryInterval !== null) {\n        clearInterval(this.retryInterval);\n        this.retryInterval = null;\n      }\n    } else {\n      this.injectionAttempts++;\n      this.log(`Subscribe button not found, attempt ${this.injectionAttempts}/${this.maxAttempts}`);\n\n      // Retry with interval\n      if (this.injectionAttempts < this.maxAttempts && this.retryInterval === null) {\n        this.retryInterval = window.setInterval(() => {\n          this.attemptInjection();\n        }, 200);\n      }\n    }\n  }\n\n  private findSubscribeButton(): HTMLElement | null {\n    const selectors = [\n      '#subscribe-button.ytd-watch-metadata',\n      'ytd-watch-metadata #subscribe-button',\n      '#owner #subscribe-button',\n      '#subscribe-button',\n    ];\n\n    for (const selector of selectors) {\n      const element = document.querySelector<HTMLElement>(selector);\n      if (element) {\n        this.log(`Found subscribe button with selector: ${selector}`);\n        return element;\n      }\n    }\n\n    return null;\n  }\n\n  private isButtonPresent(): boolean {\n    return document.querySelector(`.${BUTTON_CONTAINER_CLASS}`) !== null;\n  }\n\n  private injectButton(subscribeButton: HTMLElement, videoId: string): void {\n    // Remove any existing SafePlay button\n    const existingButton = document.querySelector(`.${BUTTON_CONTAINER_CLASS}`);\n    if (existingButton) {\n      existingButton.remove();\n    }\n\n    // Reset state for new video\n    this.currentState = 'idle';\n\n    // Create button container\n    const container = document.createElement('div');\n    container.className = `${BUTTON_CONTAINER_CLASS} style-scope ytd-watch-metadata`;\n    container.style.cssText = 'display: inline-flex; align-items: center; margin-left: 8px;';\n    container.setAttribute(PROCESSED_ATTR, 'true');\n\n    // Create the button matching YouTube's style\n    const button = document.createElement('button');\n    button.className = 'safeplay-main-button yt-spec-button-shape-next yt-spec-button-shape-next--tonal yt-spec-button-shape-next--mono yt-spec-button-shape-next--size-m yt-spec-button-shape-next--icon-leading';\n    button.title = 'Filter profanity with SafePlay';\n    button.setAttribute('aria-label', 'SafePlay Filter');\n    button.setAttribute('data-video-id', videoId);\n\n    const stateConfig = BUTTON_STATES.idle;\n    button.style.cssText = `\n      border: none;\n      background: ${stateConfig.bg};\n      color: #ffffff;\n      border-radius: 18px;\n      padding: 0 16px;\n      height: 36px;\n      font-family: \"Roboto\", \"Arial\", sans-serif;\n      font-size: 14px;\n      font-weight: 500;\n      line-height: 36px;\n      display: inline-flex;\n      align-items: center;\n      justify-content: center;\n      gap: 6px;\n      cursor: pointer;\n      transition: all 0.2s ease;\n      min-width: 120px;\n      box-shadow: 0 2px 4px ${stateConfig.shadow};\n      position: relative;\n      overflow: hidden;\n    `;\n\n    // Create progress bar (hidden initially)\n    const progressBar = document.createElement('div');\n    progressBar.className = 'safeplay-progress-bar';\n    progressBar.style.cssText = `\n      position: absolute;\n      bottom: 0;\n      left: 0;\n      height: 3px;\n      width: 0%;\n      background: rgba(255, 255, 255, 0.5);\n      transition: width 0.3s ease;\n      border-radius: 0 0 18px 18px;\n    `;\n\n    // Add icon\n    const iconWrapper = document.createElement('div');\n    iconWrapper.className = 'safeplay-icon';\n    iconWrapper.style.cssText = 'display: inline-flex; align-items: center; justify-content: center; width: 20px; height: 20px; flex-shrink: 0;';\n    iconWrapper.innerHTML = this.getIconSVG('idle');\n\n    // Add text\n    const textSpan = document.createElement('span');\n    textSpan.className = 'safeplay-text';\n    textSpan.style.cssText = 'color: currentColor; font-size: 14px; font-weight: 500; line-height: 1; white-space: nowrap;';\n    textSpan.textContent = stateConfig.text;\n\n    button.appendChild(iconWrapper);\n    button.appendChild(textSpan);\n    button.appendChild(progressBar);\n\n    // Add hover effects\n    button.addEventListener('mouseenter', () => {\n      const config = BUTTON_STATES[this.currentState];\n      button.style.background = config.hoverBg;\n      button.style.boxShadow = `0 4px 8px ${config.shadow}`;\n      button.style.transform = 'translateY(-1px)';\n    });\n\n    button.addEventListener('mouseleave', () => {\n      const config = BUTTON_STATES[this.currentState];\n      button.style.background = config.bg;\n      button.style.boxShadow = `0 2px 4px ${config.shadow}`;\n      button.style.transform = 'translateY(0)';\n    });\n\n    // Add click handler\n    button.addEventListener('click', (e) => {\n      e.preventDefault();\n      e.stopPropagation();\n\n      // Only allow click in idle or error state\n      if (this.currentState === 'idle' || this.currentState === 'error') {\n        this.options.onButtonClick(videoId);\n      }\n    });\n\n    container.appendChild(button);\n\n    // Insert after subscribe button\n    subscribeButton.parentElement?.insertBefore(container, subscribeButton.nextSibling);\n\n    this.log(`Injected SafePlay button for video: ${videoId}`);\n  }\n\n  private getIconSVG(state: ButtonState): string {\n    switch (state) {\n      case 'connecting':\n      case 'downloading':\n      case 'transcribing':\n      case 'processing':\n        // Spinning loader icon\n        return `\n          <svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" class=\"safeplay-spinner\">\n            <style>.safeplay-spinner { animation: safeplay-spin 1s linear infinite; } @keyframes safeplay-spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }</style>\n            <circle cx=\"12\" cy=\"12\" r=\"10\" stroke-opacity=\"0.25\"/>\n            <path d=\"M12 2a10 10 0 0 1 10 10\" stroke-linecap=\"round\"/>\n          </svg>\n        `;\n      case 'filtering':\n        // Active shield icon\n        return `\n          <svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n            <path d=\"M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm-2 16l-4-4 1.41-1.41L10 14.17l6.59-6.59L18 9l-8 8z\"/>\n          </svg>\n        `;\n      case 'error':\n        // Error icon\n        return `\n          <svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n            <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z\"/>\n          </svg>\n        `;\n      default:\n        // Default checkmark icon\n        return `\n          <svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n            <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z\"/>\n          </svg>\n        `;\n    }\n  }\n\n  // Update button state with detailed info\n  updateButtonState(stateInfo: ButtonStateInfo): void {\n    const container = document.querySelector(`.${BUTTON_CONTAINER_CLASS}`);\n    if (!container) return;\n\n    const button = container.querySelector<HTMLButtonElement>('.safeplay-main-button');\n    const textSpan = container.querySelector<HTMLSpanElement>('.safeplay-text');\n    const iconWrapper = container.querySelector<HTMLDivElement>('.safeplay-icon');\n    const progressBar = container.querySelector<HTMLDivElement>('.safeplay-progress-bar');\n\n    if (!button || !textSpan || !iconWrapper) return;\n\n    this.currentState = stateInfo.state;\n    const config = BUTTON_STATES[stateInfo.state];\n\n    // Update colors\n    button.style.background = config.bg;\n    button.style.boxShadow = `0 2px 4px ${config.shadow}`;\n\n    // Update icon\n    iconWrapper.innerHTML = this.getIconSVG(stateInfo.state);\n\n    // Update text\n    let displayText = stateInfo.text || config.text;\n\n    // Add progress percentage for processing states\n    if (stateInfo.progress !== undefined && stateInfo.progress > 0) {\n      if (stateInfo.state === 'downloading' || stateInfo.state === 'transcribing' || stateInfo.state === 'processing') {\n        displayText = `${config.text.replace('...', '')} ${Math.round(stateInfo.progress)}%`;\n      }\n    }\n\n    // Add interval count for filtering state\n    if (stateInfo.state === 'filtering' && stateInfo.intervalCount !== undefined) {\n      displayText = `Filtering (${stateInfo.intervalCount})`;\n    }\n\n    textSpan.textContent = displayText;\n\n    // Update progress bar\n    if (progressBar) {\n      if (stateInfo.progress !== undefined && stateInfo.progress > 0 && stateInfo.progress < 100) {\n        progressBar.style.width = `${stateInfo.progress}%`;\n        progressBar.style.display = 'block';\n      } else {\n        progressBar.style.width = '0%';\n        progressBar.style.display = 'none';\n      }\n    }\n\n    // Update cursor\n    if (stateInfo.state === 'idle' || stateInfo.state === 'error') {\n      button.style.cursor = 'pointer';\n    } else {\n      button.style.cursor = 'default';\n    }\n\n    // Update title/tooltip\n    switch (stateInfo.state) {\n      case 'connecting':\n        button.title = 'Connecting to SafePlay service...';\n        break;\n      case 'downloading':\n        button.title = `Downloading video audio${stateInfo.progress ? ` (${Math.round(stateInfo.progress)}%)` : '...'}`;\n        break;\n      case 'transcribing':\n        button.title = `Transcribing audio${stateInfo.progress ? ` (${Math.round(stateInfo.progress)}%)` : '...'}`;\n        break;\n      case 'processing':\n        button.title = 'Processing transcript...';\n        break;\n      case 'filtering':\n        button.title = `Filtering profanity${stateInfo.intervalCount ? ` - ${stateInfo.intervalCount} instances found` : ''}`;\n        break;\n      case 'error':\n        button.title = stateInfo.error || 'An error occurred. Click to retry.';\n        break;\n      default:\n        button.title = 'Click to filter profanity with SafePlay';\n    }\n\n    this.log(`Button state updated to: ${stateInfo.state}`, stateInfo);\n  }\n\n  // Convenience method for simple state updates\n  setButtonState(state: ButtonState, text?: string, progress?: number): void {\n    this.updateButtonState({ state, text: text || '', progress });\n  }\n\n  // Set up mutation observer for dynamic content changes\n  private setupMutationObserver(): void {\n    this.observer = new MutationObserver((mutations) => {\n      for (const mutation of mutations) {\n        if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {\n          for (const node of mutation.addedNodes) {\n            if (node instanceof HTMLElement) {\n              if (node.id === 'subscribe-button' ||\n                  node.querySelector?.('#subscribe-button') ||\n                  node.closest?.('ytd-watch-metadata')) {\n                this.log('Subscribe button area changed, re-injecting');\n                this.attemptInjection();\n                return;\n              }\n            }\n          }\n        }\n      }\n    });\n\n    this.observer.observe(document.body, {\n      childList: true,\n      subtree: true,\n    });\n  }\n\n  // Listen for YouTube SPA navigation\n  private setupNavigationListener(): void {\n    const originalPushState = history.pushState;\n    const originalReplaceState = history.replaceState;\n\n    history.pushState = (...args) => {\n      originalPushState.apply(history, args);\n      this.onNavigation();\n    };\n\n    history.replaceState = (...args) => {\n      originalReplaceState.apply(history, args);\n      this.onNavigation();\n    };\n\n    window.addEventListener('popstate', () => {\n      this.onNavigation();\n    });\n\n    document.addEventListener('yt-navigate-finish', () => {\n      this.onNavigation();\n    });\n\n    document.addEventListener('yt-page-data-updated', () => {\n      this.log('Page data updated');\n      this.onNavigation();\n    });\n  }\n\n  private onNavigation(): void {\n    this.log('Navigation detected');\n    this.currentVideoId = null;\n    this.currentState = 'idle';\n    this.injectionAttempts = 0;\n\n    if (this.retryInterval !== null) {\n      clearInterval(this.retryInterval);\n      this.retryInterval = null;\n    }\n\n    setTimeout(() => {\n      this.attemptInjection();\n    }, 300);\n  }\n\n  // Get current video ID\n  getCurrentVideoId(): string | null {\n    return this.currentVideoId;\n  }\n\n  // Debug logging\n  private log(...args: unknown[]): void {\n    if (this.options.debug) {\n      console.log('[SafePlay Injector]', ...args);\n    }\n  }\n}\n","import { MuteInterval, FilterMode } from '../types';\n\n// Fade duration in seconds for smooth transitions\nconst FADE_DURATION = 0.05; // 50ms fade - fast but smooth\nconst FADE_BUFFER = 0.08; // 80ms - start fading before interval begins\n\nexport class AudioFilter {\n  private video: HTMLVideoElement | null = null;\n  private muteIntervals: MuteInterval[] = [];\n  private filterMode: FilterMode = 'mute';\n  private isActive = false;\n  private checkIntervalId: number | null = null;\n  private isMuted = false;\n  private isFading = false;\n\n  // Web Audio API for smooth volume control\n  private audioContext: AudioContext | null = null;\n  private sourceNode: MediaElementAudioSourceNode | null = null;\n  private gainNode: GainNode | null = null;\n\n  // Bleep sound nodes\n  private bleepOscillator: OscillatorNode | null = null;\n  private bleepGain: GainNode | null = null;\n\n  // Track current gain target to avoid redundant fades\n  private currentGainTarget = 1;\n\n  // Callbacks\n  private onMuteStart?: (interval: MuteInterval) => void;\n  private onMuteEnd?: () => void;\n\n  constructor(options?: {\n    onMuteStart?: (interval: MuteInterval) => void;\n    onMuteEnd?: () => void;\n  }) {\n    this.onMuteStart = options?.onMuteStart;\n    this.onMuteEnd = options?.onMuteEnd;\n  }\n\n  // Initialize with video element and mute intervals\n  initialize(\n    video: HTMLVideoElement,\n    intervals: MuteInterval[],\n    mode: FilterMode = 'mute'\n  ): void {\n    this.video = video;\n    this.muteIntervals = intervals;\n    this.filterMode = mode;\n\n    // Sort intervals by start time for efficient lookup\n    this.muteIntervals.sort((a, b) => a.start - b.start);\n\n    // Initialize Web Audio API for smooth volume control\n    this.initializeAudioContext();\n  }\n\n  private initializeAudioContext(): void {\n    if (!this.video || this.audioContext) return;\n\n    try {\n      this.audioContext = new AudioContext();\n\n      // Create source from video element\n      this.sourceNode = this.audioContext.createMediaElementSource(this.video);\n\n      // Create gain node for volume control\n      this.gainNode = this.audioContext.createGain();\n      this.gainNode.gain.value = 1; // Start at full volume\n\n      // Connect: video -> gain -> destination (speakers)\n      this.sourceNode.connect(this.gainNode);\n      this.gainNode.connect(this.audioContext.destination);\n\n      // Setup bleep gain for bleep mode\n      if (this.filterMode === 'bleep') {\n        this.bleepGain = this.audioContext.createGain();\n        this.bleepGain.gain.value = 0;\n        this.bleepGain.connect(this.audioContext.destination);\n      }\n\n      console.log('[SafePlay] Audio context initialized with smooth fading');\n    } catch (error) {\n      console.error('[SafePlay] Failed to initialize audio context:', error);\n      // Fallback: will use video.muted instead\n    }\n  }\n\n  // Start monitoring playback\n  start(): void {\n    if (this.isActive || !this.video) {\n      return;\n    }\n\n    this.isActive = true;\n\n    // Resume audio context if suspended (browser autoplay policy)\n    if (this.audioContext?.state === 'suspended') {\n      this.audioContext.resume();\n    }\n\n    // Check every 5ms for precise timing\n    this.checkIntervalId = window.setInterval(() => {\n      this.checkCurrentTime();\n    }, 5);\n\n    console.log('[SafePlay] Audio filter started with', this.muteIntervals.length, 'intervals (smooth fading enabled)');\n  }\n\n  // Stop monitoring\n  stop(): void {\n    if (!this.isActive) {\n      return;\n    }\n\n    this.isActive = false;\n\n    if (this.checkIntervalId !== null) {\n      clearInterval(this.checkIntervalId);\n      this.checkIntervalId = null;\n    }\n\n    // Restore full volume\n    this.fadeToVolume(1);\n\n    // Stop bleep if playing\n    if (this.bleepOscillator) {\n      this.bleepOscillator.stop();\n      this.bleepOscillator = null;\n    }\n\n    console.log('[SafePlay] Audio filter stopped');\n  }\n\n  // Clean up resources\n  destroy(): void {\n    this.stop();\n\n    if (this.sourceNode) {\n      this.sourceNode.disconnect();\n      this.sourceNode = null;\n    }\n\n    if (this.gainNode) {\n      this.gainNode.disconnect();\n      this.gainNode = null;\n    }\n\n    if (this.audioContext) {\n      this.audioContext.close();\n      this.audioContext = null;\n    }\n  }\n\n  // Check if current time falls within or is approaching any mute interval\n  private checkCurrentTime(): void {\n    if (!this.video || !this.isActive) {\n      return;\n    }\n\n    const currentTime = this.video.currentTime;\n\n    // Check if we're in an interval OR approaching one (within fade buffer)\n    const activeInterval = this.findActiveInterval(currentTime);\n    const approachingInterval = this.findApproachingInterval(currentTime);\n\n    if (activeInterval) {\n      // We're inside a mute interval - ensure volume is 0\n      if (!this.isMuted) {\n        this.startMute(activeInterval);\n      }\n    } else if (approachingInterval) {\n      // We're approaching an interval - start fading out\n      if (!this.isMuted && !this.isFading) {\n        this.startFadeOut(approachingInterval);\n      }\n    } else {\n      // We're outside all intervals - ensure volume is restored\n      if (this.isMuted) {\n        this.endMute();\n      }\n    }\n  }\n\n  // Find if we're currently inside a mute interval\n  private findActiveInterval(time: number): MuteInterval | null {\n    for (const interval of this.muteIntervals) {\n      if (time >= interval.start && time <= interval.end) {\n        return interval;\n      }\n      // Since sorted, we can break early\n      if (interval.start > time + FADE_BUFFER) {\n        break;\n      }\n    }\n    return null;\n  }\n\n  // Find if we're approaching a mute interval (within fade buffer)\n  private findApproachingInterval(time: number): MuteInterval | null {\n    for (const interval of this.muteIntervals) {\n      // Check if we're within the fade buffer before the interval starts\n      const fadeStartTime = interval.start - FADE_BUFFER;\n      if (time >= fadeStartTime && time < interval.start) {\n        return interval;\n      }\n      // Since sorted, we can break early\n      if (interval.start > time + FADE_BUFFER) {\n        break;\n      }\n    }\n    return null;\n  }\n\n  // Start fading out before the interval\n  private startFadeOut(interval: MuteInterval): void {\n    this.isFading = true;\n    this.fadeToVolume(0, () => {\n      this.isFading = false;\n      this.isMuted = true;\n      if (this.onMuteStart) {\n        this.onMuteStart(interval);\n      }\n    });\n\n    // Start bleep if in bleep mode\n    if (this.filterMode === 'bleep') {\n      this.startBleep();\n    }\n  }\n\n  // Immediately mute (when we enter an interval without approaching it first, e.g., seeking)\n  private startMute(interval: MuteInterval): void {\n    this.isMuted = true;\n    this.fadeToVolume(0);\n\n    if (this.filterMode === 'bleep') {\n      this.startBleep();\n    }\n\n    if (this.onMuteStart) {\n      this.onMuteStart(interval);\n    }\n  }\n\n  // End mute - fade back in\n  private endMute(): void {\n    this.isMuted = false;\n    this.fadeToVolume(1);\n\n    if (this.filterMode === 'bleep') {\n      this.stopBleep();\n    }\n\n    if (this.onMuteEnd) {\n      this.onMuteEnd();\n    }\n  }\n\n  // Smooth fade to target volume\n  private fadeToVolume(target: number, onComplete?: () => void): void {\n    // Skip if already at target\n    if (this.currentGainTarget === target) {\n      onComplete?.();\n      return;\n    }\n\n    this.currentGainTarget = target;\n\n    if (this.gainNode && this.audioContext) {\n      const now = this.audioContext.currentTime;\n\n      // Cancel any ongoing transitions\n      this.gainNode.gain.cancelScheduledValues(now);\n\n      // Set current value\n      this.gainNode.gain.setValueAtTime(this.gainNode.gain.value, now);\n\n      // Ramp to target over fade duration\n      this.gainNode.gain.linearRampToValueAtTime(target, now + FADE_DURATION);\n\n      // Call completion callback after fade\n      if (onComplete) {\n        setTimeout(onComplete, FADE_DURATION * 1000);\n      }\n    } else {\n      // Fallback to hard mute if no audio context\n      if (this.video) {\n        this.video.muted = target === 0;\n      }\n      onComplete?.();\n    }\n  }\n\n  // Classic TV censor bleep settings\n  private readonly BLEEP_FREQUENCY = 1000; // 1kHz - the classic censor bleep frequency\n  private readonly BLEEP_VOLUME = 0.35; // Volume level (0-1)\n  private readonly BLEEP_ATTACK = 0.008; // 8ms attack - very fast like real censor bleeps\n  private readonly BLEEP_RELEASE = 0.025; // 25ms release - slightly slower to avoid clicks\n\n  private startBleep(): void {\n    if (!this.audioContext || !this.bleepGain) return;\n\n    // Resume audio context if suspended\n    if (this.audioContext.state === 'suspended') {\n      this.audioContext.resume();\n    }\n\n    // Create main oscillator for classic censor bleep\n    this.bleepOscillator = this.audioContext.createOscillator();\n    this.bleepOscillator.type = 'sine'; // Pure sine wave for clean bleep\n    this.bleepOscillator.frequency.value = this.BLEEP_FREQUENCY;\n\n    // Create a subtle second oscillator slightly detuned for richness (optional TV effect)\n    const oscillator2 = this.audioContext.createOscillator();\n    oscillator2.type = 'sine';\n    oscillator2.frequency.value = this.BLEEP_FREQUENCY * 1.001; // Slight detune for thickness\n\n    // Create a mixer for the two oscillators\n    const mixer = this.audioContext.createGain();\n    mixer.gain.value = 0.5;\n\n    // Connect oscillators\n    this.bleepOscillator.connect(this.bleepGain);\n    oscillator2.connect(mixer);\n    mixer.connect(this.bleepGain);\n\n    // Fast attack envelope - classic censor bleep snaps on quickly\n    const now = this.audioContext.currentTime;\n    this.bleepGain.gain.setValueAtTime(0, now);\n    this.bleepGain.gain.linearRampToValueAtTime(this.BLEEP_VOLUME, now + this.BLEEP_ATTACK);\n\n    // Start both oscillators\n    this.bleepOscillator.start(now);\n    oscillator2.start(now);\n\n    // Store reference to second oscillator for cleanup\n    (this.bleepOscillator as any)._secondOscillator = oscillator2;\n    (this.bleepOscillator as any)._mixer = mixer;\n  }\n\n  private stopBleep(): void {\n    if (!this.audioContext || !this.bleepGain || !this.bleepOscillator) return;\n\n    // Smooth release to avoid clicks\n    const now = this.audioContext.currentTime;\n    this.bleepGain.gain.setValueAtTime(this.bleepGain.gain.value, now);\n    this.bleepGain.gain.linearRampToValueAtTime(0, now + this.BLEEP_RELEASE);\n\n    // Stop and disconnect after release completes\n    const oscillator = this.bleepOscillator;\n    const oscillator2 = (oscillator as any)._secondOscillator;\n    const mixer = (oscillator as any)._mixer;\n\n    setTimeout(() => {\n      try {\n        oscillator.stop();\n        oscillator.disconnect();\n        if (oscillator2) {\n          oscillator2.stop();\n          oscillator2.disconnect();\n        }\n        if (mixer) {\n          mixer.disconnect();\n        }\n      } catch (e) {\n        // Already stopped\n      }\n    }, this.BLEEP_RELEASE * 1000 + 10);\n\n    this.bleepOscillator = null;\n  }\n\n  // Update intervals (e.g., when preferences change)\n  updateIntervals(intervals: MuteInterval[]): void {\n    this.muteIntervals = intervals;\n    this.muteIntervals.sort((a, b) => a.start - b.start);\n  }\n\n  // Update filter mode\n  updateMode(mode: FilterMode): void {\n    this.filterMode = mode;\n\n    // Initialize bleep gain if switching to bleep mode\n    if (mode === 'bleep' && this.audioContext && !this.bleepGain) {\n      this.bleepGain = this.audioContext.createGain();\n      this.bleepGain.gain.value = 0;\n      this.bleepGain.connect(this.audioContext.destination);\n    }\n  }\n\n  // Get current state\n  getState(): {\n    isActive: boolean;\n    isMuted: boolean;\n    intervalCount: number;\n    filterMode: FilterMode;\n  } {\n    return {\n      isActive: this.isActive,\n      isMuted: this.isMuted,\n      intervalCount: this.muteIntervals.length,\n      filterMode: this.filterMode,\n    };\n  }\n\n  // Check if filtering is active\n  isFiltering(): boolean {\n    return this.isActive;\n  }\n\n  // Get all intervals (for debugging/display)\n  getIntervals(): MuteInterval[] {\n    return [...this.muteIntervals];\n  }\n}\n","import { ProfanityWord, SeverityLevel } from '../types';\n\n// Comprehensive profanity list with severity levels\n// Severity: mild (common/casual), moderate (offensive), severe (highly offensive), religious (religious terms)\n\nexport const PROFANITY_LIST: ProfanityWord[] = [\n  // Religious - opt-in category for religious terms some users may want filtered\n  { word: 'jesus', severity: 'religious' },\n  { word: 'jesus christ', severity: 'religious' },\n  { word: 'jesus fucking christ', severity: 'religious' },\n  { word: 'christ', severity: 'religious' },\n  { word: 'christ almighty', severity: 'religious' },\n  { word: 'god', severity: 'religious' },\n  { word: 'oh my god', severity: 'religious' },\n  { word: 'omg', severity: 'religious' },\n  { word: 'oh god', severity: 'religious' },\n  { word: 'my god', severity: 'religious' },\n  { word: 'for gods sake', severity: 'religious' },\n  { word: 'for god\\'s sake', severity: 'religious' },\n  { word: 'god almighty', severity: 'religious' },\n  { word: 'swear to god', severity: 'religious' },\n  { word: 'i swear to god', severity: 'religious' },\n\n  // Goddamn variations - all spellings and spacings\n  { word: 'goddamn', severity: 'religious' },\n  { word: 'goddamned', severity: 'religious' },\n  { word: 'goddamnit', severity: 'religious' },\n  { word: 'goddammit', severity: 'religious' },\n  { word: 'goddamit', severity: 'religious' },\n  { word: 'goddam', severity: 'religious' },\n  { word: 'goddams', severity: 'religious' },\n  { word: 'god damn', severity: 'religious' },\n  { word: 'god damned', severity: 'religious' },\n  { word: 'god damnit', severity: 'religious' },\n  { word: 'god dammit', severity: 'religious' },\n  { word: 'god damn it', severity: 'religious' },\n  { word: 'god-damn', severity: 'religious' },\n  { word: 'god-damned', severity: 'religious' },\n  { word: 'god-damnit', severity: 'religious' },\n  { word: 'god-dammit', severity: 'religious' },\n  { word: 'godd*mn', severity: 'religious' },\n  { word: 'g*ddamn', severity: 'religious' },\n  { word: 'gd', severity: 'religious' },\n  { word: 'gdamn', severity: 'religious' },\n  { word: 'gotdamn', severity: 'religious' },\n  { word: 'gotdam', severity: 'religious' },\n  { word: 'got damn', severity: 'religious' },\n  { word: 'got dam', severity: 'religious' },\n  { word: 'gahdamn', severity: 'religious' },\n  { word: 'gawddamn', severity: 'religious' },\n  { word: 'gahdam', severity: 'religious' },\n\n  // Lord variations\n  { word: 'lord', severity: 'religious' },\n  { word: 'oh lord', severity: 'religious' },\n  { word: 'dear lord', severity: 'religious' },\n  { word: 'good lord', severity: 'religious' },\n  { word: 'lord almighty', severity: 'religious' },\n  { word: 'lord have mercy', severity: 'religious' },\n  { word: 'lordy', severity: 'religious' },\n  { word: 'lawdy', severity: 'religious' },\n  { word: 'lawd', severity: 'religious' },\n  { word: 'oh lawd', severity: 'religious' },\n\n  // Holy variations\n  { word: 'holy', severity: 'religious' },\n  { word: 'holy shit', severity: 'religious' },\n  { word: 'holy crap', severity: 'religious' },\n  { word: 'holy hell', severity: 'religious' },\n  { word: 'holy fuck', severity: 'religious' },\n  { word: 'holy cow', severity: 'religious' },\n  { word: 'holy smokes', severity: 'religious' },\n  { word: 'holy moly', severity: 'religious' },\n  { word: 'holy mother', severity: 'religious' },\n  { word: 'holy mother of god', severity: 'religious' },\n  { word: 'for christ\\'s sake', severity: 'religious' },\n  { word: 'for christs sake', severity: 'religious' },\n  { word: 'chrissake', severity: 'religious' },\n  { word: 'crissake', severity: 'religious' },\n\n  // Severe\n  { word: 'fuck', severity: 'severe' },\n  { word: 'fucking', severity: 'severe' },\n  { word: 'fucked', severity: 'severe' },\n  { word: 'fucker', severity: 'severe' },\n  { word: 'fuckers', severity: 'severe' },\n  { word: 'fucks', severity: 'severe' },\n  { word: 'motherfucker', severity: 'severe' },\n  { word: 'motherfucking', severity: 'severe' },\n  { word: 'motherfuckers', severity: 'severe' },\n  { word: 'cunt', severity: 'severe' },\n  { word: 'cunts', severity: 'severe' },\n  { word: 'nigger', severity: 'severe' },\n  { word: 'niggers', severity: 'severe' },\n  { word: 'nigga', severity: 'severe' },\n  { word: 'niggas', severity: 'severe' },\n  { word: 'faggot', severity: 'severe' },\n  { word: 'faggots', severity: 'severe' },\n  { word: 'fag', severity: 'severe' },\n  { word: 'fags', severity: 'severe' },\n  { word: 'retard', severity: 'severe' },\n  { word: 'retarded', severity: 'severe' },\n  { word: 'retards', severity: 'severe' },\n\n  // Moderate\n  { word: 'shit', severity: 'moderate' },\n  { word: 'shits', severity: 'moderate' },\n  { word: 'shitty', severity: 'moderate' },\n  { word: 'bullshit', severity: 'moderate' },\n  { word: 'horseshit', severity: 'moderate' },\n  { word: 'shithead', severity: 'moderate' },\n  { word: 'shitheads', severity: 'moderate' },\n  { word: 'ass', severity: 'moderate' },\n  { word: 'asses', severity: 'moderate' },\n  { word: 'asshole', severity: 'moderate' },\n  { word: 'assholes', severity: 'moderate' },\n  { word: 'bastard', severity: 'moderate' },\n  { word: 'bastards', severity: 'moderate' },\n  { word: 'bitch', severity: 'moderate' },\n  { word: 'bitches', severity: 'moderate' },\n  { word: 'bitchy', severity: 'moderate' },\n  { word: 'cock', severity: 'moderate' },\n  { word: 'cocks', severity: 'moderate' },\n  { word: 'cocksucker', severity: 'moderate' },\n  { word: 'cocksuckers', severity: 'moderate' },\n  { word: 'dick', severity: 'moderate' },\n  { word: 'dicks', severity: 'moderate' },\n  { word: 'dickhead', severity: 'moderate' },\n  { word: 'dickheads', severity: 'moderate' },\n  { word: 'pussy', severity: 'moderate' },\n  { word: 'pussies', severity: 'moderate' },\n  { word: 'prick', severity: 'moderate' },\n  { word: 'pricks', severity: 'moderate' },\n  { word: 'slut', severity: 'moderate' },\n  { word: 'sluts', severity: 'moderate' },\n  { word: 'slutty', severity: 'moderate' },\n  { word: 'whore', severity: 'moderate' },\n  { word: 'whores', severity: 'moderate' },\n  { word: 'twat', severity: 'moderate' },\n  { word: 'twats', severity: 'moderate' },\n  { word: 'wanker', severity: 'moderate' },\n  { word: 'wankers', severity: 'moderate' },\n  { word: 'bollocks', severity: 'moderate' },\n\n  // Mild\n  { word: 'damn', severity: 'mild' },\n  { word: 'damned', severity: 'mild' },\n  { word: 'dammit', severity: 'mild' },\n  { word: 'damnit', severity: 'mild' },\n  { word: 'hell', severity: 'mild' },\n  { word: 'crap', severity: 'mild' },\n  { word: 'crappy', severity: 'mild' },\n  { word: 'piss', severity: 'mild' },\n  { word: 'pissed', severity: 'mild' },\n  { word: 'pissing', severity: 'mild' },\n  { word: 'suck', severity: 'mild' },\n  { word: 'sucks', severity: 'mild' },\n  { word: 'sucked', severity: 'mild' },\n  { word: 'balls', severity: 'mild' },\n  { word: 'butt', severity: 'mild' },\n  { word: 'butthole', severity: 'mild' },\n  { word: 'screw', severity: 'mild' },\n  { word: 'screwed', severity: 'mild' },\n  { word: 'douche', severity: 'mild' },\n  { word: 'douchebag', severity: 'mild' },\n  { word: 'douchebags', severity: 'mild' },\n];\n\n// Create a Map for O(1) lookup\nexport const PROFANITY_MAP: Map<string, SeverityLevel> = new Map(\n  PROFANITY_LIST.map((item) => [item.word.toLowerCase(), item.severity])\n);\n\n// Safe words that contain profanity substrings but are NOT profane\n// This prevents false positives like \"class\" (contains \"ass\"), \"hello\" (contains \"hell\")\nexport const SAFE_WORDS: Set<string> = new Set([\n  // Words containing \"ass\"\n  'class', 'classes', 'classic', 'classical', 'classics', 'classify', 'classified',\n  'classification', 'classmate', 'classmates', 'classroom', 'classrooms', 'classy',\n  'grass', 'grassy', 'grassland', 'grasshopper',\n  'pass', 'passed', 'passes', 'passing', 'passable', 'passage', 'passages',\n  'passenger', 'passengers', 'passport', 'passports', 'password', 'passwords',\n  'bypass', 'bypassed', 'bypasses', 'bypassing',\n  'compass', 'compasses',\n  'bass', 'bassist', 'bassline',\n  'mass', 'masses', 'massive', 'massively', 'massacre',\n  'brass', 'brassy',\n  'glass', 'glasses', 'glassy', 'glassware',\n  'sass', 'sassy', 'sassafras',\n  'lass', 'lassie', 'lasso',\n  'cassette', 'cassettes', 'casserole',\n  'assassin', 'assassins', 'assassinate', 'assassination',\n  'embassy', 'embassies', 'ambassador', 'ambassadors',\n  'harass', 'harassed', 'harassing', 'harassment',\n  'amass', 'amassed', 'amassing',\n  'morass',\n  'trespass', 'trespassed', 'trespassing', 'trespasser',\n  'carcass', 'carcasses',\n  'canvas', 'canvases', 'canvass', 'canvassed',\n  'molasses',\n  'assume', 'assumed', 'assumes', 'assuming', 'assumption', 'assumptions',\n  'assure', 'assured', 'assures', 'assuring', 'assurance',\n  'assess', 'assessed', 'assesses', 'assessing', 'assessment', 'assessments',\n  'asset', 'assets',\n  'assign', 'assigned', 'assigns', 'assigning', 'assignment', 'assignments',\n  'assist', 'assisted', 'assists', 'assisting', 'assistant', 'assistants', 'assistance',\n  'associate', 'associated', 'associates', 'associating', 'association', 'associations',\n  'assort', 'assorted', 'assortment',\n\n  // Words containing \"hell\"\n  'hello', 'hellos',\n  'shell', 'shells', 'shelled', 'shelling', 'shellfish', 'bombshell',\n  'nutshell', 'eggshell', 'seashell', 'clamshell',\n  'dwell', 'dwells', 'dwelled', 'dwelling', 'dwellings',\n  'swell', 'swells', 'swelled', 'swelling', 'swollen',\n  'well', 'wells', 'wellness', 'farewell', 'stairwell',\n  'spell', 'spells', 'spelled', 'spelling', 'misspell', 'misspelled',\n  'smell', 'smells', 'smelled', 'smelling', 'smelly',\n  'bell', 'bells', 'doorbell', 'bellhop', 'bluebell', 'dumbbell', 'barbell',\n  'cell', 'cells', 'cellular', 'cellar', 'cellars',\n  'fell', 'fella', 'fellas', 'fellow', 'fellows', 'fellowship',\n  'jell', 'jelly', 'jellyfish',\n  'tell', 'tells', 'telling', 'teller', 'storytelling', 'foretell',\n  'sell', 'sells', 'selling', 'seller', 'sellers', 'bestseller', 'bestselling',\n  'yell', 'yells', 'yelled', 'yelling',\n  'propel', 'propelled', 'propeller', 'propelling',\n  'excel', 'excels', 'excelled', 'excelling', 'excellent', 'excellence',\n  'expel', 'expels', 'expelled', 'expelling',\n  'compel', 'compels', 'compelled', 'compelling',\n  'repel', 'repels', 'repelled', 'repelling', 'repellent',\n  'rebellion', 'rebellious', 'rebel', 'rebels', 'rebelled',\n  'hellenic', 'hellenistic',\n\n  // Words containing \"damn\"\n  'goddamn', // This IS profanity, but \"adam\" is not\n  'amsterdam',\n  'macadam', 'madame', 'madam',\n\n  // Words containing \"cock\"\n  'peacock', 'peacocks',\n  'cockpit', 'cockpits',\n  'cocktail', 'cocktails',\n  'cockatoo', 'cockatoos',\n  'cockerel',\n  'hancock', 'hitchcock', 'babcock', 'woodcock',\n  'stopcock', 'weathercock',\n\n  // Words containing \"dick\"\n  'dickens',\n  'benedict', 'benediction',\n  'predict', 'predicts', 'predicted', 'predicting', 'prediction', 'predictions',\n  'addict', 'addicts', 'addicted', 'addicting', 'addiction', 'addictions', 'addictive',\n  'verdict', 'verdicts',\n  'indict', 'indicts', 'indicted', 'indicting', 'indictment',\n  'contradict', 'contradicts', 'contradicted', 'contradicting', 'contradiction',\n  'dictionary', 'dictionaries', 'diction',\n  'dictate', 'dictates', 'dictated', 'dictating', 'dictation', 'dictator',\n  'edict', 'edicts',\n  'jurisdiction',\n\n  // Words containing \"crap\"\n  'scrap', 'scraps', 'scrapped', 'scrapping', 'scrappy', 'scrapbook', 'scrapyard',\n\n  // Words containing \"piss\"\n  'mississippi',\n\n  // Words containing \"tit\"\n  'title', 'titles', 'titled', 'titling', 'subtitle', 'subtitles', 'subtitled',\n  'entitle', 'entitled', 'entitles', 'entitling', 'entitlement',\n  'constitution', 'constitutional', 'constitutions',\n  'institution', 'institutional', 'institutions',\n  'restitution',\n  'stitute', 'substitute', 'substitutes', 'substituted', 'substitution',\n  'institute', 'institutes', 'instituted', 'institution',\n  'prostitute', 'prostitutes', 'prostitution', // This might be context-dependent\n  'titan', 'titans', 'titanic',\n  'appetite', 'appetites', 'appetizer', 'appetizers',\n  'competition', 'competitions', 'competitive', 'competitor', 'competitors',\n  'petition', 'petitions', 'petitioned', 'petitioning',\n  'repetition', 'repetitions', 'repetitive',\n  'partition', 'partitions', 'partitioned',\n  'quantity', 'quantities', 'quantitative',\n  'identity', 'identities',\n  'entity', 'entities',\n  'utility', 'utilities',\n  'fertility', 'infertility',\n\n  // Words containing \"cum\"\n  'document', 'documents', 'documented', 'documenting', 'documentation', 'documentary',\n  'circumstance', 'circumstances', 'circumstantial',\n  'circumference',\n  'accumulate', 'accumulated', 'accumulates', 'accumulating', 'accumulation',\n  'cucumber', 'cucumbers',\n  'incumbent',\n  'succumb', 'succumbed', 'succumbing',\n\n  // Words containing \"fag\"\n  'faggot', // This IS profanity - keeping for reference\n\n  // Words containing \"sex\" - often legitimate\n  'sextant', 'sextet', 'sextuple',\n\n  // Words containing \"ho\" / \"hoe\"\n  'shoe', 'shoes', 'shoed', 'shoeing', 'horseshoe',\n  'hoe', 'hoes', 'hoeing', // gardening tool\n  'whole', 'wholesome', 'wholesale', 'wholly',\n  'honest', 'honestly', 'honesty', 'dishonest',\n  'honor', 'honors', 'honored', 'honoring', 'honorable', 'honorary', 'dishonor',\n  'hope', 'hopes', 'hoped', 'hoping', 'hopeful', 'hopefully', 'hopeless',\n  'home', 'homes', 'homed', 'homing', 'homeless', 'homemade', 'hometown', 'homework',\n  'horse', 'horses', 'horseback', 'horsepower',\n  'hotel', 'hotels',\n  'horizon', 'horizons', 'horizontal',\n  'hour', 'hours', 'hourly',\n  'house', 'houses', 'housed', 'housing', 'household', 'housewife', 'housekeeper',\n\n  // Words containing \"nig\"\n  'night', 'nights', 'nightly', 'nighttime', 'nightmare', 'nightmares', 'nightclub',\n  'tonight', 'overnight', 'midnight', 'goodnight', 'fortnight',\n  'knight', 'knights', 'knighthood',\n  'ignite', 'ignites', 'ignited', 'igniting', 'ignition',\n  'insignificant', 'significance', 'significant', 'significantly',\n\n  // Words containing \"nud\"\n  'nude', 'nudes', 'nudity', // Context-dependent, usually fine in art/medical context\n\n  // Words containing \"porn\"\n  // Most are actually related to pornography, so no safe words here\n\n  // Words containing \"anal\"\n  'analog', 'analogue', 'analogous', 'analogy', 'analogies',\n  'analysis', 'analyses', 'analyst', 'analysts', 'analytical', 'analyze', 'analyzed',\n  'banal',\n  'canal', 'canals',\n  'final', 'finals', 'finally', 'finalist', 'finalize', 'finalized',\n  'journal', 'journals', 'journalism', 'journalist', 'journalists',\n  'national', 'nationally', 'international', 'internationally',\n  'personal', 'personally', 'personality', 'personalities',\n  'professional', 'professionally', 'professionals',\n  'regional', 'regionally',\n  'original', 'originally', 'originals',\n  'criminal', 'criminally', 'criminals',\n  'terminal', 'terminals',\n  'cardinal', 'cardinals',\n  'signal', 'signals', 'signaled', 'signaling',\n\n  // Words containing \"nut\"\n  'minute', 'minutes', 'minutely',\n  'peanut', 'peanuts',\n  'coconut', 'coconuts',\n  'chestnut', 'chestnuts',\n  'walnut', 'walnuts',\n  'doughnut', 'doughnuts', 'donut', 'donuts',\n  'nutmeg',\n  'nutrition', 'nutritious', 'nutritional', 'nutrient', 'nutrients',\n\n  // Words containing \"god\" (for religious filter)\n  'godfather', 'godfathers', 'godmother', 'godmothers', 'godchild', 'godchildren',\n  'godson', 'godsons', 'goddaughter', 'goddaughters',\n  'godly', 'godliness', 'ungodly',\n  'goddess', 'goddesses',\n  'godspeed',\n  'godsend',\n\n  // Words containing \"lord\" (for religious filter)\n  'landlord', 'landlords', 'landlady',\n  'warlord', 'warlords',\n  'overlord', 'overlords',\n  'lordship',\n\n  // Words containing \"holy\" (for religious filter)\n  'holiday', 'holidays',\n  'wholly',\n\n  // Words containing \"christ\" (for religious filter)\n  'christen', 'christened', 'christening',\n  'christian', 'christians', 'christianity',\n  'christmas', 'christmastime',\n  'christopher',\n\n  // Words containing \"jesus\" (for religious filter)\n  // No common safe words\n\n  // Words containing \"hell\" that are already covered but adding more religious context\n  'hellfire', 'hellbound', // These ARE religious references, not safe words\n]);\n\n// Spelling variations mapping - normalizes common letter substitutions\n// Maps variant characters to their standard letter\nconst CHAR_SUBSTITUTIONS: Record<string, string> = {\n  // Common leetspeak / symbol substitutions\n  '0': 'o',\n  '1': 'i',\n  '3': 'e',\n  '4': 'a',\n  '5': 's',\n  '7': 't',\n  '8': 'b',\n  '@': 'a',\n  '$': 's',\n  '!': 'i',\n  '*': '', // Often used as censoring, remove it\n  '#': '', // Often used as censoring, remove it\n  '+': 't',\n  '(': 'c',\n  '<': 'c',\n  '|': 'i',\n  // Common letter swaps\n  'ph': 'f',\n  'ck': 'k',\n};\n\n// Multi-character substitutions (processed first)\nconst MULTI_CHAR_SUBSTITUTIONS: [string, string][] = [\n  ['ph', 'f'],\n  ['ck', 'k'],\n  ['kk', 'ck'],\n  ['cc', 'ck'],\n  ['xx', 'x'],\n];\n\n/**\n * Normalize a word by replacing common spelling variations with standard letters.\n * This helps detect words like \"f*ck\", \"sh!t\", \"a$$\", \"fvck\", etc.\n */\nexport function normalizeSpelling(text: string): string {\n  let normalized = text.toLowerCase();\n\n  // First, apply multi-character substitutions\n  for (const [from, to] of MULTI_CHAR_SUBSTITUTIONS) {\n    normalized = normalized.split(from).join(to);\n  }\n\n  // Then, apply single character substitutions\n  let result = '';\n  for (const char of normalized) {\n    result += CHAR_SUBSTITUTIONS[char] ?? char;\n  }\n\n  // Remove repeated characters that might be used to evade (e.g., \"fuuuck\" -> \"fuck\")\n  // But be careful not to break legitimate double letters\n  result = result.replace(/(.)\\1{2,}/g, '$1$1'); // Keep max 2 of same char\n\n  return result;\n}\n\n// Get all words of a specific severity\nexport function getWordsBySeverity(severity: SeverityLevel): string[] {\n  return PROFANITY_LIST\n    .filter((item) => item.severity === severity)\n    .map((item) => item.word);\n}\n\n// Check if a word is profanity (also checks normalized spelling)\nexport function isProfanity(word: string): boolean {\n  const lower = word.toLowerCase();\n  if (PROFANITY_MAP.has(lower)) return true;\n\n  // Also check normalized version for spelling variations\n  const normalized = normalizeSpelling(lower);\n  return PROFANITY_MAP.has(normalized);\n}\n\n// Get the severity of a word (also checks normalized spelling)\nexport function getSeverity(word: string): SeverityLevel | null {\n  const lower = word.toLowerCase();\n  const direct = PROFANITY_MAP.get(lower);\n  if (direct) return direct;\n\n  // Also check normalized version for spelling variations\n  const normalized = normalizeSpelling(lower);\n  return PROFANITY_MAP.get(normalized) || null;\n}\n\n// Check if a word is in the safe list (not profane despite containing profanity substring)\nexport function isSafeWord(word: string): boolean {\n  return SAFE_WORDS.has(word.toLowerCase());\n}\n\n// Find profanity within a longer word (e.g., \"fuck\" in \"motherfucker\")\n// Now checks against safe words to avoid false positives\n// Also checks normalized spellings (f*ck, sh!t, etc.)\nexport function findEmbeddedProfanity(\n  text: string\n): { word: string; severity: SeverityLevel; startIndex: number; endIndex: number }[] {\n  const lowerText = text.toLowerCase().trim();\n\n  // First, check if the entire text is a safe word - if so, return no matches\n  if (SAFE_WORDS.has(lowerText)) {\n    return [];\n  }\n\n  const results: {\n    word: string;\n    severity: SeverityLevel;\n    startIndex: number;\n    endIndex: number;\n  }[] = [];\n\n  // Check both original and normalized text\n  const normalizedText = normalizeSpelling(lowerText);\n  const textsToCheck = [lowerText];\n  if (normalizedText !== lowerText) {\n    textsToCheck.push(normalizedText);\n  }\n\n  for (const textToCheck of textsToCheck) {\n    for (const [word, severity] of PROFANITY_MAP) {\n      let index = textToCheck.indexOf(word);\n      while (index !== -1) {\n        // Check if the found substring is actually the whole word (exact match)\n        // or if it's embedded in a safe context\n        const isExactMatch = textToCheck === word;\n        const isWholeWord = (index === 0 || !/[a-z]/.test(textToCheck[index - 1])) &&\n                            (index + word.length === textToCheck.length || !/[a-z]/.test(textToCheck[index + word.length]));\n\n        // Only add if it's an exact match or a whole word within the text\n        // This prevents \"ass\" matching in \"class\" but allows \"ass\" in \"bad-ass\"\n        if (isExactMatch || isWholeWord) {\n          // Use original text indices for timing (approximate for normalized)\n          results.push({\n            word,\n            severity,\n            startIndex: index,\n            endIndex: index + word.length,\n          });\n        }\n\n        index = textToCheck.indexOf(word, index + 1);\n      }\n    }\n  }\n\n  // Sort by start index and remove duplicates (prefer longer matches)\n  results.sort((a, b) => a.startIndex - b.startIndex);\n\n  // Remove overlapping matches, keeping the longer one\n  const filtered: typeof results = [];\n  for (const match of results) {\n    const lastMatch = filtered[filtered.length - 1];\n    if (!lastMatch || match.startIndex >= lastMatch.endIndex) {\n      filtered.push(match);\n    } else if (match.endIndex - match.startIndex > lastMatch.endIndex - lastMatch.startIndex) {\n      filtered[filtered.length - 1] = match;\n    }\n  }\n\n  // Deduplicate by word (in case both original and normalized matched)\n  const seen = new Set<string>();\n  return filtered.filter(match => {\n    const key = `${match.word}-${match.startIndex}`;\n    if (seen.has(key)) return false;\n    seen.add(key);\n    return true;\n  });\n}\n","import {\n  TranscriptSegment,\n  Transcript,\n  MuteInterval,\n  UserPreferences,\n  SeverityLevel,\n  ProfanityMatch,\n} from '../types';\nimport {\n  PROFANITY_MAP,\n  findEmbeddedProfanity,\n  isSafeWord,\n} from './profanity-list';\n\nexport class TranscriptParser {\n  private preferences: UserPreferences;\n  private customBlacklistMap: Map<string, SeverityLevel>;\n  private customWhitelistSet: Set<string>;\n\n  constructor(preferences: UserPreferences) {\n    this.preferences = preferences;\n\n    // Build custom blacklist map (all custom words are severe by default)\n    this.customBlacklistMap = new Map(\n      preferences.customBlacklist.map((word) => [word.toLowerCase(), 'severe' as SeverityLevel])\n    );\n\n    // Build whitelist set\n    this.customWhitelistSet = new Set(\n      preferences.customWhitelist.map((word) => word.toLowerCase())\n    );\n  }\n\n  // Check if a severity level should be filtered based on preferences\n  private shouldFilterSeverity(severity: SeverityLevel): boolean {\n    return this.preferences.severityLevels[severity];\n  }\n\n  // Check if a word should be filtered (considering whitelist/blacklist)\n  private shouldFilterWord(word: string, severity: SeverityLevel): boolean {\n    const lowerWord = word.toLowerCase();\n\n    // Check whitelist first (user explicitly allowed)\n    if (this.customWhitelistSet.has(lowerWord)) {\n      return false;\n    }\n\n    // Check custom blacklist (always filter)\n    if (this.customBlacklistMap.has(lowerWord)) {\n      return true;\n    }\n\n    // Check severity level preference\n    return this.shouldFilterSeverity(severity);\n  }\n\n  // Get severity for a word (checking custom blacklist too)\n  private getWordSeverity(word: string): SeverityLevel | null {\n    const lowerWord = word.toLowerCase();\n\n    // Check custom blacklist first (takes priority over safe words)\n    if (this.customBlacklistMap.has(lowerWord)) {\n      return this.customBlacklistMap.get(lowerWord)!;\n    }\n\n    // Check if it's a safe word (e.g., \"class\" contains \"ass\" but is not profane)\n    if (isSafeWord(lowerWord)) {\n      return null;\n    }\n\n    // Check built-in profanity list\n    return PROFANITY_MAP.get(lowerWord) || null;\n  }\n\n  // Get precise timing using character-level data\n  private getCharacterLevelTiming(\n    segment: TranscriptSegment,\n    startIndex: number,\n    endIndex: number\n  ): { startTime: number; endTime: number } {\n    let startTime = segment.start_time;\n    let endTime = segment.end_time;\n\n    if (segment.characters && segment.characters.length > 0) {\n      // Use character-level timing for precision\n      // Find the first character of the word\n      const startChar = segment.characters[startIndex];\n      // Find the last character of the word (endIndex is exclusive, so -1)\n      const endChar = segment.characters[Math.min(endIndex - 1, segment.characters.length - 1)];\n\n      if (startChar) {\n        startTime = startChar.start;\n      }\n      if (endChar) {\n        endTime = endChar.end;\n      }\n\n      console.log(`[SafePlay Parser] Character timing: \"${segment.text.substring(startIndex, endIndex)}\" ` +\n        `chars[${startIndex}..${endIndex-1}] -> ${startTime.toFixed(3)}s - ${endTime.toFixed(3)}s`);\n    }\n\n    return { startTime, endTime };\n  }\n\n  // Find profanity matches in transcript segments\n  findProfanityMatches(segments: TranscriptSegment[]): ProfanityMatch[] {\n    const matches: ProfanityMatch[] = [];\n\n    for (let i = 0; i < segments.length; i++) {\n      const segment = segments[i];\n      const normalizedText = segment.text.toLowerCase().trim();\n\n      // Check for exact word match first\n      const exactSeverity = this.getWordSeverity(normalizedText);\n      if (exactSeverity && this.shouldFilterWord(normalizedText, exactSeverity)) {\n        // Use character-level timing for precision even on exact matches\n        const { startTime, endTime } = this.getCharacterLevelTiming(segment, 0, segment.text.length);\n\n        matches.push({\n          segmentIndex: i,\n          word: segment.text,\n          severity: exactSeverity,\n          startTime,\n          endTime,\n          isPartialMatch: false,\n        });\n        continue;\n      }\n\n      // Check for embedded profanity within longer words\n      const embeddedMatches = findEmbeddedProfanity(normalizedText);\n\n      // Also check custom blacklist for embedded matches\n      for (const [customWord] of this.customBlacklistMap) {\n        const index = normalizedText.indexOf(customWord);\n        if (index !== -1) {\n          embeddedMatches.push({\n            word: customWord,\n            severity: 'severe',\n            startIndex: index,\n            endIndex: index + customWord.length,\n          });\n        }\n      }\n\n      for (const embedded of embeddedMatches) {\n        if (!this.shouldFilterWord(embedded.word, embedded.severity)) {\n          continue;\n        }\n\n        // Use character-level timing for precision\n        const { startTime, endTime } = this.getCharacterLevelTiming(\n          segment,\n          embedded.startIndex,\n          embedded.endIndex\n        );\n\n        matches.push({\n          segmentIndex: i,\n          word: embedded.word,\n          severity: embedded.severity,\n          startTime,\n          endTime,\n          isPartialMatch: true,\n          matchedPortion: segment.text.substring(embedded.startIndex, embedded.endIndex),\n        });\n      }\n    }\n\n    return matches;\n  }\n\n  // Convert profanity matches to mute intervals with padding\n  createMuteIntervals(matches: ProfanityMatch[]): MuteInterval[] {\n    // Use asymmetric padding if available, otherwise fall back to symmetric\n    const paddingBeforeSeconds = (this.preferences.paddingBeforeMs ?? this.preferences.paddingMs) / 1000;\n    const paddingAfterSeconds = (this.preferences.paddingAfterMs ?? this.preferences.paddingMs) / 1000;\n\n    return matches.map((match) => {\n      const interval = {\n        start: Math.max(0, match.startTime - paddingBeforeSeconds),\n        end: match.endTime + paddingAfterSeconds,\n        word: match.word,\n        severity: match.severity,\n      };\n\n      console.log(`[SafePlay Parser] Mute interval: \"${match.word}\" ` +\n        `${interval.start.toFixed(3)}s - ${interval.end.toFixed(3)}s ` +\n        `(padding: -${paddingBeforeSeconds * 1000}ms / +${paddingAfterSeconds * 1000}ms)`);\n\n      return interval;\n    });\n  }\n\n  // Merge overlapping or close intervals\n  mergeIntervals(intervals: MuteInterval[]): MuteInterval[] {\n    if (intervals.length === 0) {\n      return [];\n    }\n\n    // Sort by start time\n    const sorted = [...intervals].sort((a, b) => a.start - b.start);\n    const mergeThresholdSeconds = this.preferences.mergeThresholdMs / 1000;\n\n    const merged: MuteInterval[] = [sorted[0]];\n\n    for (let i = 1; i < sorted.length; i++) {\n      const current = sorted[i];\n      const last = merged[merged.length - 1];\n\n      // Merge if overlapping or within threshold\n      if (current.start <= last.end + mergeThresholdSeconds) {\n        // Extend the end time and combine words\n        last.end = Math.max(last.end, current.end);\n        // Keep the more severe classification\n        if (this.severityRank(current.severity) > this.severityRank(last.severity)) {\n          last.severity = current.severity;\n        }\n        // Append word if different\n        if (!last.word.includes(current.word)) {\n          last.word = `${last.word}, ${current.word}`;\n        }\n      } else {\n        merged.push({ ...current });\n      }\n    }\n\n    return merged;\n  }\n\n  private severityRank(severity: SeverityLevel): number {\n    const ranks: Record<SeverityLevel, number> = {\n      mild: 1,\n      religious: 2,\n      moderate: 3,\n      severe: 4,\n    };\n    return ranks[severity];\n  }\n\n  // Main parsing function: transcript -> mute intervals\n  parse(transcript: Transcript): MuteInterval[] {\n    const matches = this.findProfanityMatches(transcript.segments);\n    const intervals = this.createMuteIntervals(matches);\n    return this.mergeIntervals(intervals);\n  }\n}\n\n// Utility function for quick parsing\nexport function parseTranscript(\n  transcript: Transcript,\n  preferences: UserPreferences\n): MuteInterval[] {\n  const parser = new TranscriptParser(preferences);\n  return parser.parse(transcript);\n}\n","// Controller for managing video filtering on watch pages\nimport { Transcript, MuteInterval, UserPreferences } from '../types';\nimport { AudioFilter } from '../filter/audio-filter';\nimport { parseTranscript } from '../filter/transcript-parser';\n\nexport type FilterStatus =\n  | 'idle'\n  | 'loading'\n  | 'processing'\n  | 'active'\n  | 'error'\n  | 'disabled';\n\nexport interface VideoControllerState {\n  status: FilterStatus;\n  progress: number;\n  error?: string;\n  intervalCount: number;\n  currentlyMuting: boolean;\n}\n\ninterface VideoControllerOptions {\n  onStateChange?: (state: VideoControllerState) => void;\n  debug?: boolean;\n}\n\nexport class VideoController {\n  private youtubeId: string | null = null;\n  private video: HTMLVideoElement | null = null;\n  private audioFilter: AudioFilter;\n  private transcript: Transcript | null = null;\n  private muteIntervals: MuteInterval[] = [];\n  private preferences: UserPreferences | null = null;\n  private status: FilterStatus = 'idle';\n  private progress = 0;\n  private error?: string;\n  private options: VideoControllerOptions;\n  private statusOverlay: HTMLElement | null = null;\n\n  constructor(options: VideoControllerOptions = {}) {\n    this.options = options;\n    this.audioFilter = new AudioFilter({\n      onMuteStart: (interval) => this.onMuteStart(interval),\n      onMuteEnd: () => this.onMuteEnd(),\n    });\n  }\n\n  // Initialize controller for a video\n  async initialize(\n    youtubeId: string,\n    preferences: UserPreferences\n  ): Promise<void> {\n    this.youtubeId = youtubeId;\n    this.preferences = preferences;\n    this.updateStatus('idle');\n\n    // Find video element\n    this.video = this.findVideoElement();\n    if (!this.video) {\n      this.log('Video element not found, waiting...');\n      await this.waitForVideo();\n    }\n\n    if (!this.video) {\n      this.updateStatus('error', 0, 'Could not find video element');\n      return;\n    }\n\n    this.log('Video controller initialized for:', youtubeId);\n  }\n\n  // Request and apply filter\n  async applyFilter(): Promise<void> {\n    if (!this.youtubeId || !this.video || !this.preferences) {\n      this.log('Cannot apply filter: missing required data');\n      return;\n    }\n\n    if (!this.preferences.enabled) {\n      this.updateStatus('disabled');\n      return;\n    }\n\n    try {\n      this.updateStatus('loading');\n\n      // Request transcript from background script\n      const response = await chrome.runtime.sendMessage({\n        type: 'GET_FILTER',\n        payload: { youtubeId: this.youtubeId },\n      });\n\n      if (!response.success) {\n        throw new Error(response.error || 'Failed to get transcript');\n      }\n\n      // If processing, we'll receive progress updates\n      if (response.data.status === 'processing') {\n        this.updateStatus('processing', response.data.progress || 0);\n        return; // Background will send completion message\n      }\n\n      // Parse transcript and create mute intervals\n      this.transcript = response.data.transcript;\n      await this.processTranscript();\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Unknown error';\n      this.updateStatus('error', 0, message);\n      this.log('Filter error:', error);\n    }\n  }\n\n  // Process transcript and start filtering\n  async processTranscript(): Promise<void> {\n    if (!this.transcript || !this.preferences || !this.video) {\n      return;\n    }\n\n    // Parse transcript for profanity\n    this.muteIntervals = parseTranscript(this.transcript, this.preferences);\n    this.log('Found', this.muteIntervals.length, 'mute intervals');\n\n    if (this.muteIntervals.length === 0) {\n      this.updateStatus('active');\n      this.log('No profanity detected in video');\n      return;\n    }\n\n    // Initialize and start audio filter\n    this.audioFilter.initialize(\n      this.video,\n      this.muteIntervals,\n      this.preferences.filterMode\n    );\n    this.audioFilter.start();\n\n    this.updateStatus('active');\n    this.showStatusOverlay();\n  }\n\n  // Handle transcript received from background\n  onTranscriptReceived(transcript: Transcript): void {\n    this.transcript = transcript;\n    this.processTranscript();\n  }\n\n  // Handle processing progress\n  onProcessingProgress(progress: number): void {\n    this.updateStatus('processing', progress);\n  }\n\n  // Handle processing error\n  onProcessingError(error: string): void {\n    this.updateStatus('error', 0, error);\n  }\n\n  // Stop filtering\n  stop(): void {\n    this.audioFilter.stop();\n    this.hideStatusOverlay();\n    this.updateStatus('idle');\n  }\n\n  // Resume filtering (re-start audio filter)\n  resume(): void {\n    if (!this.video || this.muteIntervals.length === 0) {\n      return;\n    }\n    this.audioFilter.start();\n    this.updateStatus('active');\n    this.showStatusOverlay();\n  }\n\n  // Update preferences\n  updatePreferences(preferences: UserPreferences): void {\n    this.preferences = preferences;\n\n    if (!preferences.enabled) {\n      this.stop();\n      return;\n    }\n\n    // Re-parse with new preferences\n    if (this.transcript) {\n      this.muteIntervals = parseTranscript(this.transcript, preferences);\n      this.audioFilter.updateIntervals(this.muteIntervals);\n      this.audioFilter.updateMode(preferences.filterMode);\n    }\n  }\n\n  // Get current state\n  getState(): VideoControllerState {\n    const filterState = this.audioFilter.getState();\n    return {\n      status: this.status,\n      progress: this.progress,\n      error: this.error,\n      intervalCount: filterState.intervalCount,\n      currentlyMuting: filterState.isMuted,\n    };\n  }\n\n  // Get mute intervals for caption filtering\n  getMuteIntervals(): MuteInterval[] {\n    return this.muteIntervals;\n  }\n\n  // Find the YouTube video element\n  private findVideoElement(): HTMLVideoElement | null {\n    // Main player video\n    const selectors = [\n      'video.html5-main-video',\n      'video.video-stream',\n      '#movie_player video',\n      'ytd-player video',\n      'video',\n    ];\n\n    for (const selector of selectors) {\n      const video = document.querySelector<HTMLVideoElement>(selector);\n      if (video && video.src) {\n        return video;\n      }\n    }\n\n    return null;\n  }\n\n  // Wait for video element to appear\n  private waitForVideo(timeout = 10000): Promise<HTMLVideoElement | null> {\n    return new Promise((resolve) => {\n      const startTime = Date.now();\n\n      const check = () => {\n        this.video = this.findVideoElement();\n        if (this.video) {\n          resolve(this.video);\n          return;\n        }\n\n        if (Date.now() - startTime > timeout) {\n          resolve(null);\n          return;\n        }\n\n        requestAnimationFrame(check);\n      };\n\n      check();\n    });\n  }\n\n  // Update status and notify listeners\n  private updateStatus(\n    status: FilterStatus,\n    progress = 0,\n    error?: string\n  ): void {\n    this.status = status;\n    this.progress = progress;\n    this.error = error;\n\n    if (this.options.onStateChange) {\n      this.options.onStateChange(this.getState());\n    }\n  }\n\n  // Show status overlay on video\n  private showStatusOverlay(): void {\n    if (this.statusOverlay) return;\n\n    const playerContainer = document.querySelector('#movie_player');\n    if (!playerContainer) return;\n\n    this.statusOverlay = document.createElement('div');\n    this.statusOverlay.className = 'safeplay-status-overlay';\n    this.statusOverlay.innerHTML = `\n      <div class=\"safeplay-status-badge\">\n        <svg class=\"safeplay-status-icon\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n          <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z\"/>\n        </svg>\n        <span>SafePlay Active</span>\n      </div>\n    `;\n\n    playerContainer.appendChild(this.statusOverlay);\n\n    // Auto-hide after 3 seconds\n    setTimeout(() => {\n      this.statusOverlay?.classList.add('safeplay-status-hidden');\n    }, 3000);\n  }\n\n  // Hide status overlay\n  private hideStatusOverlay(): void {\n    if (this.statusOverlay) {\n      this.statusOverlay.remove();\n      this.statusOverlay = null;\n    }\n  }\n\n  // Event handlers\n  private onMuteStart(interval: MuteInterval): void {\n    this.log('Muting:', interval.word);\n    this.notifyStateChange();\n  }\n\n  private onMuteEnd(): void {\n    this.notifyStateChange();\n  }\n\n  private notifyStateChange(): void {\n    if (this.options.onStateChange) {\n      this.options.onStateChange(this.getState());\n    }\n  }\n\n  // Debug logging\n  private log(...args: unknown[]): void {\n    if (this.options.debug) {\n      console.log('[SafePlay Controller]', ...args);\n    }\n  }\n}\n","/**\n * Smooth Progress Animator\n *\n * Creates a smooth animated progress that:\n * - Only animates toward the actual server-reported progress\n * - Never exceeds the target (no overshooting)\n * - Smoothly interpolates between server updates\n * - Stays conservative to avoid stalling at high percentages\n */\n\ntype ProgressCallback = (progress: number, text: string) => void;\n\nexport class SmoothProgressAnimator {\n  private displayProgress = 0;\n  private targetProgress = 0;\n  private isComplete = false;\n  private animationId: number | null = null;\n  private callback: ProgressCallback;\n  private baseText: string;\n\n  // Configuration - conservative settings\n  private readonly ANIMATION_INTERVAL = 100; // ms between frames\n  private readonly CATCH_UP_SPEED = 0.15; // How fast to catch up (15% of gap per frame)\n  private readonly MIN_INCREMENT = 0.2; // Minimum progress increment per frame\n  private readonly MAX_INCREMENT = 3; // Maximum progress increment per frame\n\n  constructor(callback: ProgressCallback, baseText = 'Analyzing') {\n    this.callback = callback;\n    this.baseText = baseText;\n  }\n\n  /**\n   * Start the animation\n   */\n  start(): void {\n    this.displayProgress = 0;\n    this.targetProgress = 0;\n    this.isComplete = false;\n    this.startAnimation();\n    // Initial callback\n    this.callback(0, `${this.baseText} 0%`);\n  }\n\n  /**\n   * Update the target progress from server\n   * The display will smoothly animate toward this target\n   */\n  setTarget(progress: number): void {\n    // Never let target go backwards (unless resetting)\n    this.targetProgress = Math.max(progress, this.targetProgress);\n  }\n\n  /**\n   * Mark as complete - animate to 100%\n   */\n  complete(): void {\n    this.isComplete = true;\n    this.targetProgress = 100;\n  }\n\n  /**\n   * Stop the animation\n   */\n  stop(): void {\n    if (this.animationId !== null) {\n      clearInterval(this.animationId);\n      this.animationId = null;\n    }\n  }\n\n  /**\n   * Get current display progress\n   */\n  getProgress(): number {\n    return this.displayProgress;\n  }\n\n  private startAnimation(): void {\n    if (this.animationId !== null) return;\n\n    this.animationId = window.setInterval(() => {\n      this.tick();\n    }, this.ANIMATION_INTERVAL);\n  }\n\n  private tick(): void {\n    const gap = this.targetProgress - this.displayProgress;\n\n    // Only animate if we're behind the target\n    if (gap > 0.5) {\n      // Calculate increment - proportional to gap but clamped\n      let increment = gap * this.CATCH_UP_SPEED;\n      increment = Math.max(increment, this.MIN_INCREMENT);\n      increment = Math.min(increment, this.MAX_INCREMENT);\n\n      // Apply increment but never exceed target\n      this.displayProgress = Math.min(\n        this.displayProgress + increment,\n        this.targetProgress\n      );\n\n      // Round for display\n      const displayValue = Math.round(this.displayProgress);\n      this.callback(displayValue, `${this.baseText} ${displayValue}%`);\n    }\n\n    // Stop animation when complete and reached 100%\n    if (this.isComplete && this.displayProgress >= 99.5) {\n      this.displayProgress = 100;\n      this.callback(100, `${this.baseText} 100%`);\n      this.stop();\n    }\n  }\n}\n","// SafePlay Caption Filter - Real-time caption text censoring\nimport { UserPreferences, MuteInterval, SeverityLevel } from '../types';\nimport { findEmbeddedProfanity, isSafeWord } from '../filter/profanity-list';\n\nconst DEBUG = true;\n\nfunction log(...args: unknown[]): void {\n  if (DEBUG) {\n    console.log('[SafePlay:Captions]', ...args);\n  }\n}\n\nexport interface CaptionFilterOptions {\n  debug?: boolean;\n}\n\nexport class CaptionFilter {\n  private observer: MutationObserver | null = null;\n  private preferences: UserPreferences | null = null;\n  private isActive = false;\n  private censoredWordCount = 0;\n\n  // YouTube caption selectors (they change occasionally, so we try multiple)\n  private readonly CAPTION_SELECTORS = [\n    '.ytp-caption-segment',           // Individual caption segments\n    '.captions-text',                  // Alternative caption text\n    '.ytp-caption-window-container',   // Caption window\n    '.caption-window',                 // Another variant\n    '.ytp-caption-window-bottom',      // Bottom caption window\n  ];\n\n  constructor(_options: CaptionFilterOptions = {}) {\n    // Options for future use\n  }\n\n  /**\n   * Initialize the caption filter with user preferences and mute intervals\n   */\n  initialize(preferences: UserPreferences, _muteIntervals: MuteInterval[]): void {\n    this.preferences = preferences;\n    log('Caption filter initialized');\n  }\n\n  /**\n   * Start watching and filtering captions\n   */\n  start(): void {\n    if (this.isActive) {\n      log('Caption filter already active');\n      return;\n    }\n\n    log('Starting caption filter');\n    this.isActive = true;\n    this.censoredWordCount = 0;\n\n    // Set up mutation observer to watch for caption changes\n    this.setupObserver();\n\n    // Also do an initial scan of any existing captions\n    this.scanExistingCaptions();\n  }\n\n  /**\n   * Stop watching captions\n   */\n  stop(): void {\n    if (!this.isActive) return;\n\n    log('Stopping caption filter. Censored', this.censoredWordCount, 'words total.');\n    this.isActive = false;\n\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = null;\n    }\n  }\n\n  /**\n   * Update preferences (e.g., when user changes severity levels)\n   */\n  updatePreferences(preferences: UserPreferences): void {\n    this.preferences = preferences;\n  }\n\n  /**\n   * Get the count of censored words\n   */\n  getCensoredCount(): number {\n    return this.censoredWordCount;\n  }\n\n  /**\n   * Set up MutationObserver to watch for caption text changes\n   */\n  private setupObserver(): void {\n    // Find the player container to observe\n    const playerContainer = document.querySelector('#movie_player') ||\n                           document.querySelector('.html5-video-player') ||\n                           document.querySelector('ytd-player');\n\n    if (!playerContainer) {\n      log('Player container not found, retrying in 500ms');\n      setTimeout(() => this.setupObserver(), 500);\n      return;\n    }\n\n    // Create observer that watches for caption changes\n    this.observer = new MutationObserver((mutations) => {\n      this.handleMutations(mutations);\n    });\n\n    // Observe the player for any DOM changes (captions are dynamically added)\n    this.observer.observe(playerContainer, {\n      childList: true,\n      subtree: true,\n      characterData: true,\n      characterDataOldValue: true,\n    });\n\n    log('Caption observer set up on player container');\n  }\n\n  /**\n   * Handle DOM mutations - look for caption text changes\n   */\n  private handleMutations(mutations: MutationRecord[]): void {\n    if (!this.isActive) return;\n\n    for (const mutation of mutations) {\n      // Handle text content changes\n      if (mutation.type === 'characterData' && mutation.target.parentElement) {\n        const parent = mutation.target.parentElement;\n        if (this.isCaptionElement(parent)) {\n          this.filterCaptionElement(parent);\n        }\n      }\n\n      // Handle new nodes being added (new caption segments)\n      if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {\n        mutation.addedNodes.forEach((node) => {\n          if (node instanceof Element) {\n            // Check if this is a caption element\n            if (this.isCaptionElement(node)) {\n              this.filterCaptionElement(node);\n            }\n            // Also check children\n            const captionElements = this.findCaptionElements(node);\n            captionElements.forEach((el) => this.filterCaptionElement(el));\n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * Check if an element is a caption element\n   */\n  private isCaptionElement(element: Element): boolean {\n    for (const selector of this.CAPTION_SELECTORS) {\n      if (element.matches(selector) || element.closest(selector)) {\n        return true;\n      }\n    }\n    // Also check class names that might indicate caption content\n    const className = element.className || '';\n    return className.includes('caption') || className.includes('ytp-caption');\n  }\n\n  /**\n   * Find caption elements within a container\n   */\n  private findCaptionElements(container: Element): Element[] {\n    const elements: Element[] = [];\n    for (const selector of this.CAPTION_SELECTORS) {\n      const found = container.querySelectorAll(selector);\n      found.forEach((el) => elements.push(el));\n    }\n    return elements;\n  }\n\n  /**\n   * Scan for existing captions on the page\n   */\n  private scanExistingCaptions(): void {\n    for (const selector of this.CAPTION_SELECTORS) {\n      const elements = document.querySelectorAll(selector);\n      elements.forEach((el) => this.filterCaptionElement(el));\n    }\n  }\n\n  /**\n   * Filter profanity from a caption element\n   */\n  private filterCaptionElement(element: Element): void {\n    if (!this.preferences) return;\n\n    const originalText = element.textContent || '';\n    if (!originalText.trim()) return;\n\n    // Check if already processed\n    if (element.getAttribute('data-safeplay-filtered') === 'true') {\n      return;\n    }\n\n    const filteredText = this.censorText(originalText);\n\n    if (filteredText !== originalText) {\n      // Text was modified, update the element\n      element.textContent = filteredText;\n      element.setAttribute('data-safeplay-filtered', 'true');\n      log('Censored caption:', originalText, '->', filteredText);\n    }\n  }\n\n  /**\n   * Censor profanity in text\n   */\n  private censorText(text: string): string {\n    if (!this.preferences) return text;\n\n    // Check against safe words first\n    const words = text.split(/(\\s+)/); // Split keeping whitespace\n    let result = '';\n\n    for (const word of words) {\n      if (/^\\s+$/.test(word)) {\n        // It's whitespace, keep it\n        result += word;\n        continue;\n      }\n\n      // Strip punctuation for checking but preserve for output\n      const punctuationMatch = word.match(/^([^a-zA-Z]*)(.+?)([^a-zA-Z]*)$/);\n      if (!punctuationMatch) {\n        result += word;\n        continue;\n      }\n\n      const [, leadingPunct, coreWord, trailingPunct] = punctuationMatch;\n\n      // Check if it's a safe word\n      if (isSafeWord(coreWord)) {\n        result += word;\n        continue;\n      }\n\n      // Check for profanity\n      const profanityMatches = findEmbeddedProfanity(coreWord);\n\n      if (profanityMatches.length > 0) {\n        // Filter by enabled severity levels\n        const enabledMatches = profanityMatches.filter((match) => {\n          const severity = match.severity as SeverityLevel;\n          return this.preferences!.severityLevels[severity];\n        });\n\n        if (enabledMatches.length > 0) {\n          // Censor the word - replace with (bleep)\n          result += leadingPunct + '(bleep)' + trailingPunct;\n          this.censoredWordCount += enabledMatches.length;\n        } else {\n          result += word;\n        }\n      } else {\n        // Also check custom blacklist\n        if (this.preferences.customBlacklist.some(\n          (banned) => coreWord.toLowerCase() === banned.toLowerCase()\n        )) {\n          result += leadingPunct + '(bleep)' + trailingPunct;\n          this.censoredWordCount++;\n        } else {\n          result += word;\n        }\n      }\n    }\n\n    return result;\n  }\n}\n","// API Response Types\n\nexport interface CharacterTiming {\n  char: string;\n  start: number;\n  end: number;\n}\n\nexport interface TranscriptSegment {\n  text: string;\n  start_time: number;\n  end_time: number;\n  characters: CharacterTiming[];\n}\n\nexport interface Transcript {\n  id: string;\n  youtube_id?: string; // May be set from context\n  full_text?: string;\n  segments: TranscriptSegment[];\n  duration?: number;\n  language?: string;\n  created_at?: string;\n}\n\nexport interface FilterResponse {\n  status: 'completed' | 'processing';\n  cached?: boolean;\n  transcript?: Transcript;\n  job_id?: string;\n  message?: string;\n}\n\nexport interface JobStatusResponse {\n  status: 'pending' | 'downloading' | 'transcribing' | 'completed' | 'failed';\n  progress: number;\n  transcript?: Transcript;\n  error?: string;\n  video?: {\n    youtube_id: string;\n    title?: string;\n  };\n}\n\n// Button state for UX\nexport type ButtonState =\n  | 'idle'\n  | 'connecting'\n  | 'downloading'\n  | 'transcribing'\n  | 'processing'\n  | 'filtering'\n  | 'error';\n\nexport interface ButtonStateInfo {\n  state: ButtonState;\n  text: string;\n  progress?: number;\n  intervalCount?: number;\n  error?: string;\n}\n\n// Profanity Types\n\nexport type SeverityLevel = 'mild' | 'moderate' | 'severe' | 'religious';\n\nexport interface ProfanityWord {\n  word: string;\n  severity: SeverityLevel;\n}\n\nexport interface MuteInterval {\n  start: number;\n  end: number;\n  word: string;\n  severity: SeverityLevel;\n}\n\nexport interface ProfanityMatch {\n  segmentIndex: number;\n  word: string;\n  severity: SeverityLevel;\n  startTime: number;\n  endTime: number;\n  isPartialMatch: boolean;\n  matchedPortion?: string;\n}\n\n// User Preferences\n\nexport type FilterMode = 'mute' | 'bleep';\n\nexport interface UserPreferences {\n  enabled: boolean;\n  filterMode: FilterMode;\n  severityLevels: {\n    mild: boolean;\n    moderate: boolean;\n    severe: boolean;\n    religious: boolean;\n  };\n  customBlacklist: string[];\n  customWhitelist: string[];\n  paddingMs: number; // Legacy/fallback symmetric padding\n  paddingBeforeMs?: number; // Padding before word starts (catches attack)\n  paddingAfterMs?: number; // Padding after word ends (catches release)\n  mergeThresholdMs: number;\n}\n\nexport const DEFAULT_PREFERENCES: UserPreferences = {\n  enabled: true,\n  filterMode: 'mute',\n  severityLevels: {\n    mild: false,\n    moderate: true,\n    severe: true,\n    religious: false, // Off by default - user opt-in\n  },\n  customBlacklist: [],\n  customWhitelist: [],\n  paddingMs: 50, // Legacy/fallback symmetric padding\n  paddingBeforeMs: 100, // Padding before word - smooth fade adds ~130ms effective lead time\n  paddingAfterMs: 30, // Padding after word ends\n  mergeThresholdMs: 100,\n};\n\n// Storage Types\n\nexport interface StorageData {\n  preferences: UserPreferences;\n  authToken?: string;\n  userId?: string;\n  subscriptionTier?: 'free' | 'basic' | 'professional' | 'unlimited';\n  cachedTranscripts: Record<string, Transcript>;\n}\n\n// Message Types (between content script and background)\n\nexport type MessageType =\n  | 'GET_FILTER'\n  | 'CHECK_JOB'\n  | 'GET_PREFERENCES'\n  | 'SET_PREFERENCES'\n  | 'GET_AUTH_STATUS'\n  | 'CLEAR_CACHE';\n\nexport interface Message<T = unknown> {\n  type: MessageType;\n  payload?: T;\n}\n\nexport interface MessageResponse<T = unknown> {\n  success: boolean;\n  data?: T;\n  error?: string;\n}\n","// SafePlay Content Script - Main Entry Point\nimport { ResilientInjector } from './resilient-injector';\nimport { VideoController } from './video-controller';\nimport { SmoothProgressAnimator } from './smooth-progress';\nimport { CaptionFilter } from './caption-filter';\nimport { UserPreferences, DEFAULT_PREFERENCES, Transcript, ButtonStateInfo } from '../types';\nimport './styles.css';\n\nconst DEBUG = true;\n\nfunction log(...args: unknown[]): void {\n  if (DEBUG) {\n    console.log('[SafePlay]', ...args);\n  }\n}\n\nclass SafePlayContentScript {\n  private injector: ResilientInjector;\n  private videoController: VideoController | null = null;\n  private captionFilter: CaptionFilter;\n  private preferences: UserPreferences = DEFAULT_PREFERENCES;\n  private currentVideoId: string | null = null;\n  private isProcessing = false;\n  private videoWasPlaying = false; // Track if video was playing before we paused it\n  private progressAnimator: SmoothProgressAnimator | null = null;\n\n  constructor() {\n    // Initialize resilient injector for video watch page\n    this.injector = new ResilientInjector({\n      onButtonClick: (youtubeId) => this.onFilterButtonClick(youtubeId),\n      debug: DEBUG,\n    });\n\n    // Initialize video controller\n    this.videoController = new VideoController({\n      onStateChange: (state) => this.onVideoStateChange(state),\n      debug: DEBUG,\n    });\n\n    // Initialize caption filter\n    this.captionFilter = new CaptionFilter({ debug: DEBUG });\n  }\n\n  async initialize(): Promise<void> {\n    log('Initializing SafePlay content script');\n\n    // Load user preferences\n    await this.loadPreferences();\n\n    // Start injector - it handles watch page detection internally\n    this.injector.start();\n\n    // Check if we're on a watch page\n    if (this.isWatchPage()) {\n      this.currentVideoId = this.getVideoIdFromUrl();\n    }\n\n    // Listen for messages from background/popup\n    this.setupMessageListener();\n\n    // Listen for URL changes (YouTube SPA)\n    this.setupNavigationListener();\n\n    log('SafePlay initialized');\n  }\n\n  private async loadPreferences(): Promise<void> {\n    try {\n      const response = await chrome.runtime.sendMessage({\n        type: 'GET_PREFERENCES',\n      });\n\n      if (response.success && response.data) {\n        this.preferences = response.data;\n      }\n    } catch (error) {\n      log('Failed to load preferences:', error);\n    }\n  }\n\n  private isWatchPage(): boolean {\n    return window.location.pathname === '/watch';\n  }\n\n  private getVideoIdFromUrl(): string | null {\n    const params = new URLSearchParams(window.location.search);\n    return params.get('v');\n  }\n\n  private updateButtonState(stateInfo: ButtonStateInfo): void {\n    this.injector.updateButtonState(stateInfo);\n  }\n\n  // Get the video element\n  private getVideoElement(): HTMLVideoElement | null {\n    return document.querySelector('video.html5-main-video') ||\n           document.querySelector('video.video-stream') ||\n           document.querySelector('#movie_player video') ||\n           document.querySelector('video');\n  }\n\n  // Main filter flow - called when SafePlay button is clicked\n  private async onFilterButtonClick(youtubeId: string): Promise<void> {\n    if (this.isProcessing) {\n      log('Already processing, ignoring click');\n      return;\n    }\n\n    log('Filter button clicked for:', youtubeId);\n    this.isProcessing = true;\n    this.currentVideoId = youtubeId;\n\n    // Pause video while we load the filter to prevent hearing profanity\n    const video = this.getVideoElement();\n    this.videoWasPlaying = !!(video && !video.paused);\n    if (video && this.videoWasPlaying) {\n      video.pause();\n      log('Video paused while loading filter');\n    }\n\n    try {\n      // Step 1: Connecting\n      this.updateButtonState({ state: 'connecting', text: 'Connecting...' });\n\n      // Request filter from background script (which calls the API)\n      const response = await chrome.runtime.sendMessage({\n        type: 'GET_FILTER',\n        payload: { youtubeId },\n      });\n\n      if (!response.success) {\n        throw new Error(response.error || 'Failed to request filter');\n      }\n\n      const { status, transcript, jobId } = response.data;\n\n      if ((status === 'cached' || status === 'completed') && transcript) {\n        // Transcript was cached (locally or on server), skip to processing\n        log('Using cached transcript');\n        this.updateButtonState({ state: 'processing', text: 'Processing...' });\n        await this.applyFilter(transcript);\n      } else if (status === 'processing' && jobId) {\n        // Need to poll for job completion\n        log('Job started, polling for completion:', jobId);\n        await this.pollJobStatus(jobId);\n      } else {\n        throw new Error('Unexpected API response');\n      }\n    } catch (error) {\n      log('Filter request failed:', error);\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      this.updateButtonState({\n        state: 'error',\n        text: 'Error',\n        error: errorMessage,\n      });\n      // Resume video on error\n      if (this.videoWasPlaying) {\n        const video = this.getVideoElement();\n        if (video) {\n          video.play();\n          log('Video resumed after error');\n        }\n        this.videoWasPlaying = false;\n      }\n      this.isProcessing = false;\n    }\n  }\n\n  // Poll for job status with progress updates\n  private async pollJobStatus(jobId: string): Promise<void> {\n    const maxAttempts = 180; // 6 minutes max (2s intervals)\n    const pollInterval = 2000;\n    let attempts = 0;\n\n    // Initialize smooth progress animator\n    this.progressAnimator = new SmoothProgressAnimator(\n      (progress, text) => {\n        this.updateButtonState({\n          state: 'processing',\n          text,\n          progress,\n        });\n      },\n      'Analyzing'\n    );\n    this.progressAnimator.start();\n\n    while (attempts < maxAttempts) {\n      try {\n        const response = await chrome.runtime.sendMessage({\n          type: 'CHECK_JOB',\n          payload: { jobId },\n        });\n\n        if (!response.success) {\n          throw new Error(response.error || 'Failed to check job status');\n        }\n\n        const { status, progress, transcript, error } = response.data;\n\n        log(`Job status: ${status}, progress: ${progress}%`);\n\n        // Calculate actual progress and update animator target\n        switch (status) {\n          case 'pending':\n            this.progressAnimator.setTarget(5);\n            break;\n\n          case 'downloading':\n            // Scale downloading: 0-100% server progress -> 5-30% display\n            this.progressAnimator.setTarget(5 + progress * 0.25);\n            break;\n\n          case 'transcribing':\n            // Scale transcribing: 0-100% server progress -> 30-85% display\n            this.progressAnimator.setTarget(30 + progress * 0.55);\n            break;\n\n          case 'completed':\n            if (transcript) {\n              // Signal completion - animator will smoothly reach 100%\n              this.progressAnimator.setTarget(95);\n              // Give a moment for progress to animate up\n              await new Promise((resolve) => setTimeout(resolve, 300));\n              this.progressAnimator.complete();\n              // Wait for animation to finish\n              await new Promise((resolve) => setTimeout(resolve, 500));\n              this.progressAnimator.stop();\n              this.progressAnimator = null;\n              await this.applyFilter(transcript);\n              return;\n            } else {\n              throw new Error('Job completed but no transcript returned');\n            }\n\n          case 'failed':\n            throw new Error(error || 'Processing failed');\n\n          default:\n            // Generic processing state\n            this.progressAnimator.setTarget(progress);\n        }\n\n        // Wait before next poll\n        await new Promise((resolve) => setTimeout(resolve, pollInterval));\n        attempts++;\n      } catch (error) {\n        log('Poll error:', error);\n        // Stop animator on error\n        if (this.progressAnimator) {\n          this.progressAnimator.stop();\n          this.progressAnimator = null;\n        }\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        this.updateButtonState({\n          state: 'error',\n          text: 'Error',\n          error: errorMessage,\n        });\n        this.isProcessing = false;\n        return;\n      }\n    }\n\n    // Timeout - stop animator\n    if (this.progressAnimator) {\n      this.progressAnimator.stop();\n      this.progressAnimator = null;\n    }\n    this.updateButtonState({\n      state: 'error',\n      text: 'Timeout',\n      error: 'Processing took too long. Please try again.',\n    });\n    this.isProcessing = false;\n  }\n\n  // Apply the filter using the transcript\n  private async applyFilter(transcript: Transcript): Promise<void> {\n    if (!this.videoController) {\n      throw new Error('Video controller not initialized');\n    }\n\n    const videoId = this.currentVideoId;\n    if (!videoId) {\n      throw new Error('No video ID');\n    }\n\n    // Log transcript structure to verify character-level data\n    log('Transcript received for filtering:', {\n      id: transcript.id,\n      segmentCount: transcript.segments?.length,\n      sampleSegment: transcript.segments?.[0] ? {\n        text: transcript.segments[0].text,\n        times: `${transcript.segments[0].start_time}s - ${transcript.segments[0].end_time}s`,\n        hasCharacters: !!transcript.segments[0].characters,\n        charCount: transcript.segments[0].characters?.length,\n        sampleChars: transcript.segments[0].characters?.slice(0, 3),\n      } : null,\n    });\n\n    try {\n      // Initialize video controller with transcript\n      await this.videoController.initialize(videoId, this.preferences);\n      this.videoController.onTranscriptReceived(transcript);\n\n      // Apply the filter\n      await this.videoController.applyFilter();\n\n      // Get the interval count and mute intervals for display\n      const state = this.videoController.getState();\n      const intervalCount = state.intervalCount || 0;\n      const muteIntervals = this.videoController.getMuteIntervals();\n\n      // Start caption filtering as well\n      this.captionFilter.initialize(this.preferences, muteIntervals);\n      this.captionFilter.start();\n      log('Caption filter started');\n\n      // Update button to filtering state\n      this.updateButtonState({\n        state: 'filtering',\n        text: `Filtering (${intervalCount})`,\n        intervalCount,\n      });\n\n      log(`Filter applied successfully. ${intervalCount} profanity instances will be muted.`);\n\n      // Resume video if it was playing before\n      if (this.videoWasPlaying) {\n        const video = this.getVideoElement();\n        if (video) {\n          video.play();\n          log('Video resumed after filter applied');\n        }\n        this.videoWasPlaying = false;\n      }\n\n      // Create player controls for toggling\n      this.injectPlayerControls();\n    } catch (error) {\n      log('Failed to apply filter:', error);\n      // Resume video even on error\n      if (this.videoWasPlaying) {\n        const video = this.getVideoElement();\n        if (video) {\n          video.play();\n          log('Video resumed after filter error');\n        }\n        this.videoWasPlaying = false;\n      }\n      throw error;\n    } finally {\n      this.isProcessing = false;\n    }\n  }\n\n  private injectPlayerControls(): void {\n    // Check if already injected\n    if (document.querySelector('.safeplay-player-controls')) return;\n\n    // Wait for player controls to be available\n    const waitForControls = () => {\n      const rightControls = document.querySelector('.ytp-right-controls');\n      if (rightControls) {\n        this.createPlayerButton(rightControls);\n      } else {\n        setTimeout(waitForControls, 500);\n      }\n    };\n\n    waitForControls();\n  }\n\n  private createPlayerButton(container: Element): void {\n    const button = document.createElement('button');\n    button.className = 'ytp-button safeplay-player-controls safeplay-active';\n    button.title = 'SafePlay Filter Active - Click to toggle';\n    button.innerHTML = `\n      <svg viewBox=\"0 0 24 24\" fill=\"currentColor\" width=\"24\" height=\"24\">\n        <path d=\"M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm-2 16l-4-4 1.41-1.41L10 14.17l6.59-6.59L18 9l-8 8z\"/>\n      </svg>\n    `;\n\n    button.addEventListener('click', () => this.toggleFilter());\n\n    // Insert before settings button (if it's a direct child)\n    const settingsButton = container.querySelector('.ytp-settings-button');\n    if (settingsButton && settingsButton.parentElement === container) {\n      container.insertBefore(button, settingsButton);\n    } else {\n      // Just prepend to the container\n      container.insertBefore(button, container.firstChild);\n    }\n  }\n\n  private async toggleFilter(): Promise<void> {\n    if (!this.videoController) return;\n\n    const state = this.videoController.getState();\n    const playerButton = document.querySelector('.safeplay-player-controls');\n\n    if (state.status === 'active') {\n      this.videoController.stop();\n      this.captionFilter.stop();\n      playerButton?.classList.remove('safeplay-active');\n      playerButton?.setAttribute('title', 'SafePlay Filter Paused - Click to resume');\n      this.updateButtonState({ state: 'idle', text: 'SafePlay' });\n    } else if (this.currentVideoId) {\n      // Resume filtering\n      this.videoController.resume();\n      this.captionFilter.start();\n      playerButton?.classList.add('safeplay-active');\n      playerButton?.setAttribute('title', 'SafePlay Filter Active - Click to toggle');\n\n      const intervalCount = state.intervalCount || 0;\n      this.updateButtonState({\n        state: 'filtering',\n        text: `Filtering (${intervalCount})`,\n        intervalCount,\n      });\n    }\n  }\n\n  private onVideoStateChange(state: ReturnType<VideoController['getState']>): void {\n    log('Video state changed:', state);\n\n    // Notify popup of state change\n    chrome.runtime.sendMessage({\n      type: 'VIDEO_STATE_CHANGED',\n      payload: state,\n    }).catch(() => {\n      // Popup might not be open\n    });\n  }\n\n  private setupMessageListener(): void {\n    chrome.runtime.onMessage.addListener((message, _sender, sendResponse) => {\n      this.handleMessage(message).then(sendResponse);\n      return true; // Keep channel open for async response\n    });\n  }\n\n  private async handleMessage(message: { type: string; payload?: unknown }): Promise<unknown> {\n    switch (message.type) {\n      case 'PREFERENCES_UPDATED': {\n        const newPrefs = message.payload as UserPreferences;\n        this.preferences = newPrefs;\n        this.videoController?.updatePreferences(newPrefs);\n        this.captionFilter.updatePreferences(newPrefs);\n        return { success: true };\n      }\n\n      case 'GET_VIDEO_STATE': {\n        return {\n          success: true,\n          data: this.videoController?.getState() || null,\n        };\n      }\n\n      default:\n        return { success: false, error: 'Unknown message type' };\n    }\n  }\n\n  private setupNavigationListener(): void {\n    // YouTube SPA navigation\n    document.addEventListener('yt-navigate-finish', () => {\n      log('YouTube navigation detected');\n      this.onNavigation();\n    });\n\n    // Fallback: popstate\n    window.addEventListener('popstate', () => {\n      this.onNavigation();\n    });\n  }\n\n  private onNavigation(): void {\n    // Stop current filter if any\n    if (this.videoController) {\n      this.videoController.stop();\n    }\n\n    // Stop caption filter\n    this.captionFilter.stop();\n\n    // Reset state\n    this.currentVideoId = null;\n    this.isProcessing = false;\n\n    // Remove player button\n    const playerButton = document.querySelector('.safeplay-player-controls');\n    if (playerButton) {\n      playerButton.remove();\n    }\n\n    // Update video ID if on watch page\n    if (this.isWatchPage()) {\n      this.currentVideoId = this.getVideoIdFromUrl();\n    }\n  }\n}\n\n// Initialize when DOM is ready\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', () => {\n    const safeplay = new SafePlayContentScript();\n    safeplay.initialize();\n  });\n} else {\n  const safeplay = new SafePlayContentScript();\n  safeplay.initialize();\n}\n"],"names":["BUTTON_CONTAINER_CLASS","BUTTON_STATES","idle","bg","hoverBg","text","shadow","connecting","downloading","transcribing","processing","filtering","error","ResilientInjector","constructor","options","observer","currentVideoId","injectionAttempts","maxAttempts","retryInterval","currentState","this","start","log","attemptInjection","setupMutationObserver","setupNavigationListener","stop","disconnect","clearInterval","isWatchPage","window","location","pathname","search","includes","getVideoId","URLSearchParams","get","videoId","isButtonPresent","subscribeButton","findSubscribeButton","injectButton","setInterval","selectors","selector","element","document","querySelector","existingButton","remove","container","createElement","className","style","cssText","setAttribute","button","title","stateConfig","progressBar","iconWrapper","innerHTML","getIconSVG","textSpan","textContent","appendChild","addEventListener","config","background","boxShadow","transform","e","preventDefault","stopPropagation","onButtonClick","parentElement","insertBefore","nextSibling","state","updateButtonState","stateInfo","displayText","undefined","progress","replace","Math","round","intervalCount","width","display","cursor","setButtonState","MutationObserver","mutations","mutation","type","addedNodes","length","node","HTMLElement","id","closest","observe","body","childList","subtree","originalPushState","history","pushState","originalReplaceState","replaceState","args","apply","onNavigation","setTimeout","getCurrentVideoId","debug","console","FADE_BUFFER","AudioFilter","video","muteIntervals","filterMode","isActive","checkIntervalId","isMuted","isFading","audioContext","sourceNode","gainNode","bleepOscillator","bleepGain","currentGainTarget","BLEEP_FREQUENCY","BLEEP_VOLUME","BLEEP_ATTACK","BLEEP_RELEASE","onMuteStart","onMuteEnd","initialize","intervals","mode","sort","a","b","initializeAudioContext","AudioContext","createMediaElementSource","createGain","gain","value","connect","destination","resume","checkCurrentTime","fadeToVolume","destroy","close","currentTime","activeInterval","findActiveInterval","approachingInterval","findApproachingInterval","startMute","startFadeOut","endMute","time","interval","end","startBleep","stopBleep","target","onComplete","now","cancelScheduledValues","setValueAtTime","linearRampToValueAtTime","FADE_DURATION","muted","createOscillator","frequency","oscillator2","mixer","_secondOscillator","_mixer","oscillator","updateIntervals","updateMode","getState","isFiltering","getIntervals","PROFANITY_MAP","Map","word","severity","map","item","toLowerCase","SAFE_WORDS","Set","CHAR_SUBSTITUTIONS","MULTI_CHAR_SUBSTITUTIONS","isSafeWord","has","findEmbeddedProfanity","lowerText","trim","results","normalizedText","normalized","from","to","split","join","result","char","normalizeSpelling","textsToCheck","push","textToCheck","index","indexOf","isExactMatch","isWholeWord","test","startIndex","endIndex","filtered","match","lastMatch","seen","filter","key","add","TranscriptParser","preferences","customBlacklistMap","customBlacklist","customWhitelistSet","customWhitelist","shouldFilterSeverity","severityLevels","shouldFilterWord","lowerWord","getWordSeverity","getCharacterLevelTiming","segment","startTime","start_time","endTime","end_time","characters","startChar","endChar","min","substring","toFixed","findProfanityMatches","segments","matches","i","exactSeverity","segmentIndex","isPartialMatch","embeddedMatches","customWord","embedded","matchedPortion","createMuteIntervals","paddingBeforeSeconds","paddingBeforeMs","paddingMs","paddingAfterSeconds","paddingAfterMs","max","mergeIntervals","sorted","mergeThresholdSeconds","mergeThresholdMs","merged","current","last","severityRank","mild","religious","moderate","severe","parse","transcript","parseTranscript","VideoController","youtubeId","status","statusOverlay","audioFilter","updateStatus","findVideoElement","waitForVideo","applyFilter","enabled","response","chrome","runtime","sendMessage","payload","success","Error","data","processTranscript","message","showStatusOverlay","onTranscriptReceived","onProcessingProgress","onProcessingError","hideStatusOverlay","updatePreferences","filterState","currentlyMuting","getMuteIntervals","src","timeout","Promise","resolve","Date","check","requestAnimationFrame","onStateChange","playerContainer","classList","notifyStateChange","SmoothProgressAnimator","callback","baseText","displayProgress","targetProgress","isComplete","animationId","ANIMATION_INTERVAL","CATCH_UP_SPEED","MIN_INCREMENT","MAX_INCREMENT","startAnimation","setTarget","complete","getProgress","tick","gap","increment","displayValue","CaptionFilter","_options","censoredWordCount","CAPTION_SELECTORS","_muteIntervals","setupObserver","scanExistingCaptions","getCensoredCount","handleMutations","characterData","characterDataOldValue","parent","isCaptionElement","filterCaptionElement","forEach","Element","findCaptionElements","el","elements","querySelectorAll","originalText","getAttribute","filteredText","censorText","words","punctuationMatch","leadingPunct","coreWord","trailingPunct","profanityMatches","enabledMatches","some","banned","DEFAULT_PREFERENCES","SafePlayContentScript","videoController","isProcessing","videoWasPlaying","progressAnimator","injector","onFilterButtonClick","onVideoStateChange","captionFilter","loadPreferences","getVideoIdFromUrl","setupMessageListener","getVideoElement","paused","pause","jobId","pollJobStatus","errorMessage","play","attempts","segmentCount","sampleSegment","times","hasCharacters","charCount","sampleChars","slice","injectPlayerControls","waitForControls","rightControls","createPlayerButton","toggleFilter","settingsButton","firstChild","playerButton","catch","onMessage","addListener","_sender","sendResponse","handleMessage","then","newPrefs","readyState"],"ignoreList":[],"sourceRoot":""}