{"version":3,"file":"content.js","mappings":"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","sources":["webpack://safeplay-chrome-extension/./src/content/resilient-injector.ts","webpack://safeplay-chrome-extension/./src/filter/audio-filter.ts","webpack://safeplay-chrome-extension/./src/filter/profanity-list.ts","webpack://safeplay-chrome-extension/./src/filter/transcript-parser.ts","webpack://safeplay-chrome-extension/./src/content/video-controller.ts","webpack://safeplay-chrome-extension/./src/content/smooth-progress.ts","webpack://safeplay-chrome-extension/./src/content/caption-filter.ts","webpack://safeplay-chrome-extension/./src/content/timeline-markers.ts","webpack://safeplay-chrome-extension/./src/content/credit-confirmation.ts","webpack://safeplay-chrome-extension/./src/types/index.ts","webpack://safeplay-chrome-extension/./src/utils/storage.ts","webpack://safeplay-chrome-extension/./src/content/index.ts"],"sourcesContent":["// SafePlay Video Page Button Injector\n// Injects the SafePlay button next to the Subscribe button on YouTube watch pages\n// and above the like button on YouTube Shorts\n\nimport { ButtonState, ButtonStateInfo } from '../types';\n\nexport interface InjectorOptions {\n  onButtonClick: (youtubeId: string) => void;\n  onToggleFilter?: () => void; // Called when user clicks to toggle filter on/off\n  debug?: boolean;\n}\n\nconst PROCESSED_ATTR = 'data-safeplay-processed';\nconst BUTTON_CONTAINER_CLASS = 'safeplay-video-page-button-container';\nconst SHORTS_BUTTON_CLASS = 'safeplay-shorts-button';\n\n// Button state configurations with YouTube theme colors\n// Water fill uses blue (#3b82f6) that fills from bottom to top during processing\nconst BUTTON_STATES: Record<ButtonState, { bg: string; hoverBg: string; text: string; shadow: string; useWater?: boolean }> = {\n  idle: {\n    bg: '#ff0000', // YouTube red\n    hoverBg: '#cc0000',\n    text: 'SafePlay',\n    shadow: 'rgba(255, 0, 0, 0.3)',\n  },\n  connecting: {\n    bg: '#3f3f3f', // YouTube dark gray\n    hoverBg: '#4f4f4f',\n    text: 'Connecting...',\n    shadow: 'rgba(63, 63, 63, 0.3)',\n  },\n  downloading: {\n    bg: '#212121', // Dark background for water contrast\n    hoverBg: '#2a2a2a',\n    text: 'Filtering...',\n    shadow: 'rgba(59, 130, 246, 0.4)',\n    useWater: true,\n  },\n  transcribing: {\n    bg: '#212121', // Dark background for water contrast\n    hoverBg: '#2a2a2a',\n    text: 'Filtering...',\n    shadow: 'rgba(59, 130, 246, 0.4)',\n    useWater: true,\n  },\n  processing: {\n    bg: '#212121', // Dark background for water contrast\n    hoverBg: '#2a2a2a',\n    text: 'Filtering...',\n    shadow: 'rgba(59, 130, 246, 0.4)',\n    useWater: true,\n  },\n  filtering: {\n    bg: '#3b82f6', // Blue - fully filled with water\n    hoverBg: '#2563eb',\n    text: 'Censored',\n    shadow: 'rgba(59, 130, 246, 0.4)',\n  },\n  paused: {\n    bg: '#6b7280', // Gray - paused state\n    hoverBg: '#4b5563',\n    text: 'Paused',\n    shadow: 'rgba(107, 114, 128, 0.4)',\n  },\n  error: {\n    bg: '#ff4e45', // YouTube error red-orange\n    hoverBg: '#e63e35',\n    text: 'Retry',\n    shadow: 'rgba(255, 78, 69, 0.4)',\n  },\n  'age-restricted': {\n    bg: '#f59e0b', // Amber/warning color (not error red)\n    hoverBg: '#d97706',\n    text: 'Age-Restricted',\n    shadow: 'rgba(245, 158, 11, 0.4)',\n  },\n};\n\nexport class ResilientInjector {\n  private options: InjectorOptions;\n  private observer: MutationObserver | null = null;\n  private currentVideoId: string | null = null;\n  private injectionAttempts = 0;\n  private maxAttempts = 50;\n  private retryInterval: number | null = null;\n  private currentState: ButtonState = 'idle';\n  // Track Shorts button states by video ID\n  private shortsButtonStates: Map<string, ButtonState> = new Map();\n  private shortsScrollObserver: IntersectionObserver | null = null;\n\n  constructor(options: InjectorOptions) {\n    this.options = options;\n  }\n\n  // Start observing and injecting\n  start(): void {\n    this.log('Starting video page injector');\n\n    // Initial injection attempt\n    this.attemptInjection();\n\n    // Set up mutation observer for SPA navigation\n    this.setupMutationObserver();\n\n    // Listen for YouTube SPA navigation\n    this.setupNavigationListener();\n\n    // Set up Shorts scroll observer\n    this.setupShortsScrollObserver();\n  }\n\n  // Stop observing\n  stop(): void {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = null;\n    }\n\n    if (this.retryInterval !== null) {\n      clearInterval(this.retryInterval);\n      this.retryInterval = null;\n    }\n\n    if (this.shortsScrollObserver) {\n      this.shortsScrollObserver.disconnect();\n      this.shortsScrollObserver = null;\n    }\n\n    this.log('Stopped video page injector');\n  }\n\n  private isWatchPage(): boolean {\n    return window.location.pathname === '/watch' &&\n           window.location.search.includes('v=');\n  }\n\n  private isShortsPage(): boolean {\n    return window.location.pathname.startsWith('/shorts');\n  }\n\n  private getVideoId(): string | null {\n    const urlParams = new URLSearchParams(window.location.search);\n    return urlParams.get('v');\n  }\n\n  private getShortsVideoId(): string | null {\n    const match = window.location.pathname.match(/\\/shorts\\/([a-zA-Z0-9_-]+)/);\n    return match ? match[1] : null;\n  }\n\n  // Main injection function\n  private attemptInjection(): void {\n    // Handle Shorts pages\n    if (this.isShortsPage()) {\n      this.attemptShortsInjection();\n      return;\n    }\n\n    // Handle regular watch pages\n    if (!this.isWatchPage()) {\n      return;\n    }\n\n    const videoId = this.getVideoId();\n    if (!videoId) {\n      this.log('No video ID found');\n      return;\n    }\n\n    // Check if already injected for this video\n    if (this.currentVideoId === videoId && this.isButtonPresent()) {\n      this.log('Button already present for this video');\n      return;\n    }\n\n    // Try to find the subscribe button container\n    const subscribeButton = this.findSubscribeButton();\n\n    if (subscribeButton) {\n      this.injectButton(subscribeButton, videoId);\n      this.currentVideoId = videoId;\n      this.injectionAttempts = 0;\n      if (this.retryInterval !== null) {\n        clearInterval(this.retryInterval);\n        this.retryInterval = null;\n      }\n    } else {\n      this.injectionAttempts++;\n      this.log(`Subscribe button not found, attempt ${this.injectionAttempts}/${this.maxAttempts}`);\n\n      // Retry with interval\n      if (this.injectionAttempts < this.maxAttempts && this.retryInterval === null) {\n        this.retryInterval = window.setInterval(() => {\n          this.attemptInjection();\n        }, 200);\n      }\n    }\n  }\n\n  // Attempt injection for YouTube Shorts\n  private attemptShortsInjection(): void {\n    // Find all Shorts renderers on the page\n    const shortsRenderers = document.querySelectorAll('ytd-reel-video-renderer, ytd-shorts');\n\n    shortsRenderers.forEach((renderer) => {\n      // Skip if already processed\n      if (renderer.getAttribute(PROCESSED_ATTR) === 'true') {\n        return;\n      }\n\n      // Find the video ID from the renderer\n      const videoId = this.getShortsVideoIdFromRenderer(renderer);\n      if (!videoId) {\n        return;\n      }\n\n      // Find the action buttons container (like, dislike, comment, share)\n      const actionsContainer = this.findShortsActionsContainer(renderer);\n      if (!actionsContainer) {\n        this.log('Shorts actions container not found for', videoId);\n        return;\n      }\n\n      // Inject the button\n      this.injectShortsButton(actionsContainer, videoId, renderer);\n      renderer.setAttribute(PROCESSED_ATTR, 'true');\n    });\n\n    // Also try to inject into the currently visible Short\n    this.injectIntoVisibleShort();\n  }\n\n  // Get video ID from a Shorts renderer element\n  private getShortsVideoIdFromRenderer(renderer: Element): string | null {\n    // Try to get from URL/link in the renderer\n    const link = renderer.querySelector('a[href*=\"/shorts/\"]');\n    if (link) {\n      const href = link.getAttribute('href');\n      const match = href?.match(/\\/shorts\\/([a-zA-Z0-9_-]+)/);\n      if (match) return match[1];\n    }\n\n    // Try to extract from video source\n    const videoElement = renderer.querySelector('video');\n    if (videoElement) {\n      const src = videoElement.src || videoElement.currentSrc;\n      if (src) {\n        const match = src.match(/\\/([a-zA-Z0-9_-]{11})\\//);\n        if (match) return match[1];\n      }\n    }\n\n    // DO NOT fall back to URL - it may have stale video ID when scrolling\n    // Only injectIntoVisibleShort should use the URL\n    return null;\n  }\n\n  // Find the actions container in Shorts (like button, dislike, etc.)\n  private findShortsActionsContainer(renderer: Element): HTMLElement | null {\n    // Shorts uses different selectors - try multiple\n    const selectors = [\n      '#actions', // Main actions container\n      'ytd-reel-player-overlay-renderer #actions',\n      '#like-button', // Fall back to like button itself\n      '[id=\"like-button\"]',\n      'ytd-like-button-renderer',\n    ];\n\n    for (const selector of selectors) {\n      const element = renderer.querySelector<HTMLElement>(selector);\n      if (element) {\n        this.log(`Found Shorts actions with selector: ${selector}`);\n        return element;\n      }\n    }\n\n    // Also try document-level for the currently playing Short\n    for (const selector of selectors) {\n      const element = document.querySelector<HTMLElement>(`ytd-shorts ${selector}, ytd-reel-video-renderer ${selector}`);\n      if (element) {\n        this.log(`Found Shorts actions at document level: ${selector}`);\n        return element;\n      }\n    }\n\n    return null;\n  }\n\n  // Inject into the currently visible/active Short\n  private injectIntoVisibleShort(): void {\n    const videoId = this.getShortsVideoId();\n    if (!videoId) return;\n\n    // Check if already injected for this video\n    const existingButton = document.querySelector(`.${SHORTS_BUTTON_CLASS}[data-video-id=\"${videoId}\"]`);\n    if (existingButton) return;\n\n    // Find the actions container for the current Short\n    const actionsContainer = document.querySelector<HTMLElement>(\n      'ytd-shorts #actions, ytd-reel-video-renderer[is-active] #actions, #shorts-player #actions'\n    );\n\n    if (actionsContainer && !actionsContainer.querySelector(`.${SHORTS_BUTTON_CLASS}`)) {\n      const renderer = actionsContainer.closest('ytd-reel-video-renderer, ytd-shorts') || document.body;\n      this.injectShortsButton(actionsContainer, videoId, renderer);\n    }\n  }\n\n  // Inject SafePlay button into Shorts UI\n  private injectShortsButton(actionsContainer: HTMLElement, videoId: string, renderer: Element): void {\n    // Remove any existing button for this video\n    const existingButton = renderer.querySelector(`.${SHORTS_BUTTON_CLASS}[data-video-id=\"${videoId}\"]`);\n    if (existingButton) {\n      existingButton.remove();\n    }\n\n    // Initialize state for this video\n    if (!this.shortsButtonStates.has(videoId)) {\n      this.shortsButtonStates.set(videoId, 'idle');\n    }\n\n    // Create button container matching Shorts style\n    const container = document.createElement('div');\n    container.className = `${SHORTS_BUTTON_CLASS}`;\n    container.setAttribute('data-video-id', videoId);\n    container.style.cssText = `\n      display: flex;\n      flex-direction: column;\n      align-items: center;\n      margin-bottom: 16px;\n      cursor: pointer;\n    `;\n\n    // Create circular button (matching YouTube Shorts action buttons)\n    const button = document.createElement('button');\n    button.className = 'safeplay-shorts-action-button';\n    const state = this.shortsButtonStates.get(videoId) || 'idle';\n    const stateConfig = BUTTON_STATES[state];\n\n    button.style.cssText = `\n      width: 48px;\n      height: 48px;\n      border-radius: 50%;\n      border: none;\n      background: ${stateConfig.bg};\n      color: white;\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      cursor: pointer;\n      transition: all 0.2s ease;\n      box-shadow: 0 2px 8px rgba(0,0,0,0.3);\n      position: relative;\n      overflow: hidden;\n    `;\n\n    // Add icon\n    const iconWrapper = document.createElement('div');\n    iconWrapper.className = 'safeplay-shorts-icon';\n    iconWrapper.style.cssText = 'display: flex; align-items: center; justify-content: center; position: relative; z-index: 1;';\n    iconWrapper.innerHTML = this.getShortsIconSVG(state);\n    button.appendChild(iconWrapper);\n\n    // Add label below button\n    const label = document.createElement('span');\n    label.className = 'safeplay-shorts-label';\n    label.style.cssText = `\n      color: white;\n      font-size: 12px;\n      margin-top: 4px;\n      text-shadow: 0 1px 2px rgba(0,0,0,0.5);\n      font-family: \"Roboto\", \"Arial\", sans-serif;\n    `;\n    label.textContent = state === 'filtering' ? 'Censored' : (state === 'idle' ? 'SafePlay' : stateConfig.text);\n\n    // Add hover effects\n    button.addEventListener('mouseenter', () => {\n      const currentState = this.shortsButtonStates.get(videoId) || 'idle';\n      const config = BUTTON_STATES[currentState];\n      button.style.background = config.hoverBg;\n      button.style.transform = 'scale(1.1)';\n    });\n\n    button.addEventListener('mouseleave', () => {\n      const currentState = this.shortsButtonStates.get(videoId) || 'idle';\n      const config = BUTTON_STATES[currentState];\n      button.style.background = config.bg;\n      button.style.transform = 'scale(1)';\n    });\n\n    // Add click handler\n    button.addEventListener('click', (e) => {\n      e.preventDefault();\n      e.stopPropagation();\n\n      const currentState = this.shortsButtonStates.get(videoId) || 'idle';\n\n      if (currentState === 'idle' || currentState === 'error') {\n        this.currentVideoId = videoId;\n        this.options.onButtonClick(videoId);\n      } else if (currentState === 'filtering' || currentState === 'paused') {\n        this.currentVideoId = videoId;\n        if (this.options.onToggleFilter) {\n          this.options.onToggleFilter();\n        }\n      }\n    });\n\n    container.appendChild(button);\n    container.appendChild(label);\n\n    // Insert at the top of the actions container (above like button)\n    actionsContainer.insertBefore(container, actionsContainer.firstChild);\n\n    this.log(`Injected SafePlay Shorts button for video: ${videoId}`);\n  }\n\n  // Get icon SVG for Shorts buttons (smaller, simpler icons)\n  private getShortsIconSVG(state: ButtonState): string {\n    switch (state) {\n      case 'connecting':\n      case 'downloading':\n      case 'transcribing':\n      case 'processing':\n        return `\n          <svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" class=\"safeplay-spinner\">\n            <style>.safeplay-spinner { animation: safeplay-spin 1s linear infinite; } @keyframes safeplay-spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }</style>\n            <circle cx=\"12\" cy=\"12\" r=\"10\" stroke-opacity=\"0.25\"/>\n            <path d=\"M12 2a10 10 0 0 1 10 10\" stroke-linecap=\"round\"/>\n          </svg>\n        `;\n      case 'filtering':\n        return `\n          <svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n            <path d=\"M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm-2 16l-4-4 1.41-1.41L10 14.17l6.59-6.59L18 9l-8 8z\"/>\n          </svg>\n        `;\n      case 'paused':\n        return `\n          <svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n            <path d=\"M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm-1 14H9V9h2v6zm4 0h-2V9h2v6z\"/>\n          </svg>\n        `;\n      case 'error':\n        return `\n          <svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n            <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z\"/>\n          </svg>\n        `;\n      case 'age-restricted':\n        // Shield with 18+ symbol for age-restricted content\n        return `\n          <svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n            <path d=\"M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4z\"/>\n            <text x=\"12\" y=\"15\" text-anchor=\"middle\" fill=\"#f59e0b\" font-size=\"8\" font-weight=\"bold\" font-family=\"Arial\">18</text>\n          </svg>\n        `;\n      default:\n        // Shield icon for idle state\n        return `\n          <svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n            <path d=\"M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4z\"/>\n          </svg>\n        `;\n    }\n  }\n\n  // Set up IntersectionObserver for Shorts scroll detection\n  private setupShortsScrollObserver(): void {\n    if (this.shortsScrollObserver) {\n      this.shortsScrollObserver.disconnect();\n    }\n\n    this.shortsScrollObserver = new IntersectionObserver(\n      (entries) => {\n        entries.forEach((entry) => {\n          if (entry.isIntersecting) {\n            // A Short has scrolled into view\n            const renderer = entry.target;\n            const videoId = this.getShortsVideoIdFromRenderer(renderer);\n\n            if (videoId) {\n              this.log(`Short scrolled into view: ${videoId}`);\n              // Update current video ID\n              this.currentVideoId = videoId;\n              // Attempt to inject button if not present\n              if (!renderer.querySelector(`.${SHORTS_BUTTON_CLASS}`)) {\n                this.attemptShortsInjection();\n              }\n            }\n          }\n        });\n      },\n      {\n        threshold: 0.5, // Trigger when 50% visible\n      }\n    );\n\n    // Observe existing Shorts renderers\n    this.observeShortsRenderers();\n  }\n\n  // Observe Shorts renderers for scroll detection\n  private observeShortsRenderers(): void {\n    if (!this.shortsScrollObserver) return;\n\n    const renderers = document.querySelectorAll('ytd-reel-video-renderer, ytd-shorts');\n    renderers.forEach((renderer) => {\n      this.shortsScrollObserver!.observe(renderer);\n    });\n  }\n\n  private findSubscribeButton(): HTMLElement | null {\n    const selectors = [\n      '#subscribe-button.ytd-watch-metadata',\n      'ytd-watch-metadata #subscribe-button',\n      '#owner #subscribe-button',\n      '#subscribe-button',\n    ];\n\n    for (const selector of selectors) {\n      const element = document.querySelector<HTMLElement>(selector);\n      if (element) {\n        this.log(`Found subscribe button with selector: ${selector}`);\n        return element;\n      }\n    }\n\n    return null;\n  }\n\n  private isButtonPresent(): boolean {\n    return document.querySelector(`.${BUTTON_CONTAINER_CLASS}`) !== null;\n  }\n\n  private injectButton(subscribeButton: HTMLElement, videoId: string): void {\n    // Remove any existing SafePlay button\n    const existingButton = document.querySelector(`.${BUTTON_CONTAINER_CLASS}`);\n    if (existingButton) {\n      existingButton.remove();\n    }\n\n    // Reset state for new video\n    this.currentState = 'idle';\n\n    // Create button container\n    const container = document.createElement('div');\n    container.className = `${BUTTON_CONTAINER_CLASS} style-scope ytd-watch-metadata`;\n    container.style.cssText = 'display: inline-flex; align-items: center; margin-left: 8px;';\n    container.setAttribute(PROCESSED_ATTR, 'true');\n\n    // Create the button matching YouTube's style\n    const button = document.createElement('button');\n    button.className = 'safeplay-main-button yt-spec-button-shape-next yt-spec-button-shape-next--tonal yt-spec-button-shape-next--mono yt-spec-button-shape-next--size-m yt-spec-button-shape-next--icon-leading';\n    button.title = 'Filter profanity with SafePlay';\n    button.setAttribute('aria-label', 'SafePlay Filter');\n    button.setAttribute('data-video-id', videoId);\n    container.setAttribute('data-video-id', videoId);\n\n    const stateConfig = BUTTON_STATES.idle;\n    button.style.cssText = `\n      border: none;\n      background: ${stateConfig.bg};\n      color: #ffffff;\n      border-radius: 18px;\n      padding: 0 16px;\n      height: 36px;\n      font-family: \"Roboto\", \"Arial\", sans-serif;\n      font-size: 14px;\n      font-weight: 500;\n      line-height: 36px;\n      display: inline-flex;\n      align-items: center;\n      justify-content: center;\n      gap: 6px;\n      cursor: pointer;\n      transition: all 0.2s ease;\n      min-width: 120px;\n      box-shadow: 0 2px 4px ${stateConfig.shadow};\n      position: relative;\n      overflow: hidden;\n    `;\n\n    // Create water fill element (for progress animation)\n    const waterFill = document.createElement('div');\n    waterFill.className = 'safeplay-water-fill';\n    waterFill.style.cssText = `\n      position: absolute;\n      bottom: 0;\n      left: 0;\n      right: 0;\n      height: 0%;\n      background: linear-gradient(to top, #3b82f6, #60a5fa);\n      transition: height 0.3s ease-out;\n      overflow: hidden;\n      border-radius: 18px;\n      z-index: 0;\n    `;\n\n    // Add icon (z-index to appear above water)\n    const iconWrapper = document.createElement('div');\n    iconWrapper.className = 'safeplay-icon';\n    iconWrapper.style.cssText = 'display: inline-flex; align-items: center; justify-content: center; width: 20px; height: 20px; flex-shrink: 0; position: relative; z-index: 1;';\n    iconWrapper.innerHTML = this.getIconSVG('idle');\n\n    // Add text (z-index to appear above water)\n    const textSpan = document.createElement('span');\n    textSpan.className = 'safeplay-text';\n    textSpan.style.cssText = 'color: currentColor; font-size: 14px; font-weight: 500; line-height: 1; white-space: nowrap; position: relative; z-index: 1;';\n    textSpan.textContent = stateConfig.text;\n\n    button.appendChild(waterFill);\n    button.appendChild(iconWrapper);\n    button.appendChild(textSpan);\n\n    // Add hover effects\n    button.addEventListener('mouseenter', () => {\n      const config = BUTTON_STATES[this.currentState];\n      button.style.background = config.hoverBg;\n      button.style.boxShadow = `0 4px 8px ${config.shadow}`;\n      button.style.transform = 'translateY(-1px)';\n    });\n\n    button.addEventListener('mouseleave', () => {\n      const config = BUTTON_STATES[this.currentState];\n      button.style.background = config.bg;\n      button.style.boxShadow = `0 2px 4px ${config.shadow}`;\n      button.style.transform = 'translateY(0)';\n    });\n\n    // Add click handler\n    button.addEventListener('click', (e) => {\n      e.preventDefault();\n      e.stopPropagation();\n\n      // Allow click in idle, error, filtering (censored), or paused state\n      if (this.currentState === 'idle' || this.currentState === 'error') {\n        this.options.onButtonClick(videoId);\n      } else if (this.currentState === 'filtering' || this.currentState === 'paused') {\n        // Toggle filter on/off\n        if (this.options.onToggleFilter) {\n          this.options.onToggleFilter();\n        }\n      }\n    });\n\n    container.appendChild(button);\n\n    // Insert after subscribe button\n    subscribeButton.parentElement?.insertBefore(container, subscribeButton.nextSibling);\n\n    this.log(`Injected SafePlay button for video: ${videoId}`);\n  }\n\n  private getIconSVG(state: ButtonState): string {\n    switch (state) {\n      case 'connecting':\n      case 'downloading':\n      case 'transcribing':\n      case 'processing':\n        // Spinning loader icon\n        return `\n          <svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" class=\"safeplay-spinner\">\n            <style>.safeplay-spinner { animation: safeplay-spin 1s linear infinite; } @keyframes safeplay-spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }</style>\n            <circle cx=\"12\" cy=\"12\" r=\"10\" stroke-opacity=\"0.25\"/>\n            <path d=\"M12 2a10 10 0 0 1 10 10\" stroke-linecap=\"round\"/>\n          </svg>\n        `;\n      case 'filtering':\n        // Active shield icon with checkmark\n        return `\n          <svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n            <path d=\"M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm-2 16l-4-4 1.41-1.41L10 14.17l6.59-6.59L18 9l-8 8z\"/>\n          </svg>\n        `;\n      case 'paused':\n        // Paused - shield with pause bars\n        return `\n          <svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n            <path d=\"M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm-1 14H9V9h2v6zm4 0h-2V9h2v6z\"/>\n          </svg>\n        `;\n      case 'error':\n        // Error icon\n        return `\n          <svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n            <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z\"/>\n          </svg>\n        `;\n      case 'age-restricted':\n        // Shield with 18+ symbol for age-restricted content\n        return `\n          <svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n            <path d=\"M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4z\"/>\n            <text x=\"12\" y=\"15\" text-anchor=\"middle\" fill=\"#f59e0b\" font-size=\"8\" font-weight=\"bold\" font-family=\"Arial\">18</text>\n          </svg>\n        `;\n      default:\n        // Default checkmark icon\n        return `\n          <svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n            <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z\"/>\n          </svg>\n        `;\n    }\n  }\n\n  // Update button state with detailed info\n  updateButtonState(stateInfo: ButtonStateInfo): void {\n    // Update regular watch page button\n    this.updateWatchPageButton(stateInfo);\n\n    // Update Shorts button - use videoId from stateInfo if provided, otherwise currentVideoId\n    const targetVideoId = stateInfo.videoId || this.currentVideoId;\n    if (targetVideoId) {\n      this.updateShortsButton(targetVideoId, stateInfo);\n    }\n  }\n\n  // Update watch page button\n  private updateWatchPageButton(stateInfo: ButtonStateInfo): void {\n    const container = document.querySelector(`.${BUTTON_CONTAINER_CLASS}`);\n    if (!container) return;\n\n    // Verify this update is for the correct video to prevent stale state updates\n    const buttonVideoId = container.getAttribute('data-video-id');\n    if (stateInfo.videoId && buttonVideoId && stateInfo.videoId !== buttonVideoId) {\n      this.log(`Ignoring state update for ${stateInfo.videoId}, button is for ${buttonVideoId}`);\n      return;\n    }\n\n    const button = container.querySelector<HTMLButtonElement>('.safeplay-main-button');\n    const textSpan = container.querySelector<HTMLSpanElement>('.safeplay-text');\n    const iconWrapper = container.querySelector<HTMLDivElement>('.safeplay-icon');\n    const waterFill = container.querySelector<HTMLDivElement>('.safeplay-water-fill');\n\n    if (!button || !textSpan || !iconWrapper) return;\n\n    this.currentState = stateInfo.state;\n    const config = BUTTON_STATES[stateInfo.state];\n\n    // Update colors\n    button.style.background = config.bg;\n    button.style.boxShadow = `0 2px 4px ${config.shadow}`;\n\n    // Update icon\n    iconWrapper.innerHTML = this.getIconSVG(stateInfo.state);\n\n    // Update text\n    let displayText = stateInfo.text || config.text;\n\n    // Add progress percentage for processing states\n    if (stateInfo.progress !== undefined && stateInfo.progress > 0) {\n      if (stateInfo.state === 'downloading' || stateInfo.state === 'transcribing' || stateInfo.state === 'processing') {\n        displayText = `${config.text.replace('...', '')} ${Math.round(stateInfo.progress)}%`;\n      }\n    }\n\n    // Add interval count for filtering state (completed)\n    if (stateInfo.state === 'filtering' && stateInfo.intervalCount !== undefined) {\n      displayText = `Censored (${stateInfo.intervalCount})`;\n    }\n\n    textSpan.textContent = displayText;\n\n    // Update water fill effect\n    if (waterFill) {\n      if (config.useWater && stateInfo.progress !== undefined && stateInfo.progress > 0) {\n        // Show water filling up during processing states\n        waterFill.style.height = `${stateInfo.progress}%`;\n        waterFill.classList.remove('safeplay-water-full');\n      } else if (stateInfo.state === 'filtering') {\n        // Fully filled when complete - solid blue\n        waterFill.style.height = '100%';\n        waterFill.classList.add('safeplay-water-full');\n      } else if (stateInfo.state === 'paused') {\n        // Paused - drain the water (animate to empty)\n        waterFill.style.height = '0%';\n        waterFill.classList.remove('safeplay-water-full');\n      } else {\n        // Reset water for other states\n        waterFill.style.height = '0%';\n        waterFill.classList.remove('safeplay-water-full');\n      }\n    }\n\n    // Update cursor - clickable in idle, error, filtering, and paused states\n    // Age-restricted is NOT clickable since retry won't help\n    if (stateInfo.state === 'idle' || stateInfo.state === 'error' ||\n        stateInfo.state === 'filtering' || stateInfo.state === 'paused') {\n      button.style.cursor = 'pointer';\n    } else {\n      button.style.cursor = 'default';\n    }\n\n    // Update title/tooltip\n    switch (stateInfo.state) {\n      case 'connecting':\n        button.title = 'Connecting to SafePlay service...';\n        break;\n      case 'downloading':\n        button.title = `Filtering: Downloading audio${stateInfo.progress ? ` (${Math.round(stateInfo.progress)}%)` : '...'}`;\n        break;\n      case 'transcribing':\n        button.title = `Filtering: Transcribing audio${stateInfo.progress ? ` (${Math.round(stateInfo.progress)}%)` : '...'}`;\n        break;\n      case 'processing':\n        button.title = 'Filtering: Processing transcript...';\n        break;\n      case 'filtering':\n        button.title = `Censored${stateInfo.intervalCount ? ` - ${stateInfo.intervalCount} words filtered` : ''} - Click to disable`;\n        break;\n      case 'paused':\n        button.title = 'Filter paused - Click to re-enable';\n        break;\n      case 'error':\n        button.title = stateInfo.error || 'Something went wrong - Click to retry';\n        break;\n      case 'age-restricted':\n        button.title = stateInfo.error || 'This video is age-restricted by YouTube. SafePlay cannot filter age-restricted content.';\n        break;\n      default:\n        button.title = 'Click to filter profanity with SafePlay';\n    }\n\n    this.log(`Button state updated to: ${stateInfo.state}`, stateInfo);\n  }\n\n  // Convenience method for simple state updates\n  setButtonState(state: ButtonState, text?: string, progress?: number): void {\n    this.updateButtonState({ state, text: text || '', progress });\n  }\n\n  // Update Shorts button state for a specific video\n  private updateShortsButton(videoId: string, stateInfo: ButtonStateInfo): void {\n    const container = document.querySelector(`.${SHORTS_BUTTON_CLASS}[data-video-id=\"${videoId}\"]`);\n    if (!container) return;\n\n    const button = container.querySelector<HTMLButtonElement>('.safeplay-shorts-action-button');\n    const iconWrapper = container.querySelector<HTMLDivElement>('.safeplay-shorts-icon');\n    const label = container.querySelector<HTMLSpanElement>('.safeplay-shorts-label');\n\n    if (!button || !iconWrapper) return;\n\n    // Update state tracking\n    this.shortsButtonStates.set(videoId, stateInfo.state);\n    const config = BUTTON_STATES[stateInfo.state];\n\n    // Update button background\n    button.style.background = config.bg;\n\n    // Update icon\n    iconWrapper.innerHTML = this.getShortsIconSVG(stateInfo.state);\n\n    // Update label\n    if (label) {\n      let labelText = stateInfo.state === 'idle' ? 'SafePlay' : config.text;\n\n      if (stateInfo.state === 'filtering' && stateInfo.intervalCount !== undefined) {\n        labelText = `${stateInfo.intervalCount}`;\n      } else if (stateInfo.state === 'filtering') {\n        labelText = 'Censored';\n      }\n\n      // Show progress for processing states\n      if (stateInfo.progress !== undefined && stateInfo.progress > 0) {\n        if (stateInfo.state === 'downloading' || stateInfo.state === 'transcribing' || stateInfo.state === 'processing') {\n          labelText = `${Math.round(stateInfo.progress)}%`;\n        }\n      }\n\n      label.textContent = labelText;\n    }\n\n    // Update cursor - age-restricted is NOT clickable since retry won't help\n    if (stateInfo.state === 'idle' || stateInfo.state === 'error' ||\n        stateInfo.state === 'filtering' || stateInfo.state === 'paused') {\n      button.style.cursor = 'pointer';\n    } else {\n      button.style.cursor = 'default';\n    }\n\n    this.log(`Shorts button state updated to: ${stateInfo.state} for ${videoId}`);\n  }\n\n  // Set up mutation observer for dynamic content changes\n  private setupMutationObserver(): void {\n    this.observer = new MutationObserver((mutations) => {\n      for (const mutation of mutations) {\n        if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {\n          for (const node of mutation.addedNodes) {\n            if (node instanceof HTMLElement) {\n              // Watch page: detect subscribe button changes\n              if (node.id === 'subscribe-button' ||\n                  node.querySelector?.('#subscribe-button') ||\n                  node.closest?.('ytd-watch-metadata')) {\n                this.log('Subscribe button area changed, re-injecting');\n                this.attemptInjection();\n                return;\n              }\n\n              // Shorts: detect new Short renderers being added\n              if (node.tagName === 'YTD-REEL-VIDEO-RENDERER' ||\n                  node.tagName === 'YTD-SHORTS' ||\n                  node.querySelector?.('ytd-reel-video-renderer')) {\n                this.log('Shorts renderer added, attempting injection');\n                // Add new renderers to the intersection observer\n                this.observeShortsRenderers();\n                this.attemptShortsInjection();\n                return;\n              }\n\n              // Shorts: detect actions container being added\n              if (node.id === 'actions' || node.querySelector?.('#actions')) {\n                if (this.isShortsPage()) {\n                  this.log('Shorts actions container added');\n                  this.attemptShortsInjection();\n                  return;\n                }\n              }\n            }\n          }\n        }\n      }\n    });\n\n    this.observer.observe(document.body, {\n      childList: true,\n      subtree: true,\n    });\n  }\n\n  // Listen for YouTube SPA navigation\n  private setupNavigationListener(): void {\n    const originalPushState = history.pushState;\n    const originalReplaceState = history.replaceState;\n\n    history.pushState = (...args) => {\n      originalPushState.apply(history, args);\n      this.onNavigation();\n    };\n\n    history.replaceState = (...args) => {\n      originalReplaceState.apply(history, args);\n      this.onNavigation();\n    };\n\n    window.addEventListener('popstate', () => {\n      this.onNavigation();\n    });\n\n    document.addEventListener('yt-navigate-finish', () => {\n      this.onNavigation();\n    });\n\n    document.addEventListener('yt-page-data-updated', () => {\n      this.log('Page data updated');\n      this.onNavigation();\n    });\n  }\n\n  private onNavigation(): void {\n    this.log('Navigation detected');\n    this.currentVideoId = null;\n    this.currentState = 'idle';\n    this.injectionAttempts = 0;\n\n    if (this.retryInterval !== null) {\n      clearInterval(this.retryInterval);\n      this.retryInterval = null;\n    }\n\n    // Clear processed attribute on Shorts renderers so they can be re-processed\n    // This is needed because scrolling in Shorts triggers navigation events\n    if (this.isShortsPage()) {\n      document.querySelectorAll(`[${PROCESSED_ATTR}]`).forEach(el => {\n        el.removeAttribute(PROCESSED_ATTR);\n      });\n      // Remove all existing Shorts buttons - they'll be re-injected with correct state\n      document.querySelectorAll(`.${SHORTS_BUTTON_CLASS}`).forEach(el => {\n        el.remove();\n      });\n      // Clear button states for fresh start\n      this.shortsButtonStates.clear();\n    }\n\n    setTimeout(() => {\n      this.attemptInjection();\n    }, 300);\n  }\n\n  // Get current video ID\n  getCurrentVideoId(): string | null {\n    return this.currentVideoId;\n  }\n\n  // Debug logging\n  private log(...args: unknown[]): void {\n    if (this.options.debug) {\n      console.log('[SafePlay Injector]', ...args);\n    }\n  }\n}\n","import { MuteInterval, FilterMode } from '../types';\n\n// Fade duration in seconds for smooth transitions\nconst FADE_DURATION = 0.05; // 50ms fade - fast but smooth\nconst FADE_BUFFER = 0.08; // 80ms - start fading before interval begins\n\nexport class AudioFilter {\n  private video: HTMLVideoElement | null = null;\n  private muteIntervals: MuteInterval[] = [];\n  private filterMode: FilterMode = 'mute';\n  private isActive = false;\n  private checkIntervalId: number | null = null;\n  private isMuted = false;\n  private isFading = false;\n  private isBleeping = false; // Track if bleep should be playing\n\n  // Web Audio API for smooth volume control\n  private audioContext: AudioContext | null = null;\n  private sourceNode: MediaElementAudioSourceNode | null = null;\n  private gainNode: GainNode | null = null;\n\n  // Bleep sound nodes\n  private bleepOscillator: OscillatorNode | null = null;\n  private bleepGain: GainNode | null = null;\n\n  // Track current gain target to avoid redundant fades\n  private currentGainTarget = 1;\n\n  // Callbacks\n  private onMuteStart?: (interval: MuteInterval) => void;\n  private onMuteEnd?: () => void;\n\n  // Bound event handlers for cleanup\n  private boundHandleVideoPause: () => void;\n  private boundHandleVideoPlay: () => void;\n  private boundHandleVideoEnded: () => void;\n  private boundHandleVideoSeeking: () => void;\n  private boundHandleVisibilityChange: () => void;\n\n  constructor(options?: {\n    onMuteStart?: (interval: MuteInterval) => void;\n    onMuteEnd?: () => void;\n  }) {\n    this.onMuteStart = options?.onMuteStart;\n    this.onMuteEnd = options?.onMuteEnd;\n\n    // Bind event handlers\n    this.boundHandleVideoPause = this.handleVideoPause.bind(this);\n    this.boundHandleVideoPlay = this.handleVideoPlay.bind(this);\n    this.boundHandleVideoEnded = this.handleVideoEnded.bind(this);\n    this.boundHandleVideoSeeking = this.handleVideoSeeking.bind(this);\n    this.boundHandleVisibilityChange = this.handleVisibilityChange.bind(this);\n  }\n\n  // Initialize with video element and mute intervals\n  initialize(\n    video: HTMLVideoElement,\n    intervals: MuteInterval[],\n    mode: FilterMode = 'mute'\n  ): void {\n    this.video = video;\n    this.muteIntervals = intervals;\n    this.filterMode = mode;\n\n    // Sort intervals by start time for efficient lookup\n    this.muteIntervals.sort((a, b) => a.start - b.start);\n\n    // Initialize Web Audio API for smooth volume control\n    this.initializeAudioContext();\n  }\n\n  private initializeAudioContext(): void {\n    if (!this.video || this.audioContext) return;\n\n    try {\n      this.audioContext = new AudioContext();\n\n      // Create source from video element\n      this.sourceNode = this.audioContext.createMediaElementSource(this.video);\n\n      // Create gain node for volume control\n      this.gainNode = this.audioContext.createGain();\n      this.gainNode.gain.value = 1; // Start at full volume\n\n      // Connect: video -> gain -> destination (speakers)\n      this.sourceNode.connect(this.gainNode);\n      this.gainNode.connect(this.audioContext.destination);\n\n      // Setup bleep gain for bleep mode\n      if (this.filterMode === 'bleep') {\n        this.bleepGain = this.audioContext.createGain();\n        this.bleepGain.gain.value = 0;\n        this.bleepGain.connect(this.audioContext.destination);\n      }\n\n      // Add video event listeners for bleep control\n      this.addVideoEventListeners();\n\n      console.log('[SafePlay] Audio context initialized with smooth fading');\n    } catch (error) {\n      console.error('[SafePlay] Failed to initialize audio context:', error);\n      // Fallback: will use video.muted instead\n    }\n  }\n\n  // Add event listeners for video state changes\n  private addVideoEventListeners(): void {\n    if (!this.video) return;\n\n    this.video.addEventListener('pause', this.boundHandleVideoPause);\n    this.video.addEventListener('play', this.boundHandleVideoPlay);\n    this.video.addEventListener('ended', this.boundHandleVideoEnded);\n    this.video.addEventListener('seeking', this.boundHandleVideoSeeking);\n    document.addEventListener('visibilitychange', this.boundHandleVisibilityChange);\n  }\n\n  // Remove event listeners\n  private removeVideoEventListeners(): void {\n    if (this.video) {\n      this.video.removeEventListener('pause', this.boundHandleVideoPause);\n      this.video.removeEventListener('play', this.boundHandleVideoPlay);\n      this.video.removeEventListener('ended', this.boundHandleVideoEnded);\n      this.video.removeEventListener('seeking', this.boundHandleVideoSeeking);\n    }\n    document.removeEventListener('visibilitychange', this.boundHandleVisibilityChange);\n  }\n\n  // Handle video pause - stop bleep immediately\n  private handleVideoPause(): void {\n    if (this.isBleeping) {\n      this.stopBleep();\n    }\n  }\n\n  // Handle video play - resume bleep if we're in a mute interval\n  private handleVideoPlay(): void {\n    if (!this.video || !this.isActive) return;\n\n    // Check if we're currently in a mute interval\n    const currentTime = this.video.currentTime;\n    const activeInterval = this.findActiveInterval(currentTime);\n\n    if (activeInterval && this.isMuted && this.filterMode === 'bleep') {\n      this.startBleep();\n    }\n  }\n\n  // Handle video ended - stop everything\n  private handleVideoEnded(): void {\n    if (this.isBleeping) {\n      this.stopBleep();\n    }\n    this.isMuted = false;\n    this.isBleeping = false;\n  }\n\n  // Handle seeking - stop bleep during seek, checkCurrentTime will restart if needed\n  private handleVideoSeeking(): void {\n    if (this.isBleeping) {\n      this.stopBleep();\n    }\n  }\n\n  // Handle tab visibility change\n  // Note: We do NOT stop the bleep when tab is hidden because the user\n  // may switch tabs while still wanting to hear the video with profanity filtered.\n  // The bleep should only stop when the video is actually paused.\n  private handleVisibilityChange(): void {\n    // When tab becomes visible again, check if we need to resume bleep\n    // (in case browser throttled audio while hidden)\n    if (!document.hidden && this.video && !this.video.paused && this.isMuted && this.filterMode === 'bleep') {\n      const currentTime = this.video.currentTime;\n      const activeInterval = this.findActiveInterval(currentTime);\n\n      if (activeInterval && !this.bleepOscillator) {\n        this.startBleep();\n      }\n    }\n  }\n\n  // Start monitoring playback\n  start(): void {\n    if (this.isActive || !this.video) {\n      return;\n    }\n\n    this.isActive = true;\n\n    // Resume audio context if suspended (browser autoplay policy)\n    if (this.audioContext?.state === 'suspended') {\n      this.audioContext.resume();\n    }\n\n    // Check every 5ms for precise timing\n    this.checkIntervalId = window.setInterval(() => {\n      this.checkCurrentTime();\n    }, 5);\n\n    console.log('[SafePlay] Audio filter started with', this.muteIntervals.length, 'intervals (smooth fading enabled)');\n  }\n\n  // Stop monitoring\n  stop(): void {\n    if (!this.isActive) {\n      return;\n    }\n\n    this.isActive = false;\n    this.isBleeping = false;\n\n    if (this.checkIntervalId !== null) {\n      clearInterval(this.checkIntervalId);\n      this.checkIntervalId = null;\n    }\n\n    // Restore full volume\n    this.fadeToVolume(1);\n\n    // Stop bleep if playing\n    if (this.bleepOscillator) {\n      try {\n        this.bleepOscillator.stop();\n      } catch (e) {\n        // Already stopped\n      }\n      this.bleepOscillator = null;\n    }\n\n    console.log('[SafePlay] Audio filter stopped');\n  }\n\n  // Clean up resources\n  destroy(): void {\n    this.stop();\n\n    // Remove event listeners\n    this.removeVideoEventListeners();\n\n    if (this.sourceNode) {\n      this.sourceNode.disconnect();\n      this.sourceNode = null;\n    }\n\n    if (this.gainNode) {\n      this.gainNode.disconnect();\n      this.gainNode = null;\n    }\n\n    if (this.audioContext) {\n      this.audioContext.close();\n      this.audioContext = null;\n    }\n  }\n\n  // Check if current time falls within or is approaching any mute interval\n  private checkCurrentTime(): void {\n    if (!this.video || !this.isActive) {\n      return;\n    }\n\n    // Don't process if video is paused, ended, or not ready\n    if (this.video.paused || this.video.ended || this.video.readyState < 2) {\n      return;\n    }\n\n    const currentTime = this.video.currentTime;\n\n    // Check if we're in an interval OR approaching one (within fade buffer)\n    const activeInterval = this.findActiveInterval(currentTime);\n    const approachingInterval = this.findApproachingInterval(currentTime);\n\n    if (activeInterval) {\n      // We're inside a mute interval - ensure volume is 0\n      if (!this.isMuted) {\n        this.startMute(activeInterval);\n      }\n    } else if (approachingInterval) {\n      // We're approaching an interval - start fading out\n      if (!this.isMuted && !this.isFading) {\n        this.startFadeOut(approachingInterval);\n      }\n    } else {\n      // We're outside all intervals - ensure volume is restored\n      if (this.isMuted) {\n        this.endMute();\n      }\n    }\n  }\n\n  // Find if we're currently inside a mute interval\n  private findActiveInterval(time: number): MuteInterval | null {\n    for (const interval of this.muteIntervals) {\n      if (time >= interval.start && time <= interval.end) {\n        return interval;\n      }\n      // Since sorted, we can break early\n      if (interval.start > time + FADE_BUFFER) {\n        break;\n      }\n    }\n    return null;\n  }\n\n  // Find if we're approaching a mute interval (within fade buffer)\n  private findApproachingInterval(time: number): MuteInterval | null {\n    for (const interval of this.muteIntervals) {\n      // Check if we're within the fade buffer before the interval starts\n      const fadeStartTime = interval.start - FADE_BUFFER;\n      if (time >= fadeStartTime && time < interval.start) {\n        return interval;\n      }\n      // Since sorted, we can break early\n      if (interval.start > time + FADE_BUFFER) {\n        break;\n      }\n    }\n    return null;\n  }\n\n  // Start fading out before the interval\n  private startFadeOut(interval: MuteInterval): void {\n    this.isFading = true;\n    this.fadeToVolume(0, () => {\n      this.isFading = false;\n      this.isMuted = true;\n      if (this.onMuteStart) {\n        this.onMuteStart(interval);\n      }\n    });\n\n    // Start bleep if in bleep mode\n    if (this.filterMode === 'bleep') {\n      this.startBleep();\n    }\n  }\n\n  // Immediately mute (when we enter an interval without approaching it first, e.g., seeking)\n  private startMute(interval: MuteInterval): void {\n    this.isMuted = true;\n    this.fadeToVolume(0);\n\n    if (this.filterMode === 'bleep') {\n      this.startBleep();\n    }\n\n    if (this.onMuteStart) {\n      this.onMuteStart(interval);\n    }\n  }\n\n  // End mute - fade back in\n  private endMute(): void {\n    this.isMuted = false;\n    this.fadeToVolume(1);\n\n    if (this.filterMode === 'bleep') {\n      this.stopBleep();\n    }\n\n    if (this.onMuteEnd) {\n      this.onMuteEnd();\n    }\n  }\n\n  // Smooth fade to target volume\n  private fadeToVolume(target: number, onComplete?: () => void): void {\n    // Skip if already at target\n    if (this.currentGainTarget === target) {\n      onComplete?.();\n      return;\n    }\n\n    this.currentGainTarget = target;\n\n    if (this.gainNode && this.audioContext) {\n      const now = this.audioContext.currentTime;\n\n      // Cancel any ongoing transitions\n      this.gainNode.gain.cancelScheduledValues(now);\n\n      // Set current value\n      this.gainNode.gain.setValueAtTime(this.gainNode.gain.value, now);\n\n      // Ramp to target over fade duration\n      this.gainNode.gain.linearRampToValueAtTime(target, now + FADE_DURATION);\n\n      // Call completion callback after fade\n      if (onComplete) {\n        setTimeout(onComplete, FADE_DURATION * 1000);\n      }\n    } else {\n      // Fallback to hard mute if no audio context\n      if (this.video) {\n        this.video.muted = target === 0;\n      }\n      onComplete?.();\n    }\n  }\n\n  // Classic TV censor bleep settings\n  private readonly BLEEP_FREQUENCY = 1000; // 1kHz - the classic censor bleep frequency\n  private readonly BLEEP_VOLUME = 0.35; // Volume level (0-1)\n  private readonly BLEEP_ATTACK = 0.008; // 8ms attack - very fast like real censor bleeps\n  private readonly BLEEP_RELEASE = 0.025; // 25ms release - slightly slower to avoid clicks\n\n  private startBleep(): void {\n    if (!this.audioContext || !this.bleepGain) return;\n\n    // Don't start bleep if video is paused or ended\n    // Note: We DO allow bleep when tab is hidden - user may switch tabs\n    // while still wanting to hear filtered audio\n    if (this.video && (this.video.paused || this.video.ended)) return;\n\n    // Don't start if already bleeping\n    if (this.bleepOscillator) return;\n\n    this.isBleeping = true;\n\n    // Resume audio context if suspended\n    if (this.audioContext.state === 'suspended') {\n      this.audioContext.resume();\n    }\n\n    // Create main oscillator for classic censor bleep\n    this.bleepOscillator = this.audioContext.createOscillator();\n    this.bleepOscillator.type = 'sine'; // Pure sine wave for clean bleep\n    this.bleepOscillator.frequency.value = this.BLEEP_FREQUENCY;\n\n    // Create a subtle second oscillator slightly detuned for richness (optional TV effect)\n    const oscillator2 = this.audioContext.createOscillator();\n    oscillator2.type = 'sine';\n    oscillator2.frequency.value = this.BLEEP_FREQUENCY * 1.001; // Slight detune for thickness\n\n    // Create a mixer for the two oscillators\n    const mixer = this.audioContext.createGain();\n    mixer.gain.value = 0.5;\n\n    // Connect oscillators\n    this.bleepOscillator.connect(this.bleepGain);\n    oscillator2.connect(mixer);\n    mixer.connect(this.bleepGain);\n\n    // Fast attack envelope - classic censor bleep snaps on quickly\n    const now = this.audioContext.currentTime;\n    this.bleepGain.gain.setValueAtTime(0, now);\n    this.bleepGain.gain.linearRampToValueAtTime(this.BLEEP_VOLUME, now + this.BLEEP_ATTACK);\n\n    // Start both oscillators\n    this.bleepOscillator.start(now);\n    oscillator2.start(now);\n\n    // Store reference to second oscillator for cleanup\n    (this.bleepOscillator as any)._secondOscillator = oscillator2;\n    (this.bleepOscillator as any)._mixer = mixer;\n  }\n\n  private stopBleep(): void {\n    this.isBleeping = false;\n\n    if (!this.audioContext || !this.bleepGain || !this.bleepOscillator) return;\n\n    // Smooth release to avoid clicks\n    const now = this.audioContext.currentTime;\n    this.bleepGain.gain.setValueAtTime(this.bleepGain.gain.value, now);\n    this.bleepGain.gain.linearRampToValueAtTime(0, now + this.BLEEP_RELEASE);\n\n    // Stop and disconnect after release completes\n    const oscillator = this.bleepOscillator;\n    const oscillator2 = (oscillator as any)._secondOscillator;\n    const mixer = (oscillator as any)._mixer;\n\n    setTimeout(() => {\n      try {\n        oscillator.stop();\n        oscillator.disconnect();\n        if (oscillator2) {\n          oscillator2.stop();\n          oscillator2.disconnect();\n        }\n        if (mixer) {\n          mixer.disconnect();\n        }\n      } catch (e) {\n        // Already stopped\n      }\n    }, this.BLEEP_RELEASE * 1000 + 10);\n\n    this.bleepOscillator = null;\n  }\n\n  // Update intervals (e.g., when preferences change)\n  updateIntervals(intervals: MuteInterval[]): void {\n    this.muteIntervals = intervals;\n    this.muteIntervals.sort((a, b) => a.start - b.start);\n  }\n\n  // Update filter mode\n  updateMode(mode: FilterMode): void {\n    this.filterMode = mode;\n\n    // Initialize bleep gain if switching to bleep mode\n    if (mode === 'bleep' && this.audioContext && !this.bleepGain) {\n      this.bleepGain = this.audioContext.createGain();\n      this.bleepGain.gain.value = 0;\n      this.bleepGain.connect(this.audioContext.destination);\n    }\n  }\n\n  // Get current state\n  getState(): {\n    isActive: boolean;\n    isMuted: boolean;\n    intervalCount: number;\n    filterMode: FilterMode;\n  } {\n    return {\n      isActive: this.isActive,\n      isMuted: this.isMuted,\n      intervalCount: this.muteIntervals.length,\n      filterMode: this.filterMode,\n    };\n  }\n\n  // Check if filtering is active\n  isFiltering(): boolean {\n    return this.isActive;\n  }\n\n  // Get all intervals (for debugging/display)\n  getIntervals(): MuteInterval[] {\n    return [...this.muteIntervals];\n  }\n}\n","import { ProfanityWord, SeverityLevel } from '../types';\n\n// Comprehensive profanity list with severity levels\n// Severity: mild (common/casual), moderate (offensive), severe (highly offensive), religious (religious terms)\n\nexport const PROFANITY_LIST: ProfanityWord[] = [\n  // Religious - opt-in category for religious terms some users may want filtered\n  { word: 'jesus', severity: 'religious' },\n  { word: 'jesus christ', severity: 'religious' },\n  { word: 'jesus fucking christ', severity: 'religious' },\n  { word: 'christ', severity: 'religious' },\n  { word: 'christ almighty', severity: 'religious' },\n  { word: 'god', severity: 'religious' },\n  { word: 'oh my god', severity: 'religious' },\n  { word: 'omg', severity: 'religious' },\n  { word: 'oh god', severity: 'religious' },\n  { word: 'my god', severity: 'religious' },\n  { word: 'for gods sake', severity: 'religious' },\n  { word: 'for god\\'s sake', severity: 'religious' },\n  { word: 'god almighty', severity: 'religious' },\n  { word: 'swear to god', severity: 'religious' },\n  { word: 'i swear to god', severity: 'religious' },\n\n  // Goddamn variations - all spellings and spacings\n  { word: 'goddamn', severity: 'religious' },\n  { word: 'goddamned', severity: 'religious' },\n  { word: 'goddamnit', severity: 'religious' },\n  { word: 'goddammit', severity: 'religious' },\n  { word: 'goddamit', severity: 'religious' },\n  { word: 'goddam', severity: 'religious' },\n  { word: 'goddams', severity: 'religious' },\n  { word: 'god damn', severity: 'religious' },\n  { word: 'god damned', severity: 'religious' },\n  { word: 'god damnit', severity: 'religious' },\n  { word: 'god dammit', severity: 'religious' },\n  { word: 'god damn it', severity: 'religious' },\n  { word: 'god-damn', severity: 'religious' },\n  { word: 'god-damned', severity: 'religious' },\n  { word: 'god-damnit', severity: 'religious' },\n  { word: 'god-dammit', severity: 'religious' },\n  { word: 'godd*mn', severity: 'religious' },\n  { word: 'g*ddamn', severity: 'religious' },\n  { word: 'gd', severity: 'religious' },\n  { word: 'gdamn', severity: 'religious' },\n  { word: 'gotdamn', severity: 'religious' },\n  { word: 'gotdam', severity: 'religious' },\n  { word: 'got damn', severity: 'religious' },\n  { word: 'got dam', severity: 'religious' },\n  { word: 'gahdamn', severity: 'religious' },\n  { word: 'gawddamn', severity: 'religious' },\n  { word: 'gahdam', severity: 'religious' },\n\n  // Lord variations\n  { word: 'lord', severity: 'religious' },\n  { word: 'oh lord', severity: 'religious' },\n  { word: 'dear lord', severity: 'religious' },\n  { word: 'good lord', severity: 'religious' },\n  { word: 'lord almighty', severity: 'religious' },\n  { word: 'lord have mercy', severity: 'religious' },\n  { word: 'lordy', severity: 'religious' },\n  { word: 'lawdy', severity: 'religious' },\n  { word: 'lawd', severity: 'religious' },\n  { word: 'oh lawd', severity: 'religious' },\n\n  // Holy variations\n  { word: 'holy', severity: 'religious' },\n  { word: 'holy shit', severity: 'religious' },\n  { word: 'holy crap', severity: 'religious' },\n  { word: 'holy hell', severity: 'religious' },\n  { word: 'holy fuck', severity: 'religious' },\n  { word: 'holy cow', severity: 'religious' },\n  { word: 'holy smokes', severity: 'religious' },\n  { word: 'holy moly', severity: 'religious' },\n  { word: 'holy mother', severity: 'religious' },\n  { word: 'holy mother of god', severity: 'religious' },\n  { word: 'for christ\\'s sake', severity: 'religious' },\n  { word: 'for christs sake', severity: 'religious' },\n  { word: 'chrissake', severity: 'religious' },\n  { word: 'crissake', severity: 'religious' },\n\n  // Severe\n  { word: 'fuck', severity: 'severe' },\n  { word: 'fucking', severity: 'severe' },\n  { word: 'fucked', severity: 'severe' },\n  { word: 'fucker', severity: 'severe' },\n  { word: 'fuckers', severity: 'severe' },\n  { word: 'fucks', severity: 'severe' },\n  { word: 'motherfucker', severity: 'severe' },\n  { word: 'motherfucking', severity: 'severe' },\n  { word: 'motherfuckers', severity: 'severe' },\n  { word: 'cunt', severity: 'severe' },\n  { word: 'cunts', severity: 'severe' },\n  { word: 'nigger', severity: 'severe' },\n  { word: 'niggers', severity: 'severe' },\n  { word: 'nigga', severity: 'severe' },\n  { word: 'niggas', severity: 'severe' },\n  { word: 'faggot', severity: 'severe' },\n  { word: 'faggots', severity: 'severe' },\n  { word: 'fag', severity: 'severe' },\n  { word: 'fags', severity: 'severe' },\n  { word: 'retard', severity: 'severe' },\n  { word: 'retarded', severity: 'severe' },\n  { word: 'retards', severity: 'severe' },\n\n  // Moderate\n  { word: 'shit', severity: 'moderate' },\n  { word: 'shits', severity: 'moderate' },\n  { word: 'shitty', severity: 'moderate' },\n  { word: 'bullshit', severity: 'moderate' },\n  { word: 'horseshit', severity: 'moderate' },\n  { word: 'shithead', severity: 'moderate' },\n  { word: 'shitheads', severity: 'moderate' },\n  { word: 'ass', severity: 'moderate' },\n  { word: 'asses', severity: 'moderate' },\n  { word: 'asshole', severity: 'moderate' },\n  { word: 'assholes', severity: 'moderate' },\n  { word: 'bastard', severity: 'moderate' },\n  { word: 'bastards', severity: 'moderate' },\n  { word: 'bitch', severity: 'moderate' },\n  { word: 'bitches', severity: 'moderate' },\n  { word: 'bitchy', severity: 'moderate' },\n  { word: 'cock', severity: 'moderate' },\n  { word: 'cocks', severity: 'moderate' },\n  { word: 'cocksucker', severity: 'moderate' },\n  { word: 'cocksuckers', severity: 'moderate' },\n  { word: 'dick', severity: 'moderate' },\n  { word: 'dicks', severity: 'moderate' },\n  { word: 'dickhead', severity: 'moderate' },\n  { word: 'dickheads', severity: 'moderate' },\n  { word: 'pussy', severity: 'moderate' },\n  { word: 'pussies', severity: 'moderate' },\n  { word: 'prick', severity: 'moderate' },\n  { word: 'pricks', severity: 'moderate' },\n  { word: 'slut', severity: 'moderate' },\n  { word: 'sluts', severity: 'moderate' },\n  { word: 'slutty', severity: 'moderate' },\n  { word: 'whore', severity: 'moderate' },\n  { word: 'whores', severity: 'moderate' },\n  { word: 'twat', severity: 'moderate' },\n  { word: 'twats', severity: 'moderate' },\n  { word: 'wanker', severity: 'moderate' },\n  { word: 'wankers', severity: 'moderate' },\n  { word: 'bollocks', severity: 'moderate' },\n\n  // Mild\n  { word: 'damn', severity: 'mild' },\n  { word: 'damned', severity: 'mild' },\n  { word: 'dammit', severity: 'mild' },\n  { word: 'damnit', severity: 'mild' },\n  { word: 'hell', severity: 'mild' },\n  { word: 'crap', severity: 'mild' },\n  { word: 'crappy', severity: 'mild' },\n  { word: 'piss', severity: 'mild' },\n  { word: 'pissed', severity: 'mild' },\n  { word: 'pissing', severity: 'mild' },\n  { word: 'suck', severity: 'mild' },\n  { word: 'sucks', severity: 'mild' },\n  { word: 'sucked', severity: 'mild' },\n  { word: 'balls', severity: 'mild' },\n  { word: 'butt', severity: 'mild' },\n  { word: 'butthole', severity: 'mild' },\n  { word: 'screw', severity: 'mild' },\n  { word: 'screwed', severity: 'mild' },\n  { word: 'douche', severity: 'mild' },\n  { word: 'douchebag', severity: 'mild' },\n  { word: 'douchebags', severity: 'mild' },\n];\n\n// Create a Map for O(1) lookup\nexport const PROFANITY_MAP: Map<string, SeverityLevel> = new Map(\n  PROFANITY_LIST.map((item) => [item.word.toLowerCase(), item.severity])\n);\n\n// Safe words that contain profanity substrings but are NOT profane\n// This prevents false positives like \"class\" (contains \"ass\"), \"hello\" (contains \"hell\")\nexport const SAFE_WORDS: Set<string> = new Set([\n  // Words containing \"ass\"\n  'class', 'classes', 'classic', 'classical', 'classics', 'classify', 'classified',\n  'classification', 'classmate', 'classmates', 'classroom', 'classrooms', 'classy',\n  'grass', 'grassy', 'grassland', 'grasshopper',\n  'pass', 'passed', 'passes', 'passing', 'passable', 'passage', 'passages',\n  'passenger', 'passengers', 'passport', 'passports', 'password', 'passwords',\n  'bypass', 'bypassed', 'bypasses', 'bypassing',\n  'compass', 'compasses',\n  'bass', 'bassist', 'bassline',\n  'mass', 'masses', 'massive', 'massively', 'massacre',\n  'brass', 'brassy',\n  'glass', 'glasses', 'glassy', 'glassware',\n  'sass', 'sassy', 'sassafras',\n  'lass', 'lassie', 'lasso',\n  'cassette', 'cassettes', 'casserole',\n  'assassin', 'assassins', 'assassinate', 'assassination',\n  'embassy', 'embassies', 'ambassador', 'ambassadors',\n  'harass', 'harassed', 'harassing', 'harassment',\n  'amass', 'amassed', 'amassing',\n  'morass',\n  'trespass', 'trespassed', 'trespassing', 'trespasser',\n  'carcass', 'carcasses',\n  'canvas', 'canvases', 'canvass', 'canvassed',\n  'molasses',\n  'assume', 'assumed', 'assumes', 'assuming', 'assumption', 'assumptions',\n  'assure', 'assured', 'assures', 'assuring', 'assurance',\n  'assess', 'assessed', 'assesses', 'assessing', 'assessment', 'assessments',\n  'asset', 'assets',\n  'assign', 'assigned', 'assigns', 'assigning', 'assignment', 'assignments',\n  'assist', 'assisted', 'assists', 'assisting', 'assistant', 'assistants', 'assistance',\n  'associate', 'associated', 'associates', 'associating', 'association', 'associations',\n  'assort', 'assorted', 'assortment',\n\n  // Words containing \"hell\"\n  'hello', 'hellos',\n  'shell', 'shells', 'shelled', 'shelling', 'shellfish', 'bombshell',\n  'nutshell', 'eggshell', 'seashell', 'clamshell',\n  'dwell', 'dwells', 'dwelled', 'dwelling', 'dwellings',\n  'swell', 'swells', 'swelled', 'swelling', 'swollen',\n  'well', 'wells', 'wellness', 'farewell', 'stairwell',\n  'spell', 'spells', 'spelled', 'spelling', 'misspell', 'misspelled',\n  'smell', 'smells', 'smelled', 'smelling', 'smelly',\n  'bell', 'bells', 'doorbell', 'bellhop', 'bluebell', 'dumbbell', 'barbell',\n  'cell', 'cells', 'cellular', 'cellar', 'cellars',\n  'fell', 'fella', 'fellas', 'fellow', 'fellows', 'fellowship',\n  'jell', 'jelly', 'jellyfish',\n  'tell', 'tells', 'telling', 'teller', 'storytelling', 'foretell',\n  'sell', 'sells', 'selling', 'seller', 'sellers', 'bestseller', 'bestselling',\n  'yell', 'yells', 'yelled', 'yelling',\n  'propel', 'propelled', 'propeller', 'propelling',\n  'excel', 'excels', 'excelled', 'excelling', 'excellent', 'excellence',\n  'expel', 'expels', 'expelled', 'expelling',\n  'compel', 'compels', 'compelled', 'compelling',\n  'repel', 'repels', 'repelled', 'repelling', 'repellent',\n  'rebellion', 'rebellious', 'rebel', 'rebels', 'rebelled',\n  'hellenic', 'hellenistic',\n\n  // Words containing \"damn\"\n  // Note: \"goddamn\" is NOT here - it IS profanity\n  'amsterdam',\n  'macadam', 'madame', 'madam',\n\n  // Words containing \"cock\"\n  'peacock', 'peacocks',\n  'cockpit', 'cockpits',\n  'cocktail', 'cocktails',\n  'cockatoo', 'cockatoos',\n  'cockerel',\n  'hancock', 'hitchcock', 'babcock', 'woodcock',\n  'stopcock', 'weathercock',\n\n  // Words containing \"dick\"\n  'dickens',\n  'benedict', 'benediction',\n  'predict', 'predicts', 'predicted', 'predicting', 'prediction', 'predictions',\n  'addict', 'addicts', 'addicted', 'addicting', 'addiction', 'addictions', 'addictive',\n  'verdict', 'verdicts',\n  'indict', 'indicts', 'indicted', 'indicting', 'indictment',\n  'contradict', 'contradicts', 'contradicted', 'contradicting', 'contradiction',\n  'dictionary', 'dictionaries', 'diction',\n  'dictate', 'dictates', 'dictated', 'dictating', 'dictation', 'dictator',\n  'edict', 'edicts',\n  'jurisdiction',\n\n  // Words containing \"crap\"\n  'scrap', 'scraps', 'scrapped', 'scrapping', 'scrappy', 'scrapbook', 'scrapyard',\n\n  // Words containing \"piss\"\n  'mississippi',\n\n  // Words containing \"tit\"\n  'title', 'titles', 'titled', 'titling', 'subtitle', 'subtitles', 'subtitled',\n  'entitle', 'entitled', 'entitles', 'entitling', 'entitlement',\n  'constitution', 'constitutional', 'constitutions',\n  'institution', 'institutional', 'institutions',\n  'restitution',\n  'stitute', 'substitute', 'substitutes', 'substituted', 'substitution',\n  'institute', 'institutes', 'instituted', 'institution',\n  'prostitute', 'prostitutes', 'prostitution', // This might be context-dependent\n  'titan', 'titans', 'titanic',\n  'appetite', 'appetites', 'appetizer', 'appetizers',\n  'competition', 'competitions', 'competitive', 'competitor', 'competitors',\n  'petition', 'petitions', 'petitioned', 'petitioning',\n  'repetition', 'repetitions', 'repetitive',\n  'partition', 'partitions', 'partitioned',\n  'quantity', 'quantities', 'quantitative',\n  'identity', 'identities',\n  'entity', 'entities',\n  'utility', 'utilities',\n  'fertility', 'infertility',\n\n  // Words containing \"cum\"\n  'document', 'documents', 'documented', 'documenting', 'documentation', 'documentary',\n  'circumstance', 'circumstances', 'circumstantial',\n  'circumference',\n  'accumulate', 'accumulated', 'accumulates', 'accumulating', 'accumulation',\n  'cucumber', 'cucumbers',\n  'incumbent',\n  'succumb', 'succumbed', 'succumbing',\n\n  // Words containing \"fag\"\n  'faggot', // This IS profanity - keeping for reference\n\n  // Words containing \"sex\" - often legitimate\n  'sextant', 'sextet', 'sextuple',\n\n  // Words containing \"ho\" / \"hoe\"\n  'shoe', 'shoes', 'shoed', 'shoeing', 'horseshoe',\n  'hoe', 'hoes', 'hoeing', // gardening tool\n  'whole', 'wholesome', 'wholesale', 'wholly',\n  'honest', 'honestly', 'honesty', 'dishonest',\n  'honor', 'honors', 'honored', 'honoring', 'honorable', 'honorary', 'dishonor',\n  'hope', 'hopes', 'hoped', 'hoping', 'hopeful', 'hopefully', 'hopeless',\n  'home', 'homes', 'homed', 'homing', 'homeless', 'homemade', 'hometown', 'homework',\n  'horse', 'horses', 'horseback', 'horsepower',\n  'hotel', 'hotels',\n  'horizon', 'horizons', 'horizontal',\n  'hour', 'hours', 'hourly',\n  'house', 'houses', 'housed', 'housing', 'household', 'housewife', 'housekeeper',\n\n  // Words containing \"nig\"\n  'night', 'nights', 'nightly', 'nighttime', 'nightmare', 'nightmares', 'nightclub',\n  'tonight', 'overnight', 'midnight', 'goodnight', 'fortnight',\n  'knight', 'knights', 'knighthood',\n  'ignite', 'ignites', 'ignited', 'igniting', 'ignition',\n  'insignificant', 'significance', 'significant', 'significantly',\n\n  // Words containing \"nud\"\n  'nude', 'nudes', 'nudity', // Context-dependent, usually fine in art/medical context\n\n  // Words containing \"porn\"\n  // Most are actually related to pornography, so no safe words here\n\n  // Words containing \"anal\"\n  'analog', 'analogue', 'analogous', 'analogy', 'analogies',\n  'analysis', 'analyses', 'analyst', 'analysts', 'analytical', 'analyze', 'analyzed',\n  'banal',\n  'canal', 'canals',\n  'final', 'finals', 'finally', 'finalist', 'finalize', 'finalized',\n  'journal', 'journals', 'journalism', 'journalist', 'journalists',\n  'national', 'nationally', 'international', 'internationally',\n  'personal', 'personally', 'personality', 'personalities',\n  'professional', 'professionally', 'professionals',\n  'regional', 'regionally',\n  'original', 'originally', 'originals',\n  'criminal', 'criminally', 'criminals',\n  'terminal', 'terminals',\n  'cardinal', 'cardinals',\n  'signal', 'signals', 'signaled', 'signaling',\n\n  // Words containing \"nut\"\n  'minute', 'minutes', 'minutely',\n  'peanut', 'peanuts',\n  'coconut', 'coconuts',\n  'chestnut', 'chestnuts',\n  'walnut', 'walnuts',\n  'doughnut', 'doughnuts', 'donut', 'donuts',\n  'nutmeg',\n  'nutrition', 'nutritious', 'nutritional', 'nutrient', 'nutrients',\n\n  // Words containing \"god\" (for religious filter)\n  'godfather', 'godfathers', 'godmother', 'godmothers', 'godchild', 'godchildren',\n  'godson', 'godsons', 'goddaughter', 'goddaughters',\n  'godly', 'godliness', 'ungodly',\n  'goddess', 'goddesses',\n  'godspeed',\n  'godsend',\n\n  // Words containing \"lord\" (for religious filter)\n  'landlord', 'landlords', 'landlady',\n  'warlord', 'warlords',\n  'overlord', 'overlords',\n  'lordship',\n\n  // Words containing \"holy\" (for religious filter)\n  'holiday', 'holidays',\n  'wholly',\n\n  // Words containing \"christ\" (for religious filter)\n  'christen', 'christened', 'christening',\n  'christian', 'christians', 'christianity',\n  'christmas', 'christmastime',\n  'christopher',\n\n  // Words containing \"jesus\" (for religious filter)\n  // No common safe words\n\n  // Words containing \"hell\" that are already covered but adding more religious context\n  'hellfire', 'hellbound', // These ARE religious references, not safe words\n]);\n\n// Spelling variations mapping - normalizes common letter substitutions\n// Maps variant characters to their standard letter\nconst CHAR_SUBSTITUTIONS: Record<string, string> = {\n  // Common leetspeak / symbol substitutions\n  '0': 'o',\n  '1': 'i',\n  '3': 'e',\n  '4': 'a',\n  '5': 's',\n  '7': 't',\n  '8': 'b',\n  '@': 'a',\n  '$': 's',\n  '!': 'i',\n  '*': '', // Often used as censoring, remove it\n  '#': '', // Often used as censoring, remove it\n  '+': 't',\n  '(': 'c',\n  '<': 'c',\n  '|': 'i',\n  // Common letter swaps\n  'ph': 'f',\n  'ck': 'k',\n};\n\n// Multi-character substitutions (processed first)\nconst MULTI_CHAR_SUBSTITUTIONS: [string, string][] = [\n  ['ph', 'f'],\n  ['ck', 'k'],\n  ['kk', 'ck'],\n  ['cc', 'ck'],\n  ['xx', 'x'],\n];\n\n/**\n * Normalize a word by replacing common spelling variations with standard letters.\n * This helps detect words like \"f*ck\", \"sh!t\", \"a$$\", \"fvck\", etc.\n */\nexport function normalizeSpelling(text: string): string {\n  let normalized = text.toLowerCase();\n\n  // First, apply multi-character substitutions\n  for (const [from, to] of MULTI_CHAR_SUBSTITUTIONS) {\n    normalized = normalized.split(from).join(to);\n  }\n\n  // Then, apply single character substitutions\n  let result = '';\n  for (const char of normalized) {\n    result += CHAR_SUBSTITUTIONS[char] ?? char;\n  }\n\n  // Remove repeated characters that might be used to evade (e.g., \"fuuuck\" -> \"fuck\")\n  // But be careful not to break legitimate double letters\n  result = result.replace(/(.)\\1{2,}/g, '$1$1'); // Keep max 2 of same char\n\n  return result;\n}\n\n// Get all words of a specific severity\nexport function getWordsBySeverity(severity: SeverityLevel): string[] {\n  return PROFANITY_LIST\n    .filter((item) => item.severity === severity)\n    .map((item) => item.word);\n}\n\n// Check if a word is profanity (also checks normalized spelling)\nexport function isProfanity(word: string): boolean {\n  const lower = word.toLowerCase();\n  if (PROFANITY_MAP.has(lower)) return true;\n\n  // Also check normalized version for spelling variations\n  const normalized = normalizeSpelling(lower);\n  return PROFANITY_MAP.has(normalized);\n}\n\n// Get the severity of a word (also checks normalized spelling)\nexport function getSeverity(word: string): SeverityLevel | null {\n  const lower = word.toLowerCase();\n  const direct = PROFANITY_MAP.get(lower);\n  if (direct) return direct;\n\n  // Also check normalized version for spelling variations\n  const normalized = normalizeSpelling(lower);\n  return PROFANITY_MAP.get(normalized) || null;\n}\n\n// Check if a word is in the safe list (not profane despite containing profanity substring)\nexport function isSafeWord(word: string): boolean {\n  return SAFE_WORDS.has(word.toLowerCase());\n}\n\n// Find profanity within a longer word (e.g., \"fuck\" in \"motherfucker\")\n// Now checks against safe words to avoid false positives\n// Also checks normalized spellings (f*ck, sh!t, etc.)\nexport function findEmbeddedProfanity(\n  text: string\n): { word: string; severity: SeverityLevel; startIndex: number; endIndex: number }[] {\n  const lowerText = text.toLowerCase().trim();\n\n  // First, check if the entire text is a safe word - if so, return no matches\n  if (SAFE_WORDS.has(lowerText)) {\n    return [];\n  }\n\n  const results: {\n    word: string;\n    severity: SeverityLevel;\n    startIndex: number;\n    endIndex: number;\n  }[] = [];\n\n  // Check both original and normalized text\n  const normalizedText = normalizeSpelling(lowerText);\n  const textsToCheck = [lowerText];\n  if (normalizedText !== lowerText) {\n    textsToCheck.push(normalizedText);\n  }\n\n  for (const textToCheck of textsToCheck) {\n    for (const [word, severity] of PROFANITY_MAP) {\n      let index = textToCheck.indexOf(word);\n      while (index !== -1) {\n        // Check if the found substring is actually the whole word (exact match)\n        // or if it's embedded in a safe context\n        const isExactMatch = textToCheck === word;\n        const isWholeWord = (index === 0 || !/[a-z]/.test(textToCheck[index - 1])) &&\n                            (index + word.length === textToCheck.length || !/[a-z]/.test(textToCheck[index + word.length]));\n\n        // Only add if it's an exact match or a whole word within the text\n        // This prevents \"ass\" matching in \"class\" but allows \"ass\" in \"bad-ass\"\n        if (isExactMatch || isWholeWord) {\n          // Use original text indices for timing (approximate for normalized)\n          results.push({\n            word,\n            severity,\n            startIndex: index,\n            endIndex: index + word.length,\n          });\n        }\n\n        index = textToCheck.indexOf(word, index + 1);\n      }\n    }\n  }\n\n  // Sort by start index and remove duplicates (prefer longer matches)\n  results.sort((a, b) => a.startIndex - b.startIndex);\n\n  // Remove overlapping matches, keeping the longer one\n  const filtered: typeof results = [];\n  for (const match of results) {\n    const lastMatch = filtered[filtered.length - 1];\n    if (!lastMatch || match.startIndex >= lastMatch.endIndex) {\n      filtered.push(match);\n    } else if (match.endIndex - match.startIndex > lastMatch.endIndex - lastMatch.startIndex) {\n      filtered[filtered.length - 1] = match;\n    }\n  }\n\n  // Deduplicate by word (in case both original and normalized matched)\n  const seen = new Set<string>();\n  return filtered.filter(match => {\n    const key = `${match.word}-${match.startIndex}`;\n    if (seen.has(key)) return false;\n    seen.add(key);\n    return true;\n  });\n}\n","import {\n  TranscriptSegment,\n  Transcript,\n  MuteInterval,\n  UserPreferences,\n  SeverityLevel,\n  ProfanityMatch,\n} from '../types';\nimport {\n  PROFANITY_MAP,\n  findEmbeddedProfanity,\n  isSafeWord,\n} from './profanity-list';\n\nexport class TranscriptParser {\n  private preferences: UserPreferences;\n  private customBlacklistMap: Map<string, SeverityLevel>;\n  private customWhitelistSet: Set<string>;\n\n  constructor(preferences: UserPreferences) {\n    this.preferences = preferences;\n\n    // Build custom blacklist map (all custom words are severe by default)\n    this.customBlacklistMap = new Map(\n      preferences.customBlacklist.map((word) => [word.toLowerCase(), 'severe' as SeverityLevel])\n    );\n\n    // Build whitelist set\n    this.customWhitelistSet = new Set(\n      preferences.customWhitelist.map((word) => word.toLowerCase())\n    );\n  }\n\n  // Check if a severity level should be filtered based on preferences\n  private shouldFilterSeverity(severity: SeverityLevel): boolean {\n    return this.preferences.severityLevels[severity];\n  }\n\n  // Check if a word should be filtered (considering whitelist/blacklist)\n  private shouldFilterWord(word: string, severity: SeverityLevel): boolean {\n    const lowerWord = word.toLowerCase();\n\n    // Check whitelist first (user explicitly allowed)\n    if (this.customWhitelistSet.has(lowerWord)) {\n      return false;\n    }\n\n    // Check custom blacklist (always filter)\n    if (this.customBlacklistMap.has(lowerWord)) {\n      return true;\n    }\n\n    // Check severity level preference\n    return this.shouldFilterSeverity(severity);\n  }\n\n  // Get severity for a word (checking custom blacklist too)\n  private getWordSeverity(word: string): SeverityLevel | null {\n    const lowerWord = word.toLowerCase();\n\n    // Check custom blacklist first (takes priority over safe words)\n    if (this.customBlacklistMap.has(lowerWord)) {\n      return this.customBlacklistMap.get(lowerWord)!;\n    }\n\n    // Check if it's a safe word (e.g., \"class\" contains \"ass\" but is not profane)\n    if (isSafeWord(lowerWord)) {\n      return null;\n    }\n\n    // Check built-in profanity list\n    return PROFANITY_MAP.get(lowerWord) || null;\n  }\n\n  // Get precise timing using character-level data\n  private getCharacterLevelTiming(\n    segment: TranscriptSegment,\n    startIndex: number,\n    endIndex: number\n  ): { startTime: number; endTime: number } {\n    let startTime = segment.start_time;\n    let endTime = segment.end_time;\n\n    if (segment.characters && segment.characters.length > 0) {\n      // Use character-level timing for precision\n      // Find the first character of the word\n      const startChar = segment.characters[startIndex];\n      // Find the last character of the word (endIndex is exclusive, so -1)\n      const endChar = segment.characters[Math.min(endIndex - 1, segment.characters.length - 1)];\n\n      if (startChar) {\n        startTime = startChar.start;\n      }\n      if (endChar) {\n        endTime = endChar.end;\n      }\n\n      console.log(`[SafePlay Parser] Character timing: \"${segment.text.substring(startIndex, endIndex)}\" ` +\n        `chars[${startIndex}..${endIndex-1}] -> ${startTime.toFixed(3)}s - ${endTime.toFixed(3)}s`);\n    }\n\n    return { startTime, endTime };\n  }\n\n  // Find profanity matches in transcript segments\n  findProfanityMatches(segments: TranscriptSegment[]): ProfanityMatch[] {\n    const matches: ProfanityMatch[] = [];\n\n    for (let i = 0; i < segments.length; i++) {\n      const segment = segments[i];\n      const normalizedText = segment.text.toLowerCase().trim();\n\n      // Check for exact word match first\n      const exactSeverity = this.getWordSeverity(normalizedText);\n      if (exactSeverity && this.shouldFilterWord(normalizedText, exactSeverity)) {\n        // Use character-level timing for precision even on exact matches\n        const { startTime, endTime } = this.getCharacterLevelTiming(segment, 0, segment.text.length);\n\n        matches.push({\n          segmentIndex: i,\n          word: segment.text,\n          severity: exactSeverity,\n          startTime,\n          endTime,\n          isPartialMatch: false,\n        });\n        continue;\n      }\n\n      // Check for embedded profanity within longer words\n      const embeddedMatches = findEmbeddedProfanity(normalizedText);\n\n      // Also check custom blacklist for embedded matches\n      for (const [customWord] of this.customBlacklistMap) {\n        const index = normalizedText.indexOf(customWord);\n        if (index !== -1) {\n          embeddedMatches.push({\n            word: customWord,\n            severity: 'severe',\n            startIndex: index,\n            endIndex: index + customWord.length,\n          });\n        }\n      }\n\n      for (const embedded of embeddedMatches) {\n        if (!this.shouldFilterWord(embedded.word, embedded.severity)) {\n          continue;\n        }\n\n        // Use character-level timing for precision\n        const { startTime, endTime } = this.getCharacterLevelTiming(\n          segment,\n          embedded.startIndex,\n          embedded.endIndex\n        );\n\n        matches.push({\n          segmentIndex: i,\n          word: embedded.word,\n          severity: embedded.severity,\n          startTime,\n          endTime,\n          isPartialMatch: true,\n          matchedPortion: segment.text.substring(embedded.startIndex, embedded.endIndex),\n        });\n      }\n    }\n\n    return matches;\n  }\n\n  // Convert profanity matches to mute intervals with padding\n  createMuteIntervals(matches: ProfanityMatch[]): MuteInterval[] {\n    // Use asymmetric padding if available, otherwise fall back to symmetric\n    const paddingBeforeSeconds = (this.preferences.paddingBeforeMs ?? this.preferences.paddingMs) / 1000;\n    const paddingAfterSeconds = (this.preferences.paddingAfterMs ?? this.preferences.paddingMs) / 1000;\n\n    return matches.map((match) => {\n      const interval = {\n        start: Math.max(0, match.startTime - paddingBeforeSeconds),\n        end: match.endTime + paddingAfterSeconds,\n        word: match.word,\n        severity: match.severity,\n      };\n\n      console.log(`[SafePlay Parser] Mute interval: \"${match.word}\" ` +\n        `${interval.start.toFixed(3)}s - ${interval.end.toFixed(3)}s ` +\n        `(padding: -${paddingBeforeSeconds * 1000}ms / +${paddingAfterSeconds * 1000}ms)`);\n\n      return interval;\n    });\n  }\n\n  // Merge overlapping or close intervals\n  mergeIntervals(intervals: MuteInterval[]): MuteInterval[] {\n    if (intervals.length === 0) {\n      return [];\n    }\n\n    // Sort by start time\n    const sorted = [...intervals].sort((a, b) => a.start - b.start);\n    const mergeThresholdSeconds = this.preferences.mergeThresholdMs / 1000;\n\n    const merged: MuteInterval[] = [sorted[0]];\n\n    for (let i = 1; i < sorted.length; i++) {\n      const current = sorted[i];\n      const last = merged[merged.length - 1];\n\n      // Merge if overlapping or within threshold\n      if (current.start <= last.end + mergeThresholdSeconds) {\n        // Extend the end time and combine words\n        last.end = Math.max(last.end, current.end);\n        // Keep the more severe classification\n        if (this.severityRank(current.severity) > this.severityRank(last.severity)) {\n          last.severity = current.severity;\n        }\n        // Append word if different\n        if (!last.word.includes(current.word)) {\n          last.word = `${last.word}, ${current.word}`;\n        }\n      } else {\n        merged.push({ ...current });\n      }\n    }\n\n    return merged;\n  }\n\n  private severityRank(severity: SeverityLevel): number {\n    const ranks: Record<SeverityLevel, number> = {\n      mild: 1,\n      religious: 2,\n      moderate: 3,\n      severe: 4,\n    };\n    return ranks[severity];\n  }\n\n  // Main parsing function: transcript -> mute intervals\n  parse(transcript: Transcript): MuteInterval[] {\n    const matches = this.findProfanityMatches(transcript.segments);\n    const intervals = this.createMuteIntervals(matches);\n    return this.mergeIntervals(intervals);\n  }\n}\n\n// Utility function for quick parsing\nexport function parseTranscript(\n  transcript: Transcript,\n  preferences: UserPreferences\n): MuteInterval[] {\n  const parser = new TranscriptParser(preferences);\n  return parser.parse(transcript);\n}\n","// Controller for managing video filtering on watch pages\nimport { Transcript, MuteInterval, UserPreferences } from '../types';\nimport { AudioFilter } from '../filter/audio-filter';\nimport { parseTranscript } from '../filter/transcript-parser';\n\n// Check if the extension context is still valid\nfunction isExtensionContextValid(): boolean {\n  try {\n    return !!chrome.runtime?.id;\n  } catch {\n    return false;\n  }\n}\n\nexport type FilterStatus =\n  | 'idle'\n  | 'loading'\n  | 'processing'\n  | 'active'\n  | 'error'\n  | 'disabled';\n\nexport interface VideoControllerState {\n  status: FilterStatus;\n  progress: number;\n  error?: string;\n  intervalCount: number;\n  currentlyMuting: boolean;\n}\n\ninterface VideoControllerOptions {\n  onStateChange?: (state: VideoControllerState) => void;\n  debug?: boolean;\n}\n\nexport class VideoController {\n  private youtubeId: string | null = null;\n  private video: HTMLVideoElement | null = null;\n  private audioFilter: AudioFilter;\n  private transcript: Transcript | null = null;\n  private muteIntervals: MuteInterval[] = [];\n  private preferences: UserPreferences | null = null;\n  private status: FilterStatus = 'idle';\n  private progress = 0;\n  private error?: string;\n  private options: VideoControllerOptions;\n  private statusOverlay: HTMLElement | null = null;\n\n  constructor(options: VideoControllerOptions = {}) {\n    this.options = options;\n    this.audioFilter = new AudioFilter({\n      onMuteStart: (interval) => this.onMuteStart(interval),\n      onMuteEnd: () => this.onMuteEnd(),\n    });\n  }\n\n  // Initialize controller for a video\n  async initialize(\n    youtubeId: string,\n    preferences: UserPreferences\n  ): Promise<void> {\n    this.youtubeId = youtubeId;\n    this.preferences = preferences;\n    this.updateStatus('idle');\n\n    // Find video element\n    this.video = this.findVideoElement();\n    if (!this.video) {\n      this.log('Video element not found, waiting...');\n      await this.waitForVideo();\n    }\n\n    if (!this.video) {\n      this.updateStatus('error', 0, 'Could not find video element');\n      return;\n    }\n\n    this.log('Video controller initialized for:', youtubeId);\n  }\n\n  // Request and apply filter\n  async applyFilter(): Promise<void> {\n    if (!this.youtubeId || !this.video || !this.preferences) {\n      this.log('Cannot apply filter: missing required data');\n      return;\n    }\n\n    if (!this.preferences.enabled) {\n      this.updateStatus('disabled');\n      return;\n    }\n\n    try {\n      this.updateStatus('loading');\n\n      // Check if extension context is still valid\n      if (!isExtensionContextValid()) {\n        this.updateStatus('error', 0, 'Extension reloaded. Please refresh the page.');\n        return;\n      }\n\n      // Request transcript from background script\n      const response = await chrome.runtime.sendMessage({\n        type: 'GET_FILTER',\n        payload: { youtubeId: this.youtubeId },\n      });\n\n      // Handle extension context invalidated during request\n      if (!response) {\n        this.updateStatus('error', 0, 'Extension reloaded. Please refresh the page.');\n        return;\n      }\n\n      if (!response.success) {\n        throw new Error(response.error || 'Failed to get transcript');\n      }\n\n      // If processing, we'll receive progress updates\n      if (response.data.status === 'processing') {\n        this.updateStatus('processing', response.data.progress || 0);\n        return; // Background will send completion message\n      }\n\n      // Parse transcript and create mute intervals\n      this.transcript = response.data.transcript;\n      await this.processTranscript();\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Unknown error';\n      this.updateStatus('error', 0, message);\n      this.log('Filter error:', error);\n    }\n  }\n\n  // Process transcript and start filtering\n  async processTranscript(): Promise<void> {\n    if (!this.transcript || !this.preferences || !this.video) {\n      return;\n    }\n\n    // Parse transcript for profanity\n    this.muteIntervals = parseTranscript(this.transcript, this.preferences);\n    this.log('Found', this.muteIntervals.length, 'mute intervals');\n\n    if (this.muteIntervals.length === 0) {\n      this.updateStatus('active');\n      this.log('No profanity detected in video');\n      return;\n    }\n\n    // Initialize and start audio filter\n    this.audioFilter.initialize(\n      this.video,\n      this.muteIntervals,\n      this.preferences.filterMode\n    );\n    this.audioFilter.start();\n\n    this.updateStatus('active');\n    this.showStatusOverlay();\n  }\n\n  // Handle transcript received from background\n  onTranscriptReceived(transcript: Transcript): void {\n    this.transcript = transcript;\n    this.processTranscript();\n  }\n\n  // Handle processing progress\n  onProcessingProgress(progress: number): void {\n    this.updateStatus('processing', progress);\n  }\n\n  // Handle processing error\n  onProcessingError(error: string): void {\n    this.updateStatus('error', 0, error);\n  }\n\n  // Stop filtering\n  stop(): void {\n    this.audioFilter.stop();\n    this.hideStatusOverlay();\n    this.updateStatus('idle');\n  }\n\n  // Resume filtering (re-start audio filter)\n  resume(): void {\n    if (!this.video || this.muteIntervals.length === 0) {\n      return;\n    }\n    this.audioFilter.start();\n    this.updateStatus('active');\n    this.showStatusOverlay();\n  }\n\n  // Update preferences\n  updatePreferences(preferences: UserPreferences): void {\n    this.preferences = preferences;\n\n    if (!preferences.enabled) {\n      this.stop();\n      return;\n    }\n\n    // Re-parse with new preferences\n    if (this.transcript) {\n      this.muteIntervals = parseTranscript(this.transcript, preferences);\n      this.audioFilter.updateIntervals(this.muteIntervals);\n      this.audioFilter.updateMode(preferences.filterMode);\n    }\n  }\n\n  // Get current state\n  getState(): VideoControllerState {\n    const filterState = this.audioFilter.getState();\n    return {\n      status: this.status,\n      progress: this.progress,\n      error: this.error,\n      intervalCount: filterState.intervalCount,\n      currentlyMuting: filterState.isMuted,\n    };\n  }\n\n  // Get mute intervals for caption filtering\n  getMuteIntervals(): MuteInterval[] {\n    return this.muteIntervals;\n  }\n\n  // Find the YouTube video element\n  private findVideoElement(): HTMLVideoElement | null {\n    // Main player video\n    const selectors = [\n      'video.html5-main-video',\n      'video.video-stream',\n      '#movie_player video',\n      'ytd-player video',\n      'video',\n    ];\n\n    for (const selector of selectors) {\n      const video = document.querySelector<HTMLVideoElement>(selector);\n      if (video && video.src) {\n        return video;\n      }\n    }\n\n    return null;\n  }\n\n  // Wait for video element to appear\n  private waitForVideo(timeout = 10000): Promise<HTMLVideoElement | null> {\n    return new Promise((resolve) => {\n      const startTime = Date.now();\n\n      const check = () => {\n        this.video = this.findVideoElement();\n        if (this.video) {\n          resolve(this.video);\n          return;\n        }\n\n        if (Date.now() - startTime > timeout) {\n          resolve(null);\n          return;\n        }\n\n        requestAnimationFrame(check);\n      };\n\n      check();\n    });\n  }\n\n  // Update status and notify listeners\n  private updateStatus(\n    status: FilterStatus,\n    progress = 0,\n    error?: string\n  ): void {\n    this.status = status;\n    this.progress = progress;\n    this.error = error;\n\n    if (this.options.onStateChange) {\n      this.options.onStateChange(this.getState());\n    }\n  }\n\n  // Show status overlay on video\n  private showStatusOverlay(): void {\n    if (this.statusOverlay) return;\n\n    const playerContainer = document.querySelector('#movie_player');\n    if (!playerContainer) return;\n\n    this.statusOverlay = document.createElement('div');\n    this.statusOverlay.className = 'safeplay-status-overlay';\n    this.statusOverlay.innerHTML = `\n      <div class=\"safeplay-status-badge\">\n        <svg class=\"safeplay-status-icon\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n          <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z\"/>\n        </svg>\n        <span>SafePlay Active</span>\n      </div>\n    `;\n\n    playerContainer.appendChild(this.statusOverlay);\n\n    // Auto-hide after 3 seconds\n    setTimeout(() => {\n      this.statusOverlay?.classList.add('safeplay-status-hidden');\n    }, 3000);\n  }\n\n  // Hide status overlay\n  private hideStatusOverlay(): void {\n    if (this.statusOverlay) {\n      this.statusOverlay.remove();\n      this.statusOverlay = null;\n    }\n  }\n\n  // Event handlers\n  private onMuteStart(interval: MuteInterval): void {\n    this.log('Muting:', interval.word);\n    this.notifyStateChange();\n  }\n\n  private onMuteEnd(): void {\n    this.notifyStateChange();\n  }\n\n  private notifyStateChange(): void {\n    if (this.options.onStateChange) {\n      this.options.onStateChange(this.getState());\n    }\n  }\n\n  // Debug logging\n  private log(...args: unknown[]): void {\n    if (this.options.debug) {\n      console.log('[SafePlay Controller]', ...args);\n    }\n  }\n}\n","/**\n * Smooth Progress Animator\n *\n * Creates a smooth animated progress that:\n * - Only animates toward the actual server-reported progress\n * - Never exceeds the target (no overshooting)\n * - Smoothly interpolates between server updates\n * - Stays conservative to avoid stalling at high percentages\n */\n\ntype ProgressCallback = (progress: number, text: string) => void;\n\nexport class SmoothProgressAnimator {\n  private displayProgress = 0;\n  private targetProgress = 0;\n  private isComplete = false;\n  private animationId: number | null = null;\n  private callback: ProgressCallback;\n  private baseText: string;\n\n  // Configuration - conservative settings\n  private readonly ANIMATION_INTERVAL = 100; // ms between frames\n  private readonly CATCH_UP_SPEED = 0.15; // How fast to catch up (15% of gap per frame)\n  private readonly MIN_INCREMENT = 0.2; // Minimum progress increment per frame\n  private readonly MAX_INCREMENT = 3; // Maximum progress increment per frame\n\n  constructor(callback: ProgressCallback, baseText = 'Analyzing') {\n    this.callback = callback;\n    this.baseText = baseText;\n  }\n\n  /**\n   * Start the animation\n   */\n  start(): void {\n    this.displayProgress = 0;\n    this.targetProgress = 0;\n    this.isComplete = false;\n    this.startAnimation();\n    // Initial callback\n    this.callback(0, `${this.baseText} 0%`);\n  }\n\n  /**\n   * Update the target progress from server\n   * The display will smoothly animate toward this target\n   */\n  setTarget(progress: number): void {\n    // Never let target go backwards (unless resetting)\n    this.targetProgress = Math.max(progress, this.targetProgress);\n  }\n\n  /**\n   * Mark as complete - animate to 100%\n   */\n  complete(): void {\n    this.isComplete = true;\n    this.targetProgress = 100;\n  }\n\n  /**\n   * Stop the animation\n   */\n  stop(): void {\n    if (this.animationId !== null) {\n      clearInterval(this.animationId);\n      this.animationId = null;\n    }\n  }\n\n  /**\n   * Get current display progress\n   */\n  getProgress(): number {\n    return this.displayProgress;\n  }\n\n  private startAnimation(): void {\n    if (this.animationId !== null) return;\n\n    this.animationId = window.setInterval(() => {\n      this.tick();\n    }, this.ANIMATION_INTERVAL);\n  }\n\n  private tick(): void {\n    const gap = this.targetProgress - this.displayProgress;\n\n    // Only animate if we're behind the target\n    if (gap > 0.5) {\n      // Calculate increment - proportional to gap but clamped\n      let increment = gap * this.CATCH_UP_SPEED;\n      increment = Math.max(increment, this.MIN_INCREMENT);\n      increment = Math.min(increment, this.MAX_INCREMENT);\n\n      // Apply increment but never exceed target\n      this.displayProgress = Math.min(\n        this.displayProgress + increment,\n        this.targetProgress\n      );\n\n      // Round for display\n      const displayValue = Math.round(this.displayProgress);\n      this.callback(displayValue, `${this.baseText} ${displayValue}%`);\n    }\n\n    // Stop animation when complete and reached 100%\n    if (this.isComplete && this.displayProgress >= 99.5) {\n      this.displayProgress = 100;\n      this.callback(100, `${this.baseText} 100%`);\n      this.stop();\n    }\n  }\n}\n","// SafePlay Caption Filter - Hijacks YouTube's native captions\nimport { UserPreferences, MuteInterval, SeverityLevel } from '../types';\nimport { findEmbeddedProfanity, isSafeWord } from '../filter/profanity-list';\n\nconst DEBUG = true;\n\nfunction log(...args: unknown[]): void {\n  if (DEBUG) {\n    console.log('[SafePlay:Captions]', ...args);\n  }\n}\n\nexport interface CaptionFilterOptions {\n  debug?: boolean;\n}\n\n// Patterns for YouTube's pre-censored words (e.g., f******, s***, b****)\n// Note: We use (?=\\s|[.,!?;:'\")\\-]|$) instead of \\b at the end because\n// word boundaries don't work after non-word characters like * or #\nconst WORD_END = '(?=\\\\s|[.,!?;:\\'\"\\\\)\\\\-]|$)';\n\nconst CENSORED_PATTERNS: { pattern: RegExp; severity: SeverityLevel }[] = [\n  // F-word variations (f***, f**k, f**king, f******)\n  { pattern: new RegExp(`\\\\bf+[\\\\*\\\\#\\\\-\\\\_]+(?:ck(?:ing|ed|er|ers|s)?)?${WORD_END}`, 'gi'), severity: 'severe' },\n  { pattern: new RegExp(`\\\\bf+u+[\\\\*\\\\#\\\\-\\\\_]+k*(?:ing|ed|er|ers|s)?${WORD_END}`, 'gi'), severity: 'severe' },\n  { pattern: new RegExp(`\\\\bf[\\\\*\\\\#\\\\-\\\\_]{2,}(?:ing|ed|er|ers|s)?${WORD_END}`, 'gi'), severity: 'severe' },\n\n  // S-word variations (s***, sh*t, s**t)\n  { pattern: new RegExp(`\\\\bs+h+[\\\\*\\\\#\\\\-\\\\_]+t*(?:ty|s|head|heads)?${WORD_END}`, 'gi'), severity: 'moderate' },\n  { pattern: new RegExp(`\\\\bs[\\\\*\\\\#\\\\-\\\\_]{2,}t?${WORD_END}`, 'gi'), severity: 'moderate' },\n\n  // B-word variations (b**ch, b****)\n  { pattern: new RegExp(`\\\\bb+[\\\\*\\\\#\\\\-\\\\_]+(?:tch(?:es|y)?)?${WORD_END}`, 'gi'), severity: 'moderate' },\n  { pattern: new RegExp(`\\\\bb[\\\\*\\\\#\\\\-\\\\_]{2,}(?:es|y)?${WORD_END}`, 'gi'), severity: 'moderate' },\n\n  // A-word variations (a**, a**hole)\n  { pattern: new RegExp(`\\\\ba+[\\\\*\\\\#\\\\-\\\\_]+(?:ss(?:hole|holes)?)?${WORD_END}`, 'gi'), severity: 'moderate' },\n  { pattern: new RegExp(`\\\\ba[\\\\*\\\\#\\\\-\\\\_]{1,}(?:hole|holes)?${WORD_END}`, 'gi'), severity: 'moderate' },\n\n  // C-word variations (c**t)\n  { pattern: new RegExp(`\\\\bc+[\\\\*\\\\#\\\\-\\\\_]+(?:nt|nts)?${WORD_END}`, 'gi'), severity: 'severe' },\n\n  // D-word variations (d**k, d*ck)\n  { pattern: new RegExp(`\\\\bd+[\\\\*\\\\#\\\\-\\\\_]+(?:ck|cks|ckhead)?${WORD_END}`, 'gi'), severity: 'moderate' },\n\n  // P-word variations (p***y)\n  { pattern: new RegExp(`\\\\bp+[\\\\*\\\\#\\\\-\\\\_]+(?:ssy|ss(?:ies|y)?)?${WORD_END}`, 'gi'), severity: 'moderate' },\n\n  // N-word variations (n****r) - severe\n  { pattern: new RegExp(`\\\\bn+[\\\\*\\\\#\\\\-\\\\_]+(?:gg|gga|gger|ggers|ggas)?${WORD_END}`, 'gi'), severity: 'severe' },\n\n  // Generic catch-all: ANY word containing asterisks/hashes is pre-censored profanity\n  // This catches godd***, sh*t, a**hole, and any other YouTube pre-censored words\n  // Matches: word chars + censoring chars + optional trailing word chars\n  { pattern: new RegExp(`\\\\b\\\\w+[\\\\*\\\\#]+\\\\w*${WORD_END}`, 'gi'), severity: 'moderate' },\n];\n\nexport class CaptionFilter {\n  private observer: MutationObserver | null = null;\n  private preferences: UserPreferences | null = null;\n  private isActive = false;\n  private censoredWordCount = 0;\n  private lastProcessedTexts = new Map<Node, string>();\n\n  constructor(_options: CaptionFilterOptions = {}) {\n    // Options for future use\n  }\n\n  /**\n   * Initialize the caption filter with user preferences\n   */\n  initialize(preferences: UserPreferences, _muteIntervals: MuteInterval[]): void {\n    this.preferences = preferences;\n    log('Caption filter initialized');\n  }\n\n  /**\n   * Start hijacking YouTube captions\n   */\n  start(): void {\n    if (this.isActive) {\n      log('Caption filter already active');\n      return;\n    }\n\n    log('Starting caption filter - hijacking YouTube captions');\n    this.isActive = true;\n    this.censoredWordCount = 0;\n    this.lastProcessedTexts.clear();\n\n    // Set up mutation observer on the caption container\n    this.setupCaptionObserver();\n  }\n\n  /**\n   * Stop hijacking captions\n   */\n  stop(): void {\n    if (!this.isActive) return;\n\n    log('Stopping caption filter. Censored', this.censoredWordCount, 'words total.');\n    this.isActive = false;\n\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = null;\n    }\n\n    this.lastProcessedTexts.clear();\n  }\n\n  /**\n   * Update preferences\n   */\n  updatePreferences(preferences: UserPreferences): void {\n    this.preferences = preferences;\n  }\n\n  /**\n   * Get the count of censored words\n   */\n  getCensoredCount(): number {\n    return this.censoredWordCount;\n  }\n\n  /**\n   * Set up observer specifically on YouTube's caption container\n   */\n  private setupCaptionObserver(): void {\n    // YouTube uses these containers for captions\n    const captionContainerSelectors = [\n      '.ytp-caption-window-container',\n      '.caption-window',\n      '#movie_player .ytp-caption-window-bottom',\n      '#movie_player',\n    ];\n\n    let container: Element | null = null;\n    for (const selector of captionContainerSelectors) {\n      container = document.querySelector(selector);\n      if (container) break;\n    }\n\n    if (!container) {\n      log('Caption container not found, retrying in 500ms');\n      setTimeout(() => {\n        if (this.isActive) this.setupCaptionObserver();\n      }, 500);\n      return;\n    }\n\n    log('Found caption container, setting up observer');\n\n    // Create observer that intercepts caption text changes\n    this.observer = new MutationObserver((mutations) => {\n      if (!this.isActive) return;\n\n      for (const mutation of mutations) {\n        // Handle added nodes (new caption segments appear)\n        if (mutation.type === 'childList') {\n          mutation.addedNodes.forEach((node) => {\n            this.processCaptionNode(node);\n          });\n        }\n\n        // Handle direct text changes in caption segments\n        if (mutation.type === 'characterData') {\n          const target = mutation.target;\n          if (target.nodeType === Node.TEXT_NODE) {\n            this.filterTextNode(target as Text);\n          }\n        }\n      }\n    });\n\n    // Watch for all changes in the container\n    this.observer.observe(container, {\n      childList: true,\n      subtree: true,\n      characterData: true,\n    });\n\n    // Also do an initial scan\n    this.scanForCaptions(container);\n\n    log('Caption observer active on container');\n  }\n\n  /**\n   * Scan container for existing captions\n   */\n  private scanForCaptions(container: Element): void {\n    const segments = container.querySelectorAll('.ytp-caption-segment');\n    segments.forEach((segment) => {\n      this.filterCaptionElement(segment);\n    });\n  }\n\n  /**\n   * Process a node that was added to the caption container\n   */\n  private processCaptionNode(node: Node): void {\n    if (!this.isActive) return;\n\n    // If it's a text node, filter it directly\n    if (node.nodeType === Node.TEXT_NODE) {\n      this.filterTextNode(node as Text);\n      return;\n    }\n\n    // If it's an element, check if it's a caption segment\n    if (node.nodeType === Node.ELEMENT_NODE) {\n      const element = node as Element;\n\n      // Check if this element is or contains caption text\n      if (this.isCaptionElement(element)) {\n        this.filterCaptionElement(element);\n      }\n\n      // Also process any caption segments within this element\n      const segments = element.querySelectorAll('.ytp-caption-segment');\n      segments.forEach((segment) => {\n        this.filterCaptionElement(segment);\n      });\n    }\n  }\n\n  /**\n   * Check if element is a YouTube caption element\n   */\n  private isCaptionElement(element: Element): boolean {\n    if (!element) return false;\n\n    // Handle className safely - it can be SVGAnimatedString for SVG elements\n    const className = typeof element.className === 'string'\n      ? element.className\n      : (element.className as SVGAnimatedString)?.baseVal || '';\n\n    // Check for YouTube caption classes\n    if (className.includes('ytp-caption-segment')) return true;\n    if (className.includes('captions-text')) return true;\n    if (className.includes('caption-visual-line')) return true;\n\n    // Check if it's inside a caption window\n    if (element.closest('.ytp-caption-window-container')) return true;\n    if (element.closest('.caption-window')) return true;\n\n    return false;\n  }\n\n  /**\n   * Filter text within a caption element by modifying its text nodes directly\n   */\n  private filterCaptionElement(element: Element): void {\n    if (!this.preferences) return;\n\n    // Get all text nodes within the element\n    const walker = document.createTreeWalker(\n      element,\n      NodeFilter.SHOW_TEXT,\n      null\n    );\n\n    const textNodes: Text[] = [];\n    let currentNode: Node | null;\n    while ((currentNode = walker.nextNode())) {\n      textNodes.push(currentNode as Text);\n    }\n\n    // Filter each text node\n    textNodes.forEach((textNode) => {\n      this.filterTextNode(textNode);\n    });\n  }\n\n  /**\n   * Filter a single text node by replacing profanity with (bleep)\n   */\n  private filterTextNode(textNode: Text): void {\n    if (!this.preferences) return;\n\n    const originalText = textNode.textContent || '';\n    if (!originalText.trim()) return;\n\n    // Skip if already fully processed (contains only bleeps or same text)\n    const lastText = this.lastProcessedTexts.get(textNode);\n    if (lastText === originalText) return;\n\n    const filteredText = this.censorText(originalText);\n\n    if (filteredText !== originalText) {\n      // Directly modify the text node's content\n      textNode.textContent = filteredText;\n      this.lastProcessedTexts.set(textNode, filteredText);\n      log('Censored:', originalText, '->', filteredText);\n    } else {\n      this.lastProcessedTexts.set(textNode, originalText);\n    }\n  }\n\n  /**\n   * Censor profanity in text string\n   */\n  private censorText(text: string): string {\n    if (!this.preferences) return text;\n\n    let result = text;\n    let modified = false;\n\n    // First, handle YouTube's pre-censored words (e.g., f******, s***)\n    result = this.replaceCensoredPatterns(result);\n    if (result !== text) {\n      modified = true;\n    }\n\n    // Then handle regular profanity word by word\n    const tokens = result.split(/(\\s+)/);\n    let newResult = '';\n\n    for (const token of tokens) {\n      // Skip whitespace\n      if (!token || /^\\s+$/.test(token)) {\n        newResult += token;\n        continue;\n      }\n\n      // Skip if already (bleep)\n      if (token === '(bleep)') {\n        newResult += token;\n        continue;\n      }\n\n      // Check if it's a safe word\n      if (isSafeWord(token)) {\n        newResult += token;\n        continue;\n      }\n\n      // Check for profanity\n      const profanityMatches = findEmbeddedProfanity(token);\n\n      if (profanityMatches.length > 0) {\n        // Filter by enabled severity levels\n        const enabledMatches = profanityMatches.filter((match) => {\n          const severity = match.severity as SeverityLevel;\n          return this.preferences!.severityLevels[severity];\n        });\n\n        if (enabledMatches.length > 0) {\n          newResult += '(bleep)';\n          this.censoredWordCount += enabledMatches.length;\n          modified = true;\n          continue;\n        }\n      }\n\n      // Check custom blacklist\n      const tokenLower = token.toLowerCase().replace(/[.,!?;:'\"()-]/g, '');\n      if (this.preferences.customBlacklist.some(\n        (banned) => tokenLower === banned.toLowerCase()\n      )) {\n        newResult += '(bleep)';\n        this.censoredWordCount++;\n        modified = true;\n        continue;\n      }\n\n      newResult += token;\n    }\n\n    return modified ? newResult : text;\n  }\n\n  /**\n   * Replace YouTube's pre-censored patterns (f******, s***, etc.)\n   */\n  private replaceCensoredPatterns(text: string): string {\n    if (!this.preferences) return text;\n\n    let result = text;\n\n    for (const { pattern, severity } of CENSORED_PATTERNS) {\n      // Check if this severity level is enabled\n      if (!this.preferences.severityLevels[severity]) continue;\n\n      // Reset regex state\n      pattern.lastIndex = 0;\n\n      if (pattern.test(result)) {\n        pattern.lastIndex = 0;\n        const matches = result.match(pattern);\n        if (matches) {\n          this.censoredWordCount += matches.length;\n        }\n        result = result.replace(pattern, '(bleep)');\n      }\n    }\n\n    return result;\n  }\n}\n","// Timeline Markers - Visual indicators on YouTube's progress bar showing profanity locations\nimport { MuteInterval } from '../types';\n\nconst DEBUG = false;\n\nfunction log(...args: unknown[]): void {\n  if (DEBUG) {\n    console.log('[SafePlay Timeline]', ...args);\n  }\n}\n\nexport interface TimelineMarkersOptions {\n  debug?: boolean;\n}\n\nexport class TimelineMarkers {\n  private muteIntervals: MuteInterval[] = [];\n  private video: HTMLVideoElement | null = null;\n  private overlayContainer: HTMLElement | null = null;\n  private resizeObserver: ResizeObserver | null = null;\n  private progressBarElement: HTMLElement | null = null;\n  private isInitialized = false;\n  private retryCount = 0;\n  private maxRetries = 20;\n  private retryDelay = 500;\n\n  constructor(_options?: TimelineMarkersOptions) {\n    // Options for future use\n  }\n\n  /**\n   * Initialize the timeline markers with mute intervals\n   */\n  initialize(video: HTMLVideoElement, muteIntervals: MuteInterval[]): void {\n    this.video = video;\n    this.muteIntervals = muteIntervals;\n\n    log('Initializing timeline markers with', muteIntervals.length, 'intervals');\n\n    // Try to inject the overlay\n    this.injectOverlayWithRetry();\n\n    // Setup event listeners for duration changes\n    this.setupEventListeners();\n  }\n\n  /**\n   * Retry injection until progress bar is available\n   */\n  private injectOverlayWithRetry(): void {\n    const progressBar = this.findProgressBar();\n\n    if (progressBar) {\n      this.progressBarElement = progressBar;\n      this.createOverlay();\n      this.isInitialized = true;\n      log('Timeline overlay injected successfully');\n    } else if (this.retryCount < this.maxRetries) {\n      this.retryCount++;\n      setTimeout(() => this.injectOverlayWithRetry(), this.retryDelay);\n    } else {\n      log('Failed to find progress bar after', this.maxRetries, 'attempts');\n    }\n  }\n\n  /**\n   * Find YouTube's progress bar element\n   * We need to find the parent of .ytp-timed-markers-container to be at the same level\n   */\n  private findProgressBar(): HTMLElement | null {\n    // First, try to find where ytp-timed-markers-container lives\n    // and inject as a sibling to it\n    const timedMarkersContainer = document.querySelector<HTMLElement>('.ytp-timed-markers-container');\n    if (timedMarkersContainer?.parentElement) {\n      log('Found ytp-timed-markers-container, using its parent:', timedMarkersContainer.parentElement.className);\n      return timedMarkersContainer.parentElement;\n    }\n\n    // Fallback selectors\n    const selectors = [\n      '.ytp-progress-bar-container',\n      '.ytp-chapter-hover-container',\n      '.ytp-progress-bar',\n      '#movie_player .ytp-progress-bar-container',\n    ];\n\n    for (const selector of selectors) {\n      const element = document.querySelector<HTMLElement>(selector);\n      if (element) {\n        log('Found progress bar element:', selector);\n        return element;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Create the overlay container and markers\n   */\n  private createOverlay(): void {\n    if (!this.progressBarElement) return;\n\n    // Remove existing overlay if any\n    this.removeOverlay();\n\n\n    // Create overlay container\n    this.overlayContainer = document.createElement('div');\n    this.overlayContainer.className = 'safeplay-timeline-overlay';\n\n    // Position relative to progress bar with high z-index to be above YouTube's elements\n    // YouTube uses z-index up to ~70 for various interactive elements\n    this.overlayContainer.style.cssText = `\n      position: absolute;\n      left: 0;\n      right: 0;\n      top: 0;\n      bottom: 0;\n      height: 100%;\n      width: 100%;\n      pointer-events: none;\n      z-index: 77;\n    `;\n\n    // Insert overlay into progress bar container\n    this.progressBarElement.style.position = 'relative';\n    this.progressBarElement.appendChild(this.overlayContainer);\n\n    // CRITICAL: Disable pointer events on ytp-timed-markers-container so our markers receive events\n    const timedMarkersContainer = document.querySelector<HTMLElement>('.ytp-timed-markers-container');\n    if (timedMarkersContainer) {\n      timedMarkersContainer.style.pointerEvents = 'none';\n      log('Disabled pointer events on ytp-timed-markers-container');\n    }\n\n    log('Overlay container created and appended');\n\n    // Create markers for each mute interval\n    this.renderMarkers();\n\n    // Setup resize observer to handle player resizing\n    this.setupResizeObserver();\n\n  }\n\n  /**\n   * Render all profanity markers on the timeline\n   */\n  private renderMarkers(): void {\n    if (!this.overlayContainer || !this.video) return;\n\n    const duration = this.video.duration;\n    if (!duration || !isFinite(duration)) {\n      log('Video duration not available yet, waiting...');\n      // Retry when duration becomes available\n      this.video.addEventListener('loadedmetadata', () => this.renderMarkers(), { once: true });\n      return;\n    }\n\n    // Clear existing markers\n    this.overlayContainer.innerHTML = '';\n\n    log('Rendering', this.muteIntervals.length, 'markers for video duration:', duration);\n\n    // Create a marker for each mute interval\n    for (const interval of this.muteIntervals) {\n      const marker = this.createMarker(interval, duration);\n      if (marker) {\n        this.overlayContainer.appendChild(marker);\n      }\n    }\n  }\n\n  /**\n   * Create a single marker element for a mute interval\n   */\n  private createMarker(interval: MuteInterval, videoDuration: number): HTMLElement | null {\n    if (interval.start >= videoDuration) return null;\n\n    const marker = document.createElement('div');\n    marker.className = 'safeplay-timeline-marker';\n\n    // Calculate position and width as percentages\n    const leftPercent = (interval.start / videoDuration) * 100;\n    const endTime = Math.min(interval.end, videoDuration);\n    const widthPercent = ((endTime - interval.start) / videoDuration) * 100;\n\n    // Minimum width of 0.8% for subtle but visible markers\n    const minWidth = Math.max(widthPercent, 0.8);\n\n    // Center the marker on the profanity start time if we expanded it\n    const adjustedLeft = widthPercent < 0.8\n      ? Math.max(0, leftPercent - (0.8 - widthPercent) / 2)\n      : leftPercent;\n\n    // Use white for all markers - provides good contrast against YouTube's red progress bar\n    marker.style.cssText = `\n      position: absolute;\n      left: ${adjustedLeft}%;\n      width: ${minWidth}%;\n      height: 6px;\n      bottom: 0;\n      background-color: #FFFFFF;\n      opacity: 0.9;\n      border-radius: 2px;\n      pointer-events: auto;\n      cursor: pointer;\n      z-index: 78;\n      box-shadow: 0 0 2px rgba(0, 0, 0, 0.5);\n      transition: opacity 0.2s ease, transform 0.2s ease;\n    `;\n\n    // Add tooltip with word info\n    marker.title = `${this.formatTimestamp(interval.start)} - \"${interval.word}\"`;\n\n    // Hover effect - make it very visible\n    marker.addEventListener('mouseenter', () => {\n      marker.style.opacity = '1';\n      marker.style.transform = 'scaleY(1.5)';\n      marker.style.zIndex = '99';\n      marker.style.boxShadow = '0 0 8px 2px rgba(255, 255, 255, 0.8)';\n    });\n\n    marker.addEventListener('mouseleave', () => {\n      marker.style.opacity = '0.9';\n      marker.style.transform = 'scaleY(1)';\n      marker.style.zIndex = '78';\n      marker.style.boxShadow = '0 0 2px rgba(0, 0, 0, 0.5)';\n    });\n\n    // Click to seek to that position\n    marker.addEventListener('click', (e) => {\n      log('CLICK on marker:', interval.word);\n      e.stopPropagation();\n      e.preventDefault();\n      if (this.video) {\n        // Seek to slightly before the profanity\n        this.video.currentTime = Math.max(0, interval.start - 2);\n        log('Seeked to', interval.start - 2, 'for interval:', interval.word);\n      }\n    });\n\n    return marker;\n  }\n\n  /**\n   * Format timestamp for tooltip display\n   */\n  private formatTimestamp(seconds: number): string {\n    const mins = Math.floor(seconds / 60);\n    const secs = Math.floor(seconds % 60);\n    return `${mins}:${secs.toString().padStart(2, '0')}`;\n  }\n\n  /**\n   * Setup event listeners for video element\n   */\n  private setupEventListeners(): void {\n    if (!this.video) return;\n\n    // Re-render markers when video duration becomes available or changes\n    this.video.addEventListener('durationchange', () => {\n      log('Duration changed:', this.video?.duration);\n      if (this.isInitialized) {\n        this.renderMarkers();\n      }\n    });\n\n    // Handle video source changes (for playlists, etc.)\n    this.video.addEventListener('loadedmetadata', () => {\n      log('Metadata loaded, duration:', this.video?.duration);\n      if (this.isInitialized) {\n        this.renderMarkers();\n      }\n    });\n  }\n\n  /**\n   * Setup resize observer to reposition markers when player resizes\n   */\n  private setupResizeObserver(): void {\n    if (!this.progressBarElement) return;\n\n    this.resizeObserver = new ResizeObserver(() => {\n      // Markers use percentages, so they scale automatically\n      // But we log for debugging\n      log('Progress bar resized');\n    });\n\n    this.resizeObserver.observe(this.progressBarElement);\n  }\n\n  /**\n   * Update the mute intervals (e.g., when preferences change)\n   */\n  update(muteIntervals: MuteInterval[]): void {\n    this.muteIntervals = muteIntervals;\n    if (this.isInitialized) {\n      this.renderMarkers();\n    }\n  }\n\n  /**\n   * Show the timeline markers\n   */\n  show(): void {\n    if (this.overlayContainer) {\n      this.overlayContainer.style.display = 'block';\n    }\n  }\n\n  /**\n   * Hide the timeline markers\n   */\n  hide(): void {\n    if (this.overlayContainer) {\n      this.overlayContainer.style.display = 'none';\n    }\n  }\n\n  /**\n   * Remove the overlay from DOM\n   */\n  private removeOverlay(): void {\n    if (this.overlayContainer) {\n      this.overlayContainer.remove();\n      this.overlayContainer = null;\n    }\n  }\n\n  /**\n   * Clean up resources\n   */\n  destroy(): void {\n    log('Destroying timeline markers');\n\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n      this.resizeObserver = null;\n    }\n\n    this.removeOverlay();\n    this.video = null;\n    this.progressBarElement = null;\n    this.muteIntervals = [];\n    this.isInitialized = false;\n    this.retryCount = 0;\n  }\n}\n","// Credit Confirmation Dialog Component\nimport { PreviewData } from '../types';\n\ninterface CreditConfirmationOptions {\n  onConfirm: () => void;\n  onCancel: () => void;\n  debug?: boolean;\n}\n\nfunction log(debug: boolean, ...args: unknown[]): void {\n  if (debug) {\n    console.log('[SafePlay CreditConfirm]', ...args);\n  }\n}\n\nfunction formatDuration(seconds: number): string {\n  const mins = Math.floor(seconds / 60);\n  const secs = seconds % 60;\n  if (mins === 0) return `${secs}s`;\n  if (secs === 0) return `${mins}m`;\n  return `${mins}m ${secs}s`;\n}\n\nexport class CreditConfirmation {\n  private dialog: HTMLDivElement | null = null;\n  private debug: boolean;\n\n  constructor(private options: CreditConfirmationOptions) {\n    this.debug = options.debug || false;\n  }\n\n  show(previewData: PreviewData): void {\n    log(this.debug, 'Showing credit confirmation dialog:', previewData);\n\n    // Remove any existing dialog\n    this.hide();\n\n    // Create dialog elements\n    this.dialog = document.createElement('div');\n    this.dialog.className = 'safeplay-credit-dialog-overlay';\n    this.dialog.innerHTML = this.createDialogHTML(previewData);\n\n    // Add styles\n    this.injectStyles();\n\n    // Add to page\n    document.body.appendChild(this.dialog);\n\n    // Set up event listeners\n    this.setupListeners(previewData);\n\n    // Focus the dialog for accessibility\n    const dialogContent = this.dialog.querySelector('.safeplay-credit-dialog') as HTMLElement;\n    if (dialogContent) {\n      dialogContent.focus();\n    }\n  }\n\n  hide(): void {\n    if (this.dialog) {\n      this.dialog.remove();\n      this.dialog = null;\n    }\n  }\n\n  private createDialogHTML(data: PreviewData): string {\n    const { video, creditCost, creditCostNote, creditCostUnknown, userCredits, hasSufficientCredits, isCached } = data;\n\n    // Format cost display - handle unknown cost case\n    const costDisplay = creditCostUnknown\n      ? (creditCostNote || '~1 credit per minute')\n      : `${creditCost} credit${creditCost !== 1 ? 's' : ''}`;\n\n    // Determine dialog content based on state\n    if (isCached) {\n      // Cached video - no cost, just confirmation\n      return `\n        <div class=\"safeplay-credit-dialog\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"safeplay-dialog-title\">\n          <div class=\"safeplay-dialog-header\">\n            <div class=\"safeplay-dialog-icon safeplay-icon-cached\">\n              <svg viewBox=\"0 0 24 24\" fill=\"currentColor\" width=\"24\" height=\"24\">\n                <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z\"/>\n              </svg>\n            </div>\n            <h2 id=\"safeplay-dialog-title\">Video Ready</h2>\n          </div>\n          <div class=\"safeplay-dialog-body\">\n            <p class=\"safeplay-dialog-message\">\n              This video has already been processed. Filtering is free!\n            </p>\n          </div>\n          <div class=\"safeplay-dialog-actions\">\n            <button class=\"safeplay-btn safeplay-btn-primary\" data-action=\"confirm\">\n              Start Filtering\n            </button>\n          </div>\n        </div>\n      `;\n    }\n\n    if (!hasSufficientCredits) {\n      // Insufficient credits\n      return `\n        <div class=\"safeplay-credit-dialog\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"safeplay-dialog-title\">\n          <div class=\"safeplay-dialog-header\">\n            <div class=\"safeplay-dialog-icon safeplay-icon-warning\">\n              <svg viewBox=\"0 0 24 24\" fill=\"currentColor\" width=\"24\" height=\"24\">\n                <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z\"/>\n              </svg>\n            </div>\n            <h2 id=\"safeplay-dialog-title\">Not Enough Credits</h2>\n          </div>\n          <div class=\"safeplay-dialog-body\">\n            <div class=\"safeplay-video-info\">\n              <span class=\"safeplay-video-title\">${this.escapeHtml(video.title)}</span>\n              <span class=\"safeplay-video-duration\">${formatDuration(video.duration)}</span>\n            </div>\n            <p class=\"safeplay-dialog-message safeplay-credit-explanation\">\n              You don't have enough credits to filter this video.\n            </p>\n            <div class=\"safeplay-credit-info safeplay-insufficient\">\n              <div class=\"safeplay-credit-row\">\n                <span>This video requires:</span>\n                <span class=\"safeplay-credit-value\">${costDisplay}</span>\n              </div>\n              <div class=\"safeplay-credit-row\">\n                <span>You currently have:</span>\n                <span class=\"safeplay-credit-value safeplay-low\">${userCredits} credit${userCredits !== 1 ? 's' : ''}</span>\n              </div>\n              ${!creditCostUnknown ? `\n              <div class=\"safeplay-credit-row safeplay-need\">\n                <span>You need:</span>\n                <span class=\"safeplay-credit-value\">${creditCost - userCredits} more credit${(creditCost - userCredits) !== 1 ? 's' : ''}</span>\n              </div>\n              ` : ''}\n            </div>\n          </div>\n          <div class=\"safeplay-dialog-actions\">\n            <button class=\"safeplay-btn safeplay-btn-secondary\" data-action=\"cancel\">\n              Cancel\n            </button>\n            <a href=\"https://trysafeplay.com/pricing\" target=\"_blank\" class=\"safeplay-btn safeplay-btn-primary\">\n              Get More Credits\n            </a>\n          </div>\n        </div>\n      `;\n    }\n\n    // Normal case - show cost and confirmation\n    return `\n      <div class=\"safeplay-credit-dialog\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"safeplay-dialog-title\">\n        <div class=\"safeplay-dialog-header\">\n          <div class=\"safeplay-dialog-icon\">\n            <svg viewBox=\"0 0 24 24\" fill=\"currentColor\" width=\"24\" height=\"24\">\n              <path d=\"M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm-2 16l-4-4 1.41-1.41L10 14.17l6.59-6.59L18 9l-8 8z\"/>\n            </svg>\n          </div>\n          <h2 id=\"safeplay-dialog-title\">Confirm Filtering</h2>\n        </div>\n        <div class=\"safeplay-dialog-body\">\n          <div class=\"safeplay-video-info\">\n            <span class=\"safeplay-video-title\">${this.escapeHtml(video.title)}</span>\n            <span class=\"safeplay-video-duration\">${formatDuration(video.duration)}</span>\n          </div>\n          <p class=\"safeplay-dialog-message safeplay-credit-explanation\">\n            Filtering this video will use credits from your account.\n          </p>\n          <div class=\"safeplay-credit-info\">\n            <div class=\"safeplay-credit-row\">\n              <span>Your current credits:</span>\n              <span class=\"safeplay-credit-value\">${userCredits}</span>\n            </div>\n            <div class=\"safeplay-credit-row safeplay-deduct\">\n              <span>${creditCostUnknown ? 'Estimated deduction:' : 'Will be deducted:'}</span>\n              <span class=\"safeplay-credit-value safeplay-cost\">-${creditCost}</span>\n            </div>\n            ${!creditCostUnknown ? `\n            <div class=\"safeplay-credit-row safeplay-after\">\n              <span>You'll have left:</span>\n              <span class=\"safeplay-credit-value safeplay-remaining\">${userCredits - creditCost}</span>\n            </div>\n            ` : `\n            <div class=\"safeplay-credit-row safeplay-after\">\n              <span class=\"safeplay-cost-note\">Exact cost calculated after processing (~1 credit/minute)</span>\n            </div>\n            `}\n          </div>\n        </div>\n        <div class=\"safeplay-dialog-actions\">\n          <button class=\"safeplay-btn safeplay-btn-secondary\" data-action=\"cancel\">\n            Cancel\n          </button>\n          <button class=\"safeplay-btn safeplay-btn-primary\" data-action=\"confirm\">\n            Use ${creditCostUnknown ? '~' + creditCost : creditCost} Credit${creditCost !== 1 ? 's' : ''} & Filter\n          </button>\n        </div>\n      </div>\n    `;\n  }\n\n  private setupListeners(_data: PreviewData): void {\n    if (!this.dialog) return;\n\n    // Confirm button\n    const confirmBtn = this.dialog.querySelector('[data-action=\"confirm\"]');\n    if (confirmBtn) {\n      confirmBtn.addEventListener('click', () => {\n        log(this.debug, 'Confirm clicked');\n        this.hide();\n        this.options.onConfirm();\n      });\n    }\n\n    // Cancel button\n    const cancelBtn = this.dialog.querySelector('[data-action=\"cancel\"]');\n    if (cancelBtn) {\n      cancelBtn.addEventListener('click', () => {\n        log(this.debug, 'Cancel clicked');\n        this.hide();\n        this.options.onCancel();\n      });\n    }\n\n    // Click outside to cancel\n    this.dialog.addEventListener('click', (e) => {\n      if (e.target === this.dialog) {\n        log(this.debug, 'Clicked outside, canceling');\n        this.hide();\n        this.options.onCancel();\n      }\n    });\n\n    // Escape key to cancel\n    const handleKeydown = (e: KeyboardEvent) => {\n      if (e.key === 'Escape') {\n        log(this.debug, 'Escape pressed, canceling');\n        this.hide();\n        this.options.onCancel();\n        document.removeEventListener('keydown', handleKeydown);\n      }\n    };\n    document.addEventListener('keydown', handleKeydown);\n  }\n\n  private escapeHtml(text: string): string {\n    const div = document.createElement('div');\n    div.textContent = text;\n    return div.innerHTML;\n  }\n\n  private injectStyles(): void {\n    // Check if styles already injected\n    if (document.getElementById('safeplay-credit-dialog-styles')) return;\n\n    const styles = document.createElement('style');\n    styles.id = 'safeplay-credit-dialog-styles';\n    // Colors matched to SafePlay website theme\n    styles.textContent = `\n      .safeplay-credit-dialog-overlay {\n        position: fixed;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n        background: rgba(0, 0, 0, 0.75);\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        z-index: 999999;\n        font-family: 'Roboto', 'YouTube Sans', -apple-system, BlinkMacSystemFont, sans-serif;\n      }\n\n      .safeplay-credit-dialog {\n        background: #212121;\n        border: 1px solid #3F3F3F;\n        border-radius: 12px;\n        padding: 24px;\n        max-width: 380px;\n        width: 90%;\n        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);\n        outline: none;\n        animation: safeplay-dialog-appear 0.2s ease-out;\n      }\n\n      @keyframes safeplay-dialog-appear {\n        from {\n          opacity: 0;\n          transform: scale(0.95);\n        }\n        to {\n          opacity: 1;\n          transform: scale(1);\n        }\n      }\n\n      .safeplay-dialog-header {\n        display: flex;\n        align-items: center;\n        gap: 12px;\n        margin-bottom: 20px;\n      }\n\n      .safeplay-dialog-icon {\n        width: 40px;\n        height: 40px;\n        border-radius: 50%;\n        background: #FF0000;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        color: white;\n        flex-shrink: 0;\n      }\n\n      .safeplay-dialog-icon.safeplay-icon-cached {\n        background: #2BA640;\n      }\n\n      .safeplay-dialog-icon.safeplay-icon-warning {\n        background: #F9A825;\n      }\n\n      .safeplay-dialog-header h2 {\n        margin: 0;\n        font-size: 18px;\n        font-weight: 600;\n        color: #F1F1F1;\n      }\n\n      .safeplay-dialog-body {\n        margin-bottom: 24px;\n      }\n\n      .safeplay-dialog-message {\n        color: #AAAAAA;\n        font-size: 14px;\n        line-height: 1.5;\n        margin: 0;\n      }\n\n      .safeplay-video-info {\n        background: #272727;\n        border-radius: 8px;\n        padding: 12px;\n        margin-bottom: 16px;\n      }\n\n      .safeplay-video-title {\n        display: block;\n        color: #F1F1F1;\n        font-size: 14px;\n        font-weight: 500;\n        margin-bottom: 4px;\n        overflow: hidden;\n        text-overflow: ellipsis;\n        white-space: nowrap;\n      }\n\n      .safeplay-video-duration {\n        display: block;\n        color: #606060;\n        font-size: 12px;\n      }\n\n      .safeplay-credit-info {\n        background: #272727;\n        border-radius: 8px;\n        padding: 12px;\n      }\n\n      .safeplay-credit-info.safeplay-insufficient {\n        border: 1px solid #FF4E45;\n      }\n\n      .safeplay-credit-row {\n        display: flex;\n        justify-content: space-between;\n        align-items: center;\n        padding: 6px 0;\n        color: #AAAAAA;\n        font-size: 14px;\n      }\n\n      .safeplay-credit-row:not(:last-child) {\n        border-bottom: 1px solid #3F3F3F;\n      }\n\n      .safeplay-credit-value {\n        font-weight: 600;\n        color: #2BA640;\n      }\n\n      .safeplay-credit-value.safeplay-low {\n        color: #FF4E45;\n      }\n\n      .safeplay-credit-row.safeplay-need .safeplay-credit-value {\n        color: #F9A825;\n      }\n\n      .safeplay-credit-explanation {\n        margin: 0 0 12px 0;\n        font-size: 13px;\n        color: #AAAAAA;\n        line-height: 1.4;\n      }\n\n      .safeplay-credit-row.safeplay-deduct {\n        background: rgba(255, 78, 69, 0.1);\n        margin: 0 -12px;\n        padding: 8px 12px;\n      }\n\n      .safeplay-credit-value.safeplay-cost {\n        color: #FF4E45;\n        font-weight: 700;\n      }\n\n      .safeplay-credit-value.safeplay-remaining {\n        color: #2BA640;\n        font-weight: 600;\n      }\n\n      .safeplay-credit-row.safeplay-after {\n        color: #888888;\n        font-size: 13px;\n      }\n\n      .safeplay-cost-note {\n        font-size: 12px;\n        font-style: italic;\n        color: #888888;\n      }\n\n      .safeplay-dialog-actions {\n        display: flex;\n        gap: 12px;\n        justify-content: flex-end;\n      }\n\n      .safeplay-btn {\n        padding: 10px 20px;\n        border-radius: 8px;\n        font-size: 14px;\n        font-weight: 500;\n        cursor: pointer;\n        border: none;\n        transition: all 0.2s;\n        text-decoration: none;\n        display: inline-flex;\n        align-items: center;\n        justify-content: center;\n      }\n\n      .safeplay-btn-primary {\n        background: #FF0000;\n        color: white;\n      }\n\n      .safeplay-btn-primary:hover {\n        background: #CC0000;\n        transform: translateY(-1px);\n      }\n\n      .safeplay-btn-secondary {\n        background: #272727;\n        border: 1px solid #3F3F3F;\n        color: #F1F1F1;\n      }\n\n      .safeplay-btn-secondary:hover {\n        background: #3F3F3F;\n      }\n    `;\n\n    document.head.appendChild(styles);\n  }\n}\n\n// Helper function to show a filter error notification\nexport function showFilterErrorNotification(): void {\n  const overlay = document.createElement('div');\n  // Use inline styles to avoid conflicts with CreditConfirmation styles\n  overlay.style.cssText = `\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background: rgba(0, 0, 0, 0.75);\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    z-index: 999999;\n    font-family: 'Roboto', 'YouTube Sans', -apple-system, BlinkMacSystemFont, sans-serif;\n  `;\n  overlay.innerHTML = `\n    <div tabindex=\"-1\" role=\"dialog\" style=\"background: #212121; border: 1px solid #3F3F3F; border-radius: 12px; padding: 24px; max-width: 380px; width: 90%; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5); outline: none;\">\n      <div style=\"display: flex; align-items: center; gap: 12px; margin-bottom: 20px;\">\n        <div style=\"width: 40px; height: 40px; border-radius: 50%; background: #FF4E45; display: flex; align-items: center; justify-content: center; color: white; flex-shrink: 0;\">\n          <svg viewBox=\"0 0 24 24\" fill=\"currentColor\" width=\"24\" height=\"24\">\n            <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z\"/>\n          </svg>\n        </div>\n        <h2 style=\"margin: 0; font-size: 18px; font-weight: 600; color: #F1F1F1;\">Having Trouble Filtering</h2>\n      </div>\n      <div style=\"margin-bottom: 24px;\">\n        <p style=\"color: #AAAAAA; font-size: 14px; line-height: 1.5; margin: 0;\">\n          We're experiencing some difficulty censoring this video right now. Our team has been notified and is working on it.\n        </p>\n        <p style=\"color: #888888; font-size: 14px; line-height: 1.5; margin: 12px 0 0 0;\">\n          We'll notify you when the video is ready to be filtered. You can also try again later by clicking the Retry button.\n        </p>\n      </div>\n      <div style=\"display: flex; gap: 12px; justify-content: flex-end;\">\n        <button data-action=\"close\" style=\"padding: 10px 20px; border-radius: 8px; font-size: 14px; font-weight: 500; cursor: pointer; border: none; background: #FF0000; color: white;\">\n          Got It\n        </button>\n      </div>\n    </div>\n  `;\n\n  document.body.appendChild(overlay);\n\n  // Set up close handlers\n  const closeDialog = () => {\n    overlay.remove();\n  };\n\n  overlay.querySelector('[data-action=\"close\"]')?.addEventListener('click', closeDialog);\n  overlay.addEventListener('click', (e) => {\n    if (e.target === overlay) closeDialog();\n  });\n  document.addEventListener('keydown', function escHandler(e) {\n    if (e.key === 'Escape') {\n      closeDialog();\n      document.removeEventListener('keydown', escHandler);\n    }\n  });\n}\n\n// Helper function to show a quick \"not authenticated\" message\nexport function showAuthRequiredMessage(): void {\n  const overlay = document.createElement('div');\n  overlay.className = 'safeplay-credit-dialog-overlay';\n  overlay.innerHTML = `\n    <div class=\"safeplay-credit-dialog\" tabindex=\"-1\" role=\"dialog\">\n      <div class=\"safeplay-dialog-header\">\n        <div class=\"safeplay-dialog-icon safeplay-icon-warning\">\n          <svg viewBox=\"0 0 24 24\" fill=\"currentColor\" width=\"24\" height=\"24\">\n            <path d=\"M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm-2 16l-4-4 1.41-1.41L10 14.17l6.59-6.59L18 9l-8 8z\"/>\n          </svg>\n        </div>\n        <h2>Sign In to SafePlay</h2>\n      </div>\n      <div class=\"safeplay-dialog-body\">\n        <p class=\"safeplay-dialog-message\">\n          You need to be signed in to filter videos with SafePlay.\n        </p>\n        <div style=\"background: #272727; border-radius: 8px; padding: 12px; margin-top: 12px;\">\n          <p style=\"color: #F1F1F1; font-size: 14px; margin: 0 0 8px 0; font-weight: 500;\">\n            New to SafePlay?\n          </p>\n          <p style=\"color: #AAAAAA; font-size: 13px; margin: 0; line-height: 1.4;\">\n            Create a free account and get 30 credits per month to start filtering profanity from YouTube videos.\n          </p>\n        </div>\n      </div>\n      <div class=\"safeplay-dialog-actions\" style=\"flex-direction: column; gap: 8px;\">\n        <div style=\"display: flex; gap: 12px; width: 100%; justify-content: flex-end;\">\n          <button class=\"safeplay-btn safeplay-btn-secondary\" data-action=\"cancel\">\n            Cancel\n          </button>\n          <a href=\"https://trysafeplay.com/login\" target=\"_blank\" class=\"safeplay-btn safeplay-btn-primary\">\n            Sign In\n          </a>\n        </div>\n        <div style=\"width: 100%; text-align: center; padding-top: 8px; border-top: 1px solid #3F3F3F;\">\n          <span style=\"color: #888; font-size: 13px;\">Don't have an account? </span>\n          <a href=\"https://trysafeplay.com/signup\" target=\"_blank\" style=\"color: #FF0000; font-size: 13px; text-decoration: none; font-weight: 500;\">\n            Sign Up Free\n          </a>\n        </div>\n      </div>\n    </div>\n  `;\n\n  // Inject styles if needed (uses same styles as CreditConfirmation class)\n  if (!document.getElementById('safeplay-credit-dialog-styles')) {\n    const styles = document.createElement('style');\n    styles.id = 'safeplay-credit-dialog-styles';\n    // Colors matched to SafePlay website theme\n    styles.textContent = `\n      .safeplay-credit-dialog-overlay {\n        position: fixed;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n        background: rgba(0, 0, 0, 0.75);\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        z-index: 999999;\n        font-family: 'Roboto', 'YouTube Sans', -apple-system, BlinkMacSystemFont, sans-serif;\n      }\n      .safeplay-credit-dialog {\n        background: #212121;\n        border: 1px solid #3F3F3F;\n        border-radius: 12px;\n        padding: 24px;\n        max-width: 380px;\n        width: 90%;\n        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);\n        outline: none;\n      }\n      .safeplay-dialog-header {\n        display: flex;\n        align-items: center;\n        gap: 12px;\n        margin-bottom: 20px;\n      }\n      .safeplay-dialog-icon {\n        width: 40px;\n        height: 40px;\n        border-radius: 50%;\n        background: #FF0000;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        color: white;\n      }\n      .safeplay-dialog-icon.safeplay-icon-warning {\n        background: #F9A825;\n      }\n      .safeplay-dialog-header h2 {\n        margin: 0;\n        font-size: 18px;\n        font-weight: 600;\n        color: #F1F1F1;\n      }\n      .safeplay-dialog-body {\n        margin-bottom: 24px;\n      }\n      .safeplay-dialog-message {\n        color: #AAAAAA;\n        font-size: 14px;\n        line-height: 1.5;\n        margin: 0;\n      }\n      .safeplay-dialog-actions {\n        display: flex;\n        gap: 12px;\n        justify-content: flex-end;\n      }\n      .safeplay-btn {\n        padding: 10px 20px;\n        border-radius: 8px;\n        font-size: 14px;\n        font-weight: 500;\n        cursor: pointer;\n        border: none;\n        text-decoration: none;\n        display: inline-flex;\n        align-items: center;\n      }\n      .safeplay-btn-primary {\n        background: #FF0000;\n        color: white;\n      }\n      .safeplay-btn-primary:hover {\n        background: #CC0000;\n      }\n      .safeplay-btn-secondary {\n        background: #272727;\n        border: 1px solid #3F3F3F;\n        color: #F1F1F1;\n      }\n      .safeplay-btn-secondary:hover {\n        background: #3F3F3F;\n      }\n    `;\n    document.head.appendChild(styles);\n  }\n\n  document.body.appendChild(overlay);\n\n  // Set up close handlers\n  const closeDialog = () => {\n    overlay.remove();\n  };\n\n  overlay.querySelector('[data-action=\"cancel\"]')?.addEventListener('click', closeDialog);\n  overlay.addEventListener('click', (e) => {\n    if (e.target === overlay) closeDialog();\n  });\n  document.addEventListener('keydown', function escHandler(e) {\n    if (e.key === 'Escape') {\n      closeDialog();\n      document.removeEventListener('keydown', escHandler);\n    }\n  });\n}\n","// API Response Types\n\nexport interface CharacterTiming {\n  char: string;\n  start: number;\n  end: number;\n}\n\nexport interface TranscriptSegment {\n  text: string;\n  start_time: number;\n  end_time: number;\n  characters: CharacterTiming[];\n}\n\nexport interface Transcript {\n  id: string;\n  youtube_id?: string; // May be set from context\n  full_text?: string;\n  segments: TranscriptSegment[];\n  duration?: number;\n  language?: string;\n  created_at?: string;\n}\n\n// Video metadata from preview endpoint\nexport interface VideoMetadata {\n  youtube_id: string;\n  title: string;\n  duration: number; // in seconds\n  thumbnail?: string;\n  channel?: string;\n}\n\n// Credit system types\nexport interface CreditInfo {\n  available: number;\n  used_this_period: number;\n  plan_allocation: number;\n  percent_consumed: number;\n  plan?: 'free' | 'base' | 'professional' | 'unlimited';\n  reset_date?: string;\n}\n\n// Preview response - check cost before filtering (matches actual API format)\nexport interface PreviewResponse {\n  youtube_id: string;\n  title: string;\n  channel_name?: string;\n  duration_seconds: number;\n  thumbnail_url?: string;\n  credit_cost: number;\n  user_credits: number;\n  has_sufficient_credits: boolean;\n  cached: boolean;\n  has_transcript: boolean;\n  credit_cost_note?: string; // Note when duration/cost is unknown\n  error?: string;\n  error_code?: 'AGE_RESTRICTED' | 'VIDEO_UNAVAILABLE' | 'UNAUTHORIZED' | string;\n}\n\n// Credit balance response\nexport interface CreditBalanceResponse {\n  success: boolean;\n  credits: CreditInfo;\n  error?: string;\n}\n\n// Filter start response\nexport interface FilterStartResponse {\n  success: boolean;\n  status: 'completed' | 'processing' | 'failed';\n  cached?: boolean;\n  transcript?: Transcript;\n  job_id?: string;\n  message?: string;\n  error?: string;\n  error_code?: 'INSUFFICIENT_CREDITS' | 'AGE_RESTRICTED' | 'VIDEO_UNAVAILABLE' | 'UNAUTHORIZED' | string;\n  credits_required?: number;\n  credits_available?: number;\n}\n\n// Job status response\nexport interface JobStatusResponse {\n  status: 'pending' | 'downloading' | 'transcribing' | 'completed' | 'failed';\n  progress: number;\n  message?: string;\n  transcript?: Transcript;\n  error?: string;\n  error_code?: 'AGE_RESTRICTED' | 'VIDEO_UNAVAILABLE' | string;\n  video?: {\n    youtube_id: string;\n    title?: string;\n  };\n}\n\n// Legacy FilterResponse - kept for compatibility during migration\nexport interface FilterResponse {\n  status: 'completed' | 'processing' | 'failed';\n  cached?: boolean;\n  transcript?: Transcript;\n  job_id?: string;\n  message?: string;\n  error?: string;\n  error_code?: string;  // 'AGE_RESTRICTED', 'VIDEO_UNAVAILABLE', etc.\n}\n\n// Button state for UX\nexport type ButtonState =\n  | 'idle'\n  | 'connecting'\n  | 'downloading'\n  | 'transcribing'\n  | 'processing'\n  | 'filtering'\n  | 'paused'  // Filter is paused (user can re-enable)\n  | 'error'\n  | 'age-restricted';  // Video is age-restricted and cannot be filtered\n\nexport interface ButtonStateInfo {\n  state: ButtonState;\n  text: string;\n  progress?: number;\n  intervalCount?: number;\n  error?: string;\n  videoId?: string; // Track which video this state belongs to (for Shorts)\n}\n\n// Profanity Types\n\nexport type SeverityLevel = 'mild' | 'moderate' | 'severe' | 'religious';\n\nexport interface ProfanityWord {\n  word: string;\n  severity: SeverityLevel;\n}\n\nexport interface MuteInterval {\n  start: number;\n  end: number;\n  word: string;\n  severity: SeverityLevel;\n}\n\nexport interface ProfanityMatch {\n  segmentIndex: number;\n  word: string;\n  severity: SeverityLevel;\n  startTime: number;\n  endTime: number;\n  isPartialMatch: boolean;\n  matchedPortion?: string;\n}\n\n// User Preferences\n\nexport type FilterMode = 'mute' | 'bleep';\n\nexport interface UserPreferences {\n  enabled: boolean;\n  filterMode: FilterMode;\n  severityLevels: {\n    mild: boolean;\n    moderate: boolean;\n    severe: boolean;\n    religious: boolean;\n  };\n  customBlacklist: string[];\n  customWhitelist: string[];\n  paddingMs: number; // Legacy/fallback symmetric padding\n  paddingBeforeMs?: number; // Padding before word starts (catches attack)\n  paddingAfterMs?: number; // Padding after word ends (catches release)\n  mergeThresholdMs: number;\n  autoEnableForFilteredVideos: boolean; // Auto-enable filter for previously filtered videos\n}\n\nexport const DEFAULT_PREFERENCES: UserPreferences = {\n  enabled: true,\n  filterMode: 'mute',\n  severityLevels: {\n    mild: false,\n    moderate: true,\n    severe: true,\n    religious: false, // Off by default - user opt-in\n  },\n  customBlacklist: [],\n  customWhitelist: [],\n  paddingMs: 50, // Legacy/fallback symmetric padding\n  paddingBeforeMs: 100, // Padding before word - smooth fade adds ~130ms effective lead time\n  paddingAfterMs: 30, // Padding after word ends\n  mergeThresholdMs: 100,\n  autoEnableForFilteredVideos: true, // Auto-enable filter for previously filtered videos\n};\n\n// Storage Types\n\nexport type SubscriptionTier = 'free' | 'base' | 'professional' | 'unlimited';\n\nexport interface StorageData {\n  preferences: UserPreferences;\n  authToken?: string;\n  userId?: string;\n  subscriptionTier?: SubscriptionTier;\n  creditInfo?: CreditInfo;\n  cachedTranscripts: Record<string, Transcript>;\n}\n\n// Message Types (between content script and background)\n\nexport type MessageType =\n  | 'GET_FILTER'\n  | 'GET_PREVIEW'\n  | 'START_FILTER'\n  | 'CHECK_JOB'\n  | 'GET_CREDITS'\n  | 'GET_PREFERENCES'\n  | 'SET_PREFERENCES'\n  | 'GET_AUTH_STATUS'\n  | 'CHECK_AUTH_STRICT'\n  | 'GET_USER_PROFILE'\n  | 'LOGOUT'\n  | 'OPEN_LOGIN'\n  | 'CLEAR_CACHE';\n\nexport interface Message<T = unknown> {\n  type: MessageType;\n  payload?: T;\n}\n\nexport interface MessageResponse<T = unknown> {\n  success: boolean;\n  data?: T;\n  error?: string;\n}\n\n// Preview data passed to content script\nexport interface PreviewData {\n  video: VideoMetadata;\n  creditCost: number;\n  creditCostNote?: string; // Note when cost is unknown (e.g., \"~1 credit per minute\")\n  creditCostUnknown?: boolean; // True when duration unavailable\n  userCredits: number;\n  hasSufficientCredits: boolean;\n  isCached: boolean;\n}\n\n// Filter confirmation payload from content script\nexport interface FilterConfirmPayload {\n  youtubeId: string;\n  filterType?: 'mute' | 'bleep';\n  customWords?: string[];\n}\n\n// User Profile Types\nexport interface UserProfile {\n  id: string;\n  email: string;\n  full_name?: string;\n  avatar_url?: string;\n  created_at?: string;\n}\n\nexport interface UserSubscription {\n  id: string;\n  user_id: string;\n  plan_id: string;\n  status: 'active' | 'canceled' | 'past_due' | 'paused';\n  current_period_start?: string;\n  current_period_end?: string;\n  plans?: {\n    id: string;\n    name: string;\n    monthly_credits: number;\n  };\n}\n\nexport interface UserCredits {\n  user_id: string;\n  available_credits: number;\n  used_this_period: number;\n  rollover_credits: number;\n  updated_at?: string;\n}\n\nexport interface UserProfileResponse {\n  user: UserProfile;\n  subscription: UserSubscription | null;\n  credits: UserCredits | null;\n}\n\nexport interface AuthState {\n  isAuthenticated: boolean;\n  user: UserProfile | null;\n  subscription: UserSubscription | null;\n  credits: UserCredits | null;\n  token: string | null;\n}\n","import {\n  UserPreferences,\n  DEFAULT_PREFERENCES,\n  Transcript,\n  CreditInfo,\n  SubscriptionTier,\n  UserProfile,\n  UserSubscription,\n  UserCredits,\n} from '../types';\n\nconst STORAGE_KEYS = {\n  PREFERENCES: 'safeplay_preferences',\n  AUTH_TOKEN: 'safeplay_auth_token',\n  REFRESH_TOKEN: 'safeplay_refresh_token',\n  TOKEN_EXPIRES_AT: 'safeplay_token_expires_at',\n  USER_ID: 'safeplay_user_id',\n  SUBSCRIPTION_TIER: 'safeplay_subscription_tier',\n  CREDIT_INFO: 'safeplay_credit_info',\n  CREDIT_CACHE_TIME: 'safeplay_credit_cache_time',\n  CACHED_TRANSCRIPTS: 'safeplay_cached_transcripts',\n  FILTERED_VIDEOS: 'safeplay_filtered_videos',\n  USER_PROFILE: 'safeplay_user_profile',\n  USER_SUBSCRIPTION: 'safeplay_user_subscription',\n  USER_CREDITS: 'safeplay_user_credits',\n  PROFILE_CACHE_TIME: 'safeplay_profile_cache_time',\n} as const;\n\n// API base URL for token refresh\nconst API_BASE_URL = 'https://trysafeplay.com';\n\n// Token refresh buffer - refresh 5 minutes before expiry\nconst TOKEN_REFRESH_BUFFER_MS = 5 * 60 * 1000;\n\n// Credit cache duration in milliseconds (5 minutes)\nconst CREDIT_CACHE_DURATION = 5 * 60 * 1000;\n\n// Cache limits\nconst MAX_CACHED_TRANSCRIPTS = 15; // Keep only 15 most recent transcripts\n\nexport async function getPreferences(): Promise<UserPreferences> {\n  const result = await chrome.storage.local.get(STORAGE_KEYS.PREFERENCES);\n  return result[STORAGE_KEYS.PREFERENCES] || DEFAULT_PREFERENCES;\n}\n\nexport async function setPreferences(\n  preferences: Partial<UserPreferences>\n): Promise<UserPreferences> {\n  const current = await getPreferences();\n  const updated = { ...current, ...preferences };\n  await chrome.storage.local.set({ [STORAGE_KEYS.PREFERENCES]: updated });\n  return updated;\n}\n\n// Refresh the auth token by getting fresh session from website\nexport async function refreshAuthToken(): Promise<string | null> {\n  try {\n    const extensionId = chrome.runtime.id;\n    const url = `${API_BASE_URL}/api/extension/session?extensionId=${extensionId}`;\n\n    console.log('[SafePlay Storage]  Refreshing token via website session...');\n    console.log('[SafePlay Storage] Endpoint:', url);\n\n    const response = await fetch(url, {\n      method: 'GET',\n      credentials: 'include',  // Include cookies for session\n    });\n\n    console.log('[SafePlay Storage] Response status:', response.status);\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      console.log('[SafePlay Storage]  Session fetch failed:', {\n        status: response.status,\n        statusText: response.statusText,\n        body: errorText.substring(0, 200),\n      });\n      return null;\n    }\n\n    const data = await response.json();\n\n    console.log('[SafePlay Storage] Response data:', {\n      authenticated: data.authenticated,\n      hasToken: !!data.token,\n      tokenLength: data.token?.length,\n      hasRefreshToken: !!data.refreshToken,\n      refreshTokenLength: data.refreshToken?.length,\n      expiresAt: data.expiresAt,\n      expiresAtDate: data.expiresAt ? new Date(data.expiresAt).toISOString() : null,\n    });\n\n    if (!data.authenticated) {\n      console.log('[SafePlay Storage]  User not authenticated on website - clearing local tokens');\n      // Clear local tokens since website session is gone\n      await chrome.storage.local.remove([\n        STORAGE_KEYS.AUTH_TOKEN,\n        STORAGE_KEYS.REFRESH_TOKEN,\n        STORAGE_KEYS.TOKEN_EXPIRES_AT,\n      ]);\n      return null;\n    }\n\n    // Store the new tokens\n    const expiresAtSeconds = Math.floor(data.expiresAt / 1000);\n    await chrome.storage.local.set({\n      [STORAGE_KEYS.AUTH_TOKEN]: data.token,\n      [STORAGE_KEYS.REFRESH_TOKEN]: data.refreshToken,\n      [STORAGE_KEYS.TOKEN_EXPIRES_AT]: expiresAtSeconds,\n    });\n\n    console.log('[SafePlay Storage]  Token refreshed successfully via website session');\n    console.log('[SafePlay Storage] New token expires:', new Date(expiresAtSeconds * 1000).toISOString());\n\n    return data.token;\n  } catch (error) {\n    console.log('[SafePlay Storage]  Session refresh error:', error);\n    return null;\n  }\n}\n\n// Get auth token - automatically refreshes if expired\nexport async function getAuthToken(): Promise<string | null> {\n  const result = await chrome.storage.local.get([\n    STORAGE_KEYS.AUTH_TOKEN,\n    STORAGE_KEYS.REFRESH_TOKEN,\n    STORAGE_KEYS.TOKEN_EXPIRES_AT,\n  ]);\n\n  const token = result[STORAGE_KEYS.AUTH_TOKEN];\n  const refreshToken = result[STORAGE_KEYS.REFRESH_TOKEN];\n  const expiresAt = result[STORAGE_KEYS.TOKEN_EXPIRES_AT];\n\n  if (!token) {\n    return null;\n  }\n\n  // Check if token is expired or expiring soon\n  if (expiresAt) {\n    const now = Date.now();\n    // expiresAt should be stored in seconds (normalized in setAuthToken)\n    // But handle both cases for safety\n    let expiresAtMs = expiresAt;\n    if (expiresAt < 10000000000) {\n      // It's in seconds, convert to milliseconds\n      expiresAtMs = expiresAt * 1000;\n    }\n    // else it's already in milliseconds (legacy data)\n\n    const timeUntilExpiry = expiresAtMs - now;\n    const isExpired = timeUntilExpiry < 0;\n    const isExpiringSoon = timeUntilExpiry < TOKEN_REFRESH_BUFFER_MS;\n\n    // If token is completely expired (past expiry time)\n    if (isExpired) {\n      console.log('[SafePlay Storage] Token expired:', {\n        expiresAt,\n        expiresAtMs,\n        now,\n        expiredAgo: Math.abs(timeUntilExpiry) / 1000 + ' seconds',\n        hasRefreshToken: !!refreshToken,\n        refreshTokenLength: refreshToken?.length,\n      });\n\n      if (refreshToken) {\n        const newToken = await refreshAuthToken();\n        if (newToken) {\n          return newToken;\n        }\n      }\n\n      // Refresh failed and token is expired - clear access token but keep refresh for manual retry\n      console.log('[SafePlay Storage] Token expired and refresh failed');\n      await chrome.storage.local.remove([STORAGE_KEYS.AUTH_TOKEN]);\n      return null;\n    }\n\n    // If token is expiring soon (within buffer) but not yet expired, try to refresh\n    // but still return the current token if refresh fails\n    if (isExpiringSoon) {\n      console.log('[SafePlay Storage] Token expiring soon:', {\n        expiresIn: timeUntilExpiry / 1000 + ' seconds',\n        hasRefreshToken: !!refreshToken,\n      });\n\n      if (refreshToken) {\n        const newToken = await refreshAuthToken();\n        if (newToken) {\n          return newToken;\n        }\n        // Refresh failed but token is still valid - use it anyway\n        console.log('[SafePlay Storage] Proactive refresh failed but token still valid, using existing token');\n      }\n    }\n  }\n\n  return token;\n}\n\n// Get raw auth token without refresh check (for internal use)\nexport async function getAuthTokenRaw(): Promise<string | null> {\n  const result = await chrome.storage.local.get(STORAGE_KEYS.AUTH_TOKEN);\n  return result[STORAGE_KEYS.AUTH_TOKEN] || null;\n}\n\n// Check if a refresh token exists locally (for checking if user has explicit session)\nexport async function hasRefreshToken(): Promise<boolean> {\n  const result = await chrome.storage.local.get(STORAGE_KEYS.REFRESH_TOKEN);\n  return !!result[STORAGE_KEYS.REFRESH_TOKEN];\n}\n\nexport async function setAuthToken(token: string, refreshToken?: string, expiresAt?: number): Promise<void> {\n  // Detailed logging to diagnose token storage issues\n  console.log('[SafePlay Storage] setAuthToken called:', {\n    hasToken: !!token,\n    tokenLength: token?.length,\n    hasRefreshToken: !!refreshToken,\n    refreshTokenLength: refreshToken?.length,\n    refreshTokenPreview: refreshToken ? `${refreshToken.substring(0, 10)}...` : 'none',\n    expiresAt,\n    expiresAtType: typeof expiresAt,\n  });\n\n  const data: Record<string, unknown> = {\n    [STORAGE_KEYS.AUTH_TOKEN]: token,\n  };\n\n  if (refreshToken) {\n    data[STORAGE_KEYS.REFRESH_TOKEN] = refreshToken;\n  }\n\n  if (expiresAt) {\n    // Normalize expiresAt to seconds\n    // If the value is > 10 billion, it's likely in milliseconds (ms timestamps are ~13 digits)\n    // If the value is < 10 billion, it's likely in seconds (second timestamps are ~10 digits)\n    let expiresAtSeconds = expiresAt;\n    if (expiresAt > 10000000000) {\n      console.log('[SafePlay Storage] expiresAt appears to be in milliseconds, converting to seconds');\n      expiresAtSeconds = Math.floor(expiresAt / 1000);\n    }\n    data[STORAGE_KEYS.TOKEN_EXPIRES_AT] = expiresAtSeconds;\n    console.log('[SafePlay Storage] Storing expiresAt:', expiresAtSeconds, '(seconds), expires:', new Date(expiresAtSeconds * 1000).toISOString());\n  }\n\n  await chrome.storage.local.set(data);\n  console.log('[SafePlay Storage] Auth tokens stored successfully');\n}\n\nexport async function clearAuthToken(): Promise<void> {\n  await chrome.storage.local.remove([\n    STORAGE_KEYS.AUTH_TOKEN,\n    STORAGE_KEYS.REFRESH_TOKEN,\n    STORAGE_KEYS.TOKEN_EXPIRES_AT,\n  ]);\n}\n\nexport async function getUserId(): Promise<string | null> {\n  const result = await chrome.storage.local.get(STORAGE_KEYS.USER_ID);\n  return result[STORAGE_KEYS.USER_ID] || null;\n}\n\nexport async function setUserId(userId: string): Promise<void> {\n  await chrome.storage.local.set({ [STORAGE_KEYS.USER_ID]: userId });\n}\n\nexport async function getSubscriptionTier(): Promise<SubscriptionTier | null> {\n  const result = await chrome.storage.local.get(STORAGE_KEYS.SUBSCRIPTION_TIER);\n  return result[STORAGE_KEYS.SUBSCRIPTION_TIER] || null;\n}\n\nexport async function setSubscriptionTier(tier: SubscriptionTier): Promise<void> {\n  await chrome.storage.local.set({ [STORAGE_KEYS.SUBSCRIPTION_TIER]: tier });\n}\n\n// Credit Info storage with caching\nexport async function getCreditInfo(): Promise<CreditInfo | null> {\n  try {\n    const result = await chrome.storage.local.get([\n      STORAGE_KEYS.CREDIT_INFO,\n      STORAGE_KEYS.CREDIT_CACHE_TIME,\n    ]);\n\n    const cacheTime = result[STORAGE_KEYS.CREDIT_CACHE_TIME];\n    const creditInfo = result[STORAGE_KEYS.CREDIT_INFO];\n\n    // Check if cache is valid\n    if (cacheTime && creditInfo && Date.now() - cacheTime < CREDIT_CACHE_DURATION) {\n      return creditInfo;\n    }\n\n    return null; // Cache expired or not present\n  } catch (error) {\n    console.error('[SafePlay Storage] Error getting credit info:', error);\n    return null;\n  }\n}\n\nexport async function setCreditInfo(creditInfo: CreditInfo): Promise<void> {\n  try {\n    await chrome.storage.local.set({\n      [STORAGE_KEYS.CREDIT_INFO]: creditInfo,\n      [STORAGE_KEYS.CREDIT_CACHE_TIME]: Date.now(),\n    });\n  } catch (error) {\n    console.error('[SafePlay Storage] Error setting credit info:', error);\n  }\n}\n\nexport async function clearCreditInfo(): Promise<void> {\n  await chrome.storage.local.remove([\n    STORAGE_KEYS.CREDIT_INFO,\n    STORAGE_KEYS.CREDIT_CACHE_TIME,\n  ]);\n}\n\n// Update credit info after a filter operation (optimistic update)\nexport async function updateCreditsAfterFilter(creditCost: number): Promise<void> {\n  try {\n    const currentInfo = await getCreditInfo();\n    if (currentInfo) {\n      const updatedInfo: CreditInfo = {\n        ...currentInfo,\n        available: Math.max(0, currentInfo.available - creditCost),\n        used_this_period: currentInfo.used_this_period + creditCost,\n        percent_consumed: Math.min(\n          100,\n          ((currentInfo.used_this_period + creditCost) / currentInfo.plan_allocation) * 100\n        ),\n      };\n      await setCreditInfo(updatedInfo);\n    }\n  } catch (error) {\n    console.error('[SafePlay Storage] Error updating credits after filter:', error);\n  }\n}\n\ninterface CachedTranscriptEntry {\n  transcript: Transcript;\n  timestamp: number;\n}\n\ninterface TranscriptCache {\n  [youtubeId: string]: CachedTranscriptEntry;\n}\n\nexport async function getCachedTranscript(\n  youtubeId: string\n): Promise<Transcript | null> {\n  try {\n    const result = await chrome.storage.local.get(STORAGE_KEYS.CACHED_TRANSCRIPTS);\n    const cache = result[STORAGE_KEYS.CACHED_TRANSCRIPTS] || {};\n    const entry = cache[youtubeId];\n\n    if (!entry) return null;\n\n    // Handle both old format (direct transcript) and new format (with timestamp)\n    if (entry.transcript) {\n      // New format with timestamp\n      entry.timestamp = Date.now();\n      await chrome.storage.local.set({ [STORAGE_KEYS.CACHED_TRANSCRIPTS]: cache });\n      return entry.transcript;\n    } else if (entry.segments) {\n      // Old format - transcript stored directly, migrate to new format\n      const transcript = entry as Transcript;\n      cache[youtubeId] = { transcript, timestamp: Date.now() };\n      await chrome.storage.local.set({ [STORAGE_KEYS.CACHED_TRANSCRIPTS]: cache });\n      return transcript;\n    }\n\n    return null;\n  } catch (error) {\n    console.error('[SafePlay Storage] Error getting cached transcript:', error);\n    return null;\n  }\n}\n\nexport async function setCachedTranscript(\n  youtubeId: string,\n  transcript: Transcript\n): Promise<void> {\n  try {\n    const result = await chrome.storage.local.get(STORAGE_KEYS.CACHED_TRANSCRIPTS);\n    let cache: TranscriptCache = result[STORAGE_KEYS.CACHED_TRANSCRIPTS] || {};\n\n    // Add new entry with timestamp\n    cache[youtubeId] = {\n      transcript,\n      timestamp: Date.now(),\n    };\n\n    // Enforce cache limit - remove oldest entries if over limit\n    const entries = Object.entries(cache);\n    if (entries.length > MAX_CACHED_TRANSCRIPTS) {\n      // Sort by timestamp (oldest first) and keep only the newest\n      entries.sort((a, b) => a[1].timestamp - b[1].timestamp);\n      const toKeep = entries.slice(-MAX_CACHED_TRANSCRIPTS);\n      cache = Object.fromEntries(toKeep);\n      console.log(`[SafePlay Storage] Trimmed transcript cache to ${MAX_CACHED_TRANSCRIPTS} entries`);\n    }\n\n    await chrome.storage.local.set({ [STORAGE_KEYS.CACHED_TRANSCRIPTS]: cache });\n  } catch (error: unknown) {\n    // Handle quota exceeded error\n    if (error instanceof Error && error.message.includes('quota')) {\n      console.warn('[SafePlay Storage] Quota exceeded, clearing transcript cache...');\n      await clearCachedTranscripts();\n      // Retry with fresh cache\n      try {\n        const freshCache: TranscriptCache = {\n          [youtubeId]: { transcript, timestamp: Date.now() }\n        };\n        await chrome.storage.local.set({ [STORAGE_KEYS.CACHED_TRANSCRIPTS]: freshCache });\n        console.log('[SafePlay Storage] Cache cleared and new transcript saved');\n      } catch (retryError) {\n        console.error('[SafePlay Storage] Failed to save transcript after clearing cache:', retryError);\n      }\n    } else {\n      console.error('[SafePlay Storage] Error caching transcript:', error);\n    }\n  }\n}\n\nexport async function clearCachedTranscripts(): Promise<void> {\n  await chrome.storage.local.remove(STORAGE_KEYS.CACHED_TRANSCRIPTS);\n}\n\nexport async function clearAllData(): Promise<void> {\n  await chrome.storage.local.clear();\n}\n\nexport async function isAuthenticated(): Promise<boolean> {\n  const token = await getAuthToken();\n  return token !== null;\n}\n\n/**\n * Check if user is authenticated WITHOUT triggering any auto-refresh.\n * This is a strict check that only looks at local storage.\n * Use this when you need to verify auth state without potentially\n * re-authenticating via website cookies.\n */\nexport async function isAuthenticatedStrict(): Promise<boolean> {\n  const token = await getAuthTokenRaw();\n  if (!token) {\n    return false;\n  }\n\n  // Also check if token is expired\n  const result = await chrome.storage.local.get(STORAGE_KEYS.TOKEN_EXPIRES_AT);\n  const expiresAt = result[STORAGE_KEYS.TOKEN_EXPIRES_AT];\n\n  if (expiresAt) {\n    const now = Date.now();\n    let expiresAtMs = expiresAt;\n    if (expiresAt < 10000000000) {\n      // It's in seconds, convert to milliseconds\n      expiresAtMs = expiresAt * 1000;\n    }\n\n    // Token is expired\n    if (expiresAtMs < now) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n// Filtered Videos Storage - tracks which videos have been filtered\nexport async function getFilteredVideos(): Promise<string[]> {\n  try {\n    const result = await chrome.storage.local.get(STORAGE_KEYS.FILTERED_VIDEOS);\n    return result[STORAGE_KEYS.FILTERED_VIDEOS] || [];\n  } catch (error) {\n    console.error('[SafePlay Storage] Error getting filtered videos:', error);\n    return [];\n  }\n}\n\nexport async function addFilteredVideo(youtubeId: string): Promise<void> {\n  try {\n    const videos = await getFilteredVideos();\n    if (!videos.includes(youtubeId)) {\n      videos.push(youtubeId);\n      // Keep only last 500 videos to prevent storage bloat\n      const trimmedVideos = videos.slice(-500);\n      await chrome.storage.local.set({ [STORAGE_KEYS.FILTERED_VIDEOS]: trimmedVideos });\n    }\n  } catch (error) {\n    console.error('[SafePlay Storage] Error adding filtered video:', error);\n  }\n}\n\nexport async function isVideoFiltered(youtubeId: string): Promise<boolean> {\n  try {\n    const videos = await getFilteredVideos();\n    return videos.includes(youtubeId);\n  } catch (error) {\n    console.error('[SafePlay Storage] Error checking if video filtered:', error);\n    return false;\n  }\n}\n\nexport async function removeFilteredVideo(youtubeId: string): Promise<void> {\n  const videos = await getFilteredVideos();\n  const filtered = videos.filter(id => id !== youtubeId);\n  await chrome.storage.local.set({ [STORAGE_KEYS.FILTERED_VIDEOS]: filtered });\n}\n\nexport async function clearFilteredVideos(): Promise<void> {\n  await chrome.storage.local.remove(STORAGE_KEYS.FILTERED_VIDEOS);\n}\n\n// Profile cache duration in milliseconds (10 minutes)\nconst PROFILE_CACHE_DURATION = 10 * 60 * 1000;\n\n// User Profile Storage\nexport async function getUserProfile(): Promise<UserProfile | null> {\n  try {\n    const result = await chrome.storage.local.get([\n      STORAGE_KEYS.USER_PROFILE,\n      STORAGE_KEYS.PROFILE_CACHE_TIME,\n    ]);\n\n    const cacheTime = result[STORAGE_KEYS.PROFILE_CACHE_TIME];\n    const profile = result[STORAGE_KEYS.USER_PROFILE];\n\n    // Check if cache is valid\n    if (cacheTime && profile && Date.now() - cacheTime < PROFILE_CACHE_DURATION) {\n      return profile;\n    }\n\n    return null;\n  } catch (error) {\n    console.error('[SafePlay Storage] Error getting user profile:', error);\n    return null;\n  }\n}\n\nexport async function setUserProfile(profile: UserProfile): Promise<void> {\n  try {\n    await chrome.storage.local.set({\n      [STORAGE_KEYS.USER_PROFILE]: profile,\n      [STORAGE_KEYS.PROFILE_CACHE_TIME]: Date.now(),\n    });\n  } catch (error) {\n    console.error('[SafePlay Storage] Error setting user profile:', error);\n  }\n}\n\nexport async function getUserSubscription(): Promise<UserSubscription | null> {\n  try {\n    const result = await chrome.storage.local.get(STORAGE_KEYS.USER_SUBSCRIPTION);\n    return result[STORAGE_KEYS.USER_SUBSCRIPTION] || null;\n  } catch (error) {\n    console.error('[SafePlay Storage] Error getting user subscription:', error);\n    return null;\n  }\n}\n\nexport async function setUserSubscription(subscription: UserSubscription | null): Promise<void> {\n  try {\n    if (subscription) {\n      await chrome.storage.local.set({ [STORAGE_KEYS.USER_SUBSCRIPTION]: subscription });\n    } else {\n      await chrome.storage.local.remove(STORAGE_KEYS.USER_SUBSCRIPTION);\n    }\n  } catch (error) {\n    console.error('[SafePlay Storage] Error setting user subscription:', error);\n  }\n}\n\nexport async function getUserCredits(): Promise<UserCredits | null> {\n  try {\n    const result = await chrome.storage.local.get(STORAGE_KEYS.USER_CREDITS);\n    return result[STORAGE_KEYS.USER_CREDITS] || null;\n  } catch (error) {\n    console.error('[SafePlay Storage] Error getting user credits:', error);\n    return null;\n  }\n}\n\nexport async function setUserCredits(credits: UserCredits | null): Promise<void> {\n  try {\n    if (credits) {\n      await chrome.storage.local.set({ [STORAGE_KEYS.USER_CREDITS]: credits });\n    } else {\n      await chrome.storage.local.remove(STORAGE_KEYS.USER_CREDITS);\n    }\n  } catch (error) {\n    console.error('[SafePlay Storage] Error setting user credits:', error);\n  }\n}\n\n// Clear all auth-related data (for logout)\nexport async function clearAuthData(): Promise<void> {\n  try {\n    await chrome.storage.local.remove([\n      STORAGE_KEYS.AUTH_TOKEN,\n      STORAGE_KEYS.REFRESH_TOKEN,\n      STORAGE_KEYS.TOKEN_EXPIRES_AT,\n      STORAGE_KEYS.USER_ID,\n      STORAGE_KEYS.SUBSCRIPTION_TIER,\n      STORAGE_KEYS.CREDIT_INFO,\n      STORAGE_KEYS.CREDIT_CACHE_TIME,\n      STORAGE_KEYS.USER_PROFILE,\n      STORAGE_KEYS.USER_SUBSCRIPTION,\n      STORAGE_KEYS.USER_CREDITS,\n      STORAGE_KEYS.PROFILE_CACHE_TIME,\n    ]);\n    console.log('[SafePlay Storage] Auth data cleared');\n  } catch (error) {\n    console.error('[SafePlay Storage] Error clearing auth data:', error);\n  }\n}\n\n// Get full auth state\nexport async function getFullAuthState(): Promise<{\n  isAuthenticated: boolean;\n  profile: UserProfile | null;\n  subscription: UserSubscription | null;\n  credits: UserCredits | null;\n  token: string | null;\n}> {\n  const token = await getAuthToken();\n  const profile = await getUserProfile();\n  const subscription = await getUserSubscription();\n  const credits = await getUserCredits();\n\n  return {\n    isAuthenticated: token !== null,\n    profile,\n    subscription,\n    credits,\n    token,\n  };\n}\n","// SafePlay Content Script - Main Entry Point\nimport { ResilientInjector } from './resilient-injector';\nimport { VideoController } from './video-controller';\nimport { SmoothProgressAnimator } from './smooth-progress';\nimport { CaptionFilter } from './caption-filter';\nimport { TimelineMarkers } from './timeline-markers';\nimport { CreditConfirmation, showAuthRequiredMessage, showFilterErrorNotification } from './credit-confirmation';\nimport { UserPreferences, DEFAULT_PREFERENCES, Transcript, ButtonStateInfo, PreviewData } from '../types';\nimport { addFilteredVideo, isVideoFiltered } from '../utils/storage';\nimport './styles.css';\n\nconst DEBUG = true;\n\nfunction log(...args: unknown[]): void {\n  if (DEBUG) {\n    console.log('[SafePlay]', ...args);\n  }\n}\n\n// Check if the extension context is still valid (not invalidated by extension reload)\nfunction isExtensionContextValid(): boolean {\n  try {\n    // Accessing chrome.runtime.id will throw if context is invalidated\n    return !!chrome.runtime?.id;\n  } catch {\n    return false;\n  }\n}\n\n// Safe wrapper for chrome.runtime.sendMessage\nasync function safeSendMessage<T>(message: unknown): Promise<T | null> {\n  if (!isExtensionContextValid()) {\n    log('Extension context invalidated, skipping message');\n    return null;\n  }\n  try {\n    return await chrome.runtime.sendMessage(message);\n  } catch (error) {\n    // Extension context might have been invalidated during the call\n    if (String(error).includes('Extension context invalidated')) {\n      log('Extension context invalidated during message');\n      return null;\n    }\n    throw error;\n  }\n}\n\nclass SafePlayContentScript {\n  private injector: ResilientInjector;\n  private videoController: VideoController | null = null;\n  private captionFilter: CaptionFilter;\n  private preferences: UserPreferences = DEFAULT_PREFERENCES;\n  private currentVideoId: string | null = null;\n  private filteringVideoId: string | null = null; // Track which video is being filtered (for Shorts)\n  private isProcessing = false;\n  private videoWasPlaying = false; // Track if video was playing before we paused it\n  private progressAnimator: SmoothProgressAnimator | null = null;\n  private lastIntervalCount = 0; // Store interval count for toggle restore\n  private isFilterActive = false; // Track if filter is currently active\n  private timelineMarkers: TimelineMarkers | null = null; // Visual markers on progress bar\n  private navigationId = 0; // Incremented on each navigation to cancel stale async operations\n  private pendingAuthVideoId: string | null = null; // Track video ID when waiting for auth\n\n  constructor() {\n    // Initialize resilient injector for video watch page\n    this.injector = new ResilientInjector({\n      onButtonClick: (youtubeId) => this.onFilterButtonClick(youtubeId),\n      onToggleFilter: () => this.toggleFilterFromButton(),\n      debug: DEBUG,\n    });\n\n    // Initialize video controller\n    this.videoController = new VideoController({\n      onStateChange: (state) => this.onVideoStateChange(state),\n      debug: DEBUG,\n    });\n\n    // Initialize caption filter\n    this.captionFilter = new CaptionFilter({ debug: DEBUG });\n  }\n\n  async initialize(): Promise<void> {\n    log('Initializing SafePlay content script');\n\n    // Load user preferences\n    await this.loadPreferences();\n\n    // Start injector - it handles watch page and Shorts detection internally\n    this.injector.start();\n\n    // Check if we're on a watch page or Shorts page\n    if (this.isWatchPage() || this.isShortsPage()) {\n      this.currentVideoId = this.getVideoIdFromUrl();\n\n      // Check for auto-enable after a short delay (allow button to inject first)\n      if (this.currentVideoId) {\n        setTimeout(() => this.checkAutoEnable(), 1000);\n      }\n    }\n\n    // Listen for messages from background/popup\n    this.setupMessageListener();\n\n    // Listen for URL changes (YouTube SPA)\n    this.setupNavigationListener();\n\n    log('SafePlay initialized');\n  }\n\n  private async loadPreferences(): Promise<void> {\n    try {\n      const response = await safeSendMessage<{ success: boolean; data?: UserPreferences }>({\n        type: 'GET_PREFERENCES',\n      });\n\n      if (response?.success && response.data) {\n        this.preferences = response.data;\n      }\n    } catch (error) {\n      log('Failed to load preferences:', error);\n    }\n  }\n\n  private isWatchPage(): boolean {\n    return window.location.pathname === '/watch';\n  }\n\n  private isShortsPage(): boolean {\n    return window.location.pathname.startsWith('/shorts');\n  }\n\n  private getVideoIdFromUrl(): string | null {\n    // Check for regular watch page\n    if (this.isWatchPage()) {\n      const params = new URLSearchParams(window.location.search);\n      return params.get('v');\n    }\n\n    // Check for Shorts page\n    if (this.isShortsPage()) {\n      const match = window.location.pathname.match(/\\/shorts\\/([a-zA-Z0-9_-]+)/);\n      return match ? match[1] : null;\n    }\n\n    return null;\n  }\n\n  private updateButtonState(stateInfo: ButtonStateInfo): void {\n    this.injector.updateButtonState(stateInfo);\n  }\n\n  // Get the video element\n  private getVideoElement(): HTMLVideoElement | null {\n    return document.querySelector('video.html5-main-video') ||\n           document.querySelector('video.video-stream') ||\n           document.querySelector('#movie_player video') ||\n           document.querySelector('video');\n  }\n\n  // Resume video if it was playing before we paused it\n  private resumeVideoIfNeeded(): void {\n    if (this.videoWasPlaying) {\n      const video = this.getVideoElement();\n      if (video) {\n        video.play();\n        log('Video resumed');\n      }\n      this.videoWasPlaying = false;\n    }\n  }\n\n  // Main filter flow - called when SafePlay button is clicked\n  private async onFilterButtonClick(youtubeId: string): Promise<void> {\n    if (this.isProcessing) {\n      log('Already processing, ignoring click');\n      return;\n    }\n\n    log('Filter button clicked for:', youtubeId);\n\n    // Step 0: Check authentication FIRST - strict check without auto-refresh\n    // This prevents the extension from silently re-authenticating via website cookies\n    try {\n      const authResponse = await safeSendMessage<{ success: boolean; data?: { authenticated: boolean } }>({\n        type: 'CHECK_AUTH_STRICT',\n      });\n\n      if (!authResponse?.success || !authResponse?.data?.authenticated) {\n        log('User not authenticated, showing sign in modal');\n        this.pendingAuthVideoId = youtubeId; // Store video ID to filter after auth\n        showAuthRequiredMessage();\n        return;\n      }\n    } catch (error) {\n      log('Auth check failed:', error);\n      this.pendingAuthVideoId = youtubeId; // Store video ID to filter after auth\n      showAuthRequiredMessage();\n      return;\n    }\n\n    this.isProcessing = true;\n    this.currentVideoId = youtubeId;\n    this.filteringVideoId = youtubeId;\n\n    try {\n      // Step 1: Get preview (credit cost and video info)\n      this.updateButtonState({ state: 'connecting', text: 'Checking...', videoId: youtubeId });\n\n      const previewResponse = await safeSendMessage<{ success: boolean; error?: string; data?: PreviewData }>({\n        type: 'GET_PREVIEW',\n        payload: { youtubeId },\n      });\n\n      // Handle extension context invalidated\n      if (!previewResponse) {\n        this.isProcessing = false;\n        this.filteringVideoId = null;\n        this.updateButtonState({ state: 'error', text: 'Reload page', error: 'Extension reloaded', videoId: youtubeId });\n        return;\n      }\n\n      // Handle auth errors\n      if (!previewResponse.success) {\n        if (previewResponse.error?.includes('UNAUTHORIZED') || previewResponse.error?.includes('401')) {\n          this.isProcessing = false;\n          this.filteringVideoId = null;\n          this.updateButtonState({ state: 'idle', text: 'SafePlay', videoId: youtubeId });\n          showAuthRequiredMessage();\n          return;\n        }\n        throw new Error(previewResponse.error || 'Failed to get preview');\n      }\n\n      if (!previewResponse.data) {\n        throw new Error('No preview data received');\n      }\n\n      const previewData: PreviewData = previewResponse.data;\n\n      // If cached and has sufficient credits (free), skip confirmation\n      if (previewData.isCached && previewData.creditCost === 0) {\n        log('Video is cached, skipping confirmation');\n        // Reset isProcessing since proceedWithFiltering will set it again\n        this.isProcessing = false;\n        await this.proceedWithFiltering(youtubeId);\n        return;\n      }\n\n      // Pause video before showing confirmation dialog so user can review without missing content\n      const video = this.getVideoElement();\n      const videoWasPlayingBeforeDialog = !!(video && !video.paused);\n      if (video && videoWasPlayingBeforeDialog) {\n        video.pause();\n        log('Video paused for credit confirmation');\n      }\n\n      // Show credit confirmation dialog\n      this.updateButtonState({ state: 'idle', text: 'SafePlay', videoId: youtubeId });\n      this.isProcessing = false;\n\n      const confirmation = new CreditConfirmation({\n        onConfirm: async () => {\n          log('User confirmed filtering');\n          // Pass the video state to proceedWithFiltering\n          this.videoWasPlaying = videoWasPlayingBeforeDialog;\n          await this.proceedWithFiltering(youtubeId);\n        },\n        onCancel: () => {\n          log('User cancelled filtering');\n          this.filteringVideoId = null;\n          // Resume video if it was playing before we showed the dialog\n          if (videoWasPlayingBeforeDialog && video) {\n            video.play();\n            log('Video resumed after cancel');\n          }\n        },\n        debug: DEBUG,\n      });\n\n      confirmation.show(previewData);\n    } catch (error) {\n      log('Preview request failed:', error);\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      this.updateButtonState({\n        state: 'error',\n        text: 'Retry',\n        error: `${errorMessage} - Click to retry`,\n        videoId: youtubeId,\n      });\n      this.isProcessing = false;\n      this.filteringVideoId = null;\n      // Show notification about the filtering issue\n      showFilterErrorNotification();\n    }\n  }\n\n  // Proceed with filtering after user confirmation or for cached videos\n  private async proceedWithFiltering(youtubeId: string): Promise<void> {\n    if (this.isProcessing) {\n      log('Already processing, ignoring');\n      return;\n    }\n\n    log('Proceeding with filtering for:', youtubeId);\n    this.isProcessing = true;\n    this.filteringVideoId = youtubeId;\n    // Capture navigation ID to detect if user navigates away during filtering\n    const startNavigationId = this.navigationId;\n\n    // Video should already be paused from the confirmation dialog\n    // If not (e.g., for cached videos that skip confirmation), pause it now\n    const video = this.getVideoElement();\n    if (!this.videoWasPlaying) {\n      // Only set videoWasPlaying if it wasn't already set by the confirmation flow\n      this.videoWasPlaying = !!(video && !video.paused);\n      if (video && this.videoWasPlaying) {\n        video.pause();\n        log('Video paused while loading filter');\n      }\n    }\n\n    try {\n      // Step 1: Connecting\n      this.updateButtonState({ state: 'connecting', text: 'Connecting...', videoId: youtubeId });\n\n      // Request filter from background script (uses START_FILTER which deducts credits)\n      const response = await safeSendMessage<{\n        success: boolean;\n        error?: string;\n        data?: { status: string; transcript?: Transcript; jobId?: string; error?: string; error_code?: string };\n      }>({\n        type: 'START_FILTER',\n        payload: { youtubeId, filterType: this.preferences.filterMode },\n      });\n\n      // Check if user navigated away during the request\n      if (this.navigationId !== startNavigationId) {\n        log(`Filtering aborted for ${youtubeId}: user navigated away during START_FILTER`);\n        return;\n      }\n\n      // Handle extension context invalidated\n      if (!response) {\n        this.updateButtonState({ state: 'error', text: 'Reload page', error: 'Extension reloaded', videoId: youtubeId });\n        this.resumeVideoIfNeeded();\n        return;\n      }\n\n      if (!response.success) {\n        throw new Error(response.error || 'Failed to request filter');\n      }\n\n      if (!response.data) {\n        throw new Error('No filter data received');\n      }\n\n      const { status, transcript, jobId, error_code, error } = response.data;\n\n      // Handle immediate failure with error_code\n      if (status === 'failed') {\n        if (error_code === 'AGE_RESTRICTED') {\n          this.updateButtonState({\n            state: 'age-restricted',\n            text: 'Age-Restricted',\n            error: error || 'This video is age-restricted by YouTube. SafePlay cannot filter age-restricted content.',\n            videoId: youtubeId,\n          });\n        } else if (error_code === 'INSUFFICIENT_CREDITS') {\n          this.updateButtonState({\n            state: 'error',\n            text: 'No Credits',\n            error: error || 'Insufficient credits. Please purchase more credits at safeplay.app',\n            videoId: youtubeId,\n          });\n        } else {\n          this.updateButtonState({\n            state: 'error',\n            text: 'Retry',\n            error: (error || 'Failed to filter video') + ' - Click to retry',\n            videoId: youtubeId,\n          });\n          // Show notification about the filtering issue\n          showFilterErrorNotification();\n        }\n        // Resume video since we can't filter\n        if (this.videoWasPlaying) {\n          const video = this.getVideoElement();\n          if (video) {\n            video.play();\n            log('Video resumed after error');\n          }\n          this.videoWasPlaying = false;\n        }\n        this.isProcessing = false;\n        this.filteringVideoId = null;\n        return;\n      }\n\n      if ((status === 'cached' || status === 'completed') && transcript) {\n        // Transcript was cached (locally or on server), skip to processing\n        log('Using cached transcript');\n\n        // Final navigation check before applying filter\n        if (this.navigationId !== startNavigationId) {\n          log(`Filtering aborted for ${youtubeId}: user navigated away before applying cached filter`);\n          return;\n        }\n\n        this.updateButtonState({ state: 'processing', text: 'Processing...', videoId: youtubeId });\n        await this.applyFilter(transcript);\n      } else if (status === 'processing' && jobId) {\n        // Need to poll for job completion\n        log('Job started, polling for completion:', jobId);\n        await this.pollJobStatus(jobId);\n      } else {\n        throw new Error('Unexpected API response');\n      }\n    } catch (error) {\n      log('Filter request failed:', error);\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      this.updateButtonState({\n        state: 'error',\n        text: 'Retry',\n        error: `${errorMessage} - Click to retry`,\n        videoId: youtubeId,\n      });\n      // Resume video on error\n      if (this.videoWasPlaying) {\n        const video = this.getVideoElement();\n        if (video) {\n          video.play();\n          log('Video resumed after error');\n        }\n        this.videoWasPlaying = false;\n      }\n      this.isProcessing = false;\n      this.filteringVideoId = null;\n      // Show notification about the filtering issue\n      showFilterErrorNotification();\n    }\n  }\n\n  // Poll for job status with progress updates\n  private async pollJobStatus(jobId: string): Promise<void> {\n    const maxAttempts = 180; // 6 minutes max (2s intervals)\n    const pollInterval = 2000;\n    let attempts = 0;\n    // Capture the video ID being filtered at the start\n    const videoId = this.filteringVideoId;\n    // Capture navigation ID to detect if user navigated away during polling\n    const startNavigationId = this.navigationId;\n\n    // Initialize smooth progress animator\n    this.progressAnimator = new SmoothProgressAnimator(\n      (progress, text) => {\n        this.updateButtonState({\n          state: 'processing',\n          text,\n          progress,\n          videoId: videoId || undefined,\n        });\n      },\n      'Analyzing'\n    );\n    this.progressAnimator.start();\n\n    while (attempts < maxAttempts) {\n      // Check if user navigated away - if so, abort polling silently\n      if (this.navigationId !== startNavigationId) {\n        log(`Polling aborted for ${videoId}: user navigated away`);\n        if (this.progressAnimator) {\n          this.progressAnimator.stop();\n          this.progressAnimator = null;\n        }\n        return;\n      }\n\n      try {\n        const response = await safeSendMessage<{\n          success: boolean;\n          error?: string;\n          data?: { status: string; progress: number; transcript?: Transcript; error?: string; error_code?: string };\n        }>({\n          type: 'CHECK_JOB',\n          payload: { jobId },\n        });\n\n        // Check again after async call - user may have navigated during the request\n        if (this.navigationId !== startNavigationId) {\n          log(`Polling aborted for ${videoId}: user navigated away during request`);\n          if (this.progressAnimator) {\n            this.progressAnimator.stop();\n            this.progressAnimator = null;\n          }\n          return;\n        }\n\n        // Handle extension context invalidated\n        if (!response) {\n          this.progressAnimator?.stop();\n          this.progressAnimator = null;\n          this.updateButtonState({ state: 'error', text: 'Reload page', error: 'Extension reloaded', videoId: videoId || undefined });\n          this.resumeVideoIfNeeded();\n          return;\n        }\n\n        if (!response.success) {\n          throw new Error(response.error || 'Failed to check job status');\n        }\n\n        if (!response.data) {\n          throw new Error('No job status data received');\n        }\n\n        const { status, progress, transcript, error, error_code } = response.data;\n\n        log(`Job status: ${status}, progress: ${progress}%`);\n\n        // Calculate actual progress and update animator target\n        switch (status) {\n          case 'pending':\n            this.progressAnimator.setTarget(5);\n            break;\n\n          case 'downloading':\n            // Scale downloading: 0-100% server progress -> 5-30% display\n            this.progressAnimator.setTarget(5 + progress * 0.25);\n            break;\n\n          case 'transcribing':\n            // Scale transcribing: 0-100% server progress -> 30-85% display\n            this.progressAnimator.setTarget(30 + progress * 0.55);\n            break;\n\n          case 'completed':\n            if (transcript) {\n              // Signal completion - animator will smoothly reach 100%\n              this.progressAnimator.setTarget(95);\n              // Give a moment for progress to animate up\n              await new Promise((resolve) => setTimeout(resolve, 300));\n\n              // Check if user navigated away during animation\n              if (this.navigationId !== startNavigationId) {\n                log(`Polling aborted for ${videoId}: user navigated away during completion animation`);\n                if (this.progressAnimator) {\n                  this.progressAnimator.stop();\n                  this.progressAnimator = null;\n                }\n                return;\n              }\n\n              this.progressAnimator.complete();\n              // Wait for animation to finish\n              await new Promise((resolve) => setTimeout(resolve, 500));\n\n              // Final navigation check before applying filter\n              if (this.navigationId !== startNavigationId) {\n                log(`Polling aborted for ${videoId}: user navigated away before filter apply`);\n                if (this.progressAnimator) {\n                  this.progressAnimator.stop();\n                  this.progressAnimator = null;\n                }\n                return;\n              }\n\n              this.progressAnimator.stop();\n              this.progressAnimator = null;\n              await this.applyFilter(transcript);\n              return;\n            } else {\n              throw new Error('Job completed but no transcript returned');\n            }\n\n          case 'failed':\n            // Check for specific error codes that need special handling\n            if (error_code === 'AGE_RESTRICTED') {\n              // Stop animator\n              if (this.progressAnimator) {\n                this.progressAnimator.stop();\n                this.progressAnimator = null;\n              }\n              // Show age-restricted state with helpful message\n              this.updateButtonState({\n                state: 'age-restricted',\n                text: 'Age-Restricted',\n                error: error || 'This video is age-restricted by YouTube. SafePlay cannot filter age-restricted content.',\n                videoId: videoId || undefined,\n              });\n              this.isProcessing = false;\n              this.filteringVideoId = null;\n              // Resume video since we can't filter\n              if (this.videoWasPlaying) {\n                const video = this.getVideoElement();\n                if (video) {\n                  video.play();\n                  log('Video resumed after age-restricted detection');\n                }\n                this.videoWasPlaying = false;\n              }\n              return;\n            }\n            throw new Error(error || 'Processing failed');\n\n          default:\n            // Generic processing state\n            this.progressAnimator.setTarget(progress);\n        }\n\n        // Wait before next poll\n        await new Promise((resolve) => setTimeout(resolve, pollInterval));\n        attempts++;\n      } catch (error) {\n        log('Poll error:', error);\n        // Stop animator on error\n        if (this.progressAnimator) {\n          this.progressAnimator.stop();\n          this.progressAnimator = null;\n        }\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        this.updateButtonState({\n          state: 'error',\n          text: 'Retry',\n          error: `${errorMessage} - Click to retry`,\n          videoId: videoId || undefined,\n        });\n        this.isProcessing = false;\n        this.filteringVideoId = null;\n        // Show notification about the filtering issue\n        showFilterErrorNotification();\n        return;\n      }\n    }\n\n    // Timeout - stop animator\n    if (this.progressAnimator) {\n      this.progressAnimator.stop();\n      this.progressAnimator = null;\n    }\n    this.updateButtonState({\n      state: 'error',\n      text: 'Retry',\n      error: 'Processing timed out - Click to retry',\n      videoId: videoId || undefined,\n    });\n    this.isProcessing = false;\n    this.filteringVideoId = null;\n    // Show notification about the filtering issue\n    showFilterErrorNotification();\n  }\n\n  // Apply the filter using the transcript\n  private async applyFilter(transcript: Transcript): Promise<void> {\n    if (!this.videoController) {\n      throw new Error('Video controller not initialized');\n    }\n\n    // Use filteringVideoId which tracks the video being filtered\n    const videoId = this.filteringVideoId || this.currentVideoId;\n    if (!videoId) {\n      throw new Error('No video ID');\n    }\n\n    // Capture navigation ID to detect if user navigates during async operations\n    const startNavigationId = this.navigationId;\n\n    // Log transcript structure to verify character-level data\n    log('Transcript received for filtering:', {\n      id: transcript.id,\n      segmentCount: transcript.segments?.length,\n      sampleSegment: transcript.segments?.[0] ? {\n        text: transcript.segments[0].text,\n        times: `${transcript.segments[0].start_time}s - ${transcript.segments[0].end_time}s`,\n        hasCharacters: !!transcript.segments[0].characters,\n        charCount: transcript.segments[0].characters?.length,\n        sampleChars: transcript.segments[0].characters?.slice(0, 3),\n      } : null,\n    });\n\n    try {\n      // Initialize video controller with transcript\n      await this.videoController.initialize(videoId, this.preferences);\n\n      // Check if user navigated away during initialization\n      if (this.navigationId !== startNavigationId) {\n        log(`Filter apply aborted for ${videoId}: user navigated away during initialization`);\n        return;\n      }\n\n      this.videoController.onTranscriptReceived(transcript);\n\n      // Apply the filter\n      await this.videoController.applyFilter();\n\n      // Check if user navigated away during filter application\n      if (this.navigationId !== startNavigationId) {\n        log(`Filter apply aborted for ${videoId}: user navigated away during filter application`);\n        return;\n      }\n\n      // Get the interval count and mute intervals for display\n      const state = this.videoController.getState();\n      const intervalCount = state.intervalCount || 0;\n      const muteIntervals = this.videoController.getMuteIntervals();\n\n      // Store interval count for toggle restore\n      this.lastIntervalCount = intervalCount;\n      this.isFilterActive = true;\n\n      // Start caption filtering as well\n      this.captionFilter.initialize(this.preferences, muteIntervals);\n      this.captionFilter.start();\n      log('Caption filter started');\n\n      // Initialize timeline markers to show profanity locations on progress bar\n      const video = this.getVideoElement();\n      if (video && muteIntervals.length > 0) {\n        this.timelineMarkers = new TimelineMarkers({ debug: DEBUG });\n        this.timelineMarkers.initialize(video, muteIntervals);\n        log('Timeline markers initialized');\n      }\n\n      // Update button to filtering state\n      this.updateButtonState({\n        state: 'filtering',\n        text: `Censored (${intervalCount})`,\n        intervalCount,\n        videoId,\n      });\n\n      log(`Filter applied successfully. ${intervalCount} profanity instances will be muted.`);\n\n      // Store this video as filtered for auto-enable feature\n      if (videoId) {\n        await addFilteredVideo(videoId);\n      }\n\n      // Resume video if it was playing before\n      if (this.videoWasPlaying) {\n        const video = this.getVideoElement();\n        if (video) {\n          video.play();\n          log('Video resumed after filter applied');\n        }\n        this.videoWasPlaying = false;\n      }\n\n      // Create player controls for toggling\n      this.injectPlayerControls();\n    } catch (error) {\n      log('Failed to apply filter:', error);\n      // Resume video even on error\n      if (this.videoWasPlaying) {\n        const video = this.getVideoElement();\n        if (video) {\n          video.play();\n          log('Video resumed after filter error');\n        }\n        this.videoWasPlaying = false;\n      }\n      throw error;\n    } finally {\n      this.isProcessing = false;\n      this.filteringVideoId = null;\n    }\n  }\n\n  private injectPlayerControls(): void {\n    // Check if already injected\n    if (document.querySelector('.safeplay-player-controls')) return;\n\n    // Wait for player controls to be available\n    const waitForControls = () => {\n      const rightControls = document.querySelector('.ytp-right-controls');\n      if (rightControls) {\n        this.createPlayerButton(rightControls);\n      } else {\n        setTimeout(waitForControls, 500);\n      }\n    };\n\n    waitForControls();\n  }\n\n  private createPlayerButton(container: Element): void {\n    const button = document.createElement('button');\n    button.className = 'ytp-button safeplay-player-controls safeplay-active';\n    button.title = 'SafePlay Filter Active - Click to toggle';\n    button.innerHTML = `\n      <svg viewBox=\"0 0 24 24\" fill=\"currentColor\" width=\"24\" height=\"24\">\n        <path d=\"M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm-2 16l-4-4 1.41-1.41L10 14.17l6.59-6.59L18 9l-8 8z\"/>\n      </svg>\n    `;\n\n    button.addEventListener('click', () => this.toggleFilter());\n\n    // Insert before settings button (if it's a direct child)\n    const settingsButton = container.querySelector('.ytp-settings-button');\n    if (settingsButton && settingsButton.parentElement === container) {\n      container.insertBefore(button, settingsButton);\n    } else {\n      // Just prepend to the container\n      container.insertBefore(button, container.firstChild);\n    }\n  }\n\n  // Toggle filter from player controls button\n  private async toggleFilter(): Promise<void> {\n    await this.toggleFilterFromButton();\n  }\n\n  // Toggle filter on/off - called from main button or player controls\n  private async toggleFilterFromButton(): Promise<void> {\n    if (!this.videoController) return;\n\n    const playerButton = document.querySelector('.safeplay-player-controls');\n\n    if (this.isFilterActive) {\n      // Disable filter\n      this.videoController.stop();\n      this.captionFilter.stop();\n      this.timelineMarkers?.hide();\n      this.isFilterActive = false;\n\n      playerButton?.classList.remove('safeplay-active');\n      playerButton?.setAttribute('title', 'SafePlay Filter Paused - Click to resume');\n\n      this.updateButtonState({\n        state: 'paused',\n        text: 'Paused',\n        intervalCount: this.lastIntervalCount,\n      });\n\n      log('Filter paused by user');\n    } else if (this.currentVideoId && this.lastIntervalCount > 0) {\n      // Resume filtering (we have data from before)\n      this.videoController.resume();\n      this.captionFilter.start();\n      this.timelineMarkers?.show();\n      this.isFilterActive = true;\n\n      playerButton?.classList.add('safeplay-active');\n      playerButton?.setAttribute('title', 'SafePlay Filter Active - Click to toggle');\n\n      this.updateButtonState({\n        state: 'filtering',\n        text: `Censored (${this.lastIntervalCount})`,\n        intervalCount: this.lastIntervalCount,\n      });\n\n      log('Filter resumed by user');\n    }\n  }\n\n  private onVideoStateChange(state: ReturnType<VideoController['getState']>): void {\n    log('Video state changed:', state);\n\n    // Notify popup of state change (if extension context still valid)\n    if (!isExtensionContextValid()) {\n      log('Extension context invalidated, skipping state change notification');\n      return;\n    }\n\n    chrome.runtime.sendMessage({\n      type: 'VIDEO_STATE_CHANGED',\n      payload: state,\n    }).catch(() => {\n      // Popup might not be open or extension context invalidated\n    });\n  }\n\n  private setupMessageListener(): void {\n    // Check if extension context is still valid before setting up listener\n    if (!isExtensionContextValid()) {\n      log('Extension context invalidated, skipping message listener setup');\n      return;\n    }\n\n    try {\n      chrome.runtime.onMessage.addListener((message, _sender, sendResponse) => {\n        this.handleMessage(message).then(sendResponse);\n        return true; // Keep channel open for async response\n      });\n    } catch (error) {\n      log('Failed to setup message listener (extension context may be invalidated):', error);\n    }\n  }\n\n  private async handleMessage(message: { type: string; payload?: unknown }): Promise<unknown> {\n    switch (message.type) {\n      case 'PREFERENCES_UPDATED': {\n        const newPrefs = message.payload as UserPreferences;\n        this.preferences = newPrefs;\n        this.videoController?.updatePreferences(newPrefs);\n        this.captionFilter.updatePreferences(newPrefs);\n        return { success: true };\n      }\n\n      case 'AUTH_STATE_CHANGED': {\n        const payload = message.payload as { isAuthenticated: boolean };\n        log('Auth state changed:', payload);\n\n        // If user just authenticated and we have a pending video to filter\n        if (payload.isAuthenticated && this.pendingAuthVideoId) {\n          log('User authenticated, closing auth modal and starting filter for:', this.pendingAuthVideoId);\n\n          // Close the auth modal if it's open\n          const authModal = document.querySelector('.safeplay-credit-dialog-overlay');\n          if (authModal) {\n            authModal.remove();\n          }\n\n          // Start filtering the pending video\n          const videoId = this.pendingAuthVideoId;\n          this.pendingAuthVideoId = null;\n          this.onFilterButtonClick(videoId);\n        }\n        return { success: true };\n      }\n\n      case 'GET_VIDEO_STATE': {\n        return {\n          success: true,\n          data: this.videoController?.getState() || null,\n        };\n      }\n\n      default:\n        return { success: false, error: 'Unknown message type' };\n    }\n  }\n\n  private setupNavigationListener(): void {\n    // YouTube SPA navigation\n    document.addEventListener('yt-navigate-finish', () => {\n      log('YouTube navigation detected');\n      this.onNavigation();\n    });\n\n    // Fallback: popstate\n    window.addEventListener('popstate', () => {\n      this.onNavigation();\n    });\n  }\n\n  private onNavigation(): void {\n    // Increment navigation ID to cancel any stale async operations\n    this.navigationId++;\n    const currentNavId = this.navigationId;\n    log(`Navigation detected, navigationId: ${currentNavId}`);\n\n    // Stop current filter if any\n    if (this.videoController) {\n      this.videoController.stop();\n    }\n\n    // Stop caption filter\n    this.captionFilter.stop();\n\n    // Stop progress animator if running (prevents stale state updates)\n    if (this.progressAnimator) {\n      this.progressAnimator.stop();\n      this.progressAnimator = null;\n    }\n\n    // Clean up timeline markers\n    if (this.timelineMarkers) {\n      this.timelineMarkers.destroy();\n      this.timelineMarkers = null;\n    }\n\n    // Reset ALL state to prevent stale data from persisting\n    this.currentVideoId = null;\n    this.filteringVideoId = null;\n    this.isProcessing = false;\n    this.pendingAuthVideoId = null;\n    this.isFilterActive = false;\n    this.lastIntervalCount = 0;\n    this.videoWasPlaying = false;\n\n    // Remove player button\n    const playerButton = document.querySelector('.safeplay-player-controls');\n    if (playerButton) {\n      playerButton.remove();\n    }\n\n    // Update video ID if on watch page or Shorts page\n    if (this.isWatchPage() || this.isShortsPage()) {\n      this.currentVideoId = this.getVideoIdFromUrl();\n\n      // Check for auto-enable after a short delay (allow button to inject first)\n      if (this.currentVideoId) {\n        setTimeout(() => this.checkAutoEnable(), 500);\n      }\n    }\n  }\n\n  // Check if we should auto-enable filter for this video\n  private async checkAutoEnable(): Promise<void> {\n    if (!this.currentVideoId) return;\n    if (this.preferences.autoEnableForFilteredVideos === false) return;\n    if (this.isProcessing) return;\n\n    try {\n      // First check if user is authenticated - silently skip if not\n      // (don't show auth modal on navigation, only when user clicks button)\n      const authResponse = await safeSendMessage<{ success: boolean; data?: { authenticated: boolean } }>({\n        type: 'CHECK_AUTH_STRICT',\n      });\n\n      if (!authResponse?.success || !authResponse?.data?.authenticated) {\n        log('Auto-enable skipped: user not authenticated');\n        return;\n      }\n\n      const wasFiltered = await isVideoFiltered(this.currentVideoId);\n      if (wasFiltered) {\n        log(`Auto-enabling filter for previously filtered video: ${this.currentVideoId}`);\n        this.onFilterButtonClick(this.currentVideoId);\n      }\n    } catch (error) {\n      log('Error checking auto-enable:', error);\n    }\n  }\n}\n\n// Initialize when DOM is ready\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', () => {\n    const safeplay = new SafePlayContentScript();\n    safeplay.initialize();\n  });\n} else {\n  const safeplay = new SafePlayContentScript();\n  safeplay.initialize();\n}\n"],"names":["PROCESSED_ATTR","BUTTON_CONTAINER_CLASS","SHORTS_BUTTON_CLASS","BUTTON_STATES","idle","bg","hoverBg","text","shadow","connecting","downloading","useWater","transcribing","processing","filtering","paused","error","ResilientInjector","constructor","options","observer","currentVideoId","injectionAttempts","maxAttempts","retryInterval","currentState","shortsButtonStates","Map","shortsScrollObserver","this","start","log","attemptInjection","setupMutationObserver","setupNavigationListener","setupShortsScrollObserver","stop","disconnect","clearInterval","isWatchPage","window","location","pathname","search","includes","isShortsPage","startsWith","getVideoId","URLSearchParams","get","getShortsVideoId","match","attemptShortsInjection","videoId","isButtonPresent","subscribeButton","findSubscribeButton","injectButton","setInterval","document","querySelectorAll","forEach","renderer","getAttribute","getShortsVideoIdFromRenderer","actionsContainer","findShortsActionsContainer","injectShortsButton","setAttribute","injectIntoVisibleShort","link","querySelector","href","videoElement","src","currentSrc","selectors","selector","element","closest","body","existingButton","remove","has","set","container","createElement","className","style","cssText","button","state","stateConfig","iconWrapper","innerHTML","getShortsIconSVG","appendChild","label","textContent","addEventListener","config","background","transform","e","preventDefault","stopPropagation","onButtonClick","onToggleFilter","insertBefore","firstChild","IntersectionObserver","entries","entry","isIntersecting","target","threshold","observeShortsRenderers","observe","title","waterFill","getIconSVG","textSpan","boxShadow","parentElement","nextSibling","updateButtonState","stateInfo","updateWatchPageButton","targetVideoId","updateShortsButton","buttonVideoId","displayText","undefined","progress","replace","Math","round","intervalCount","height","classList","add","cursor","setButtonState","labelText","MutationObserver","mutations","mutation","type","addedNodes","length","node","HTMLElement","id","tagName","childList","subtree","originalPushState","history","pushState","originalReplaceState","replaceState","args","apply","onNavigation","el","removeAttribute","clear","setTimeout","getCurrentVideoId","debug","console","FADE_BUFFER","AudioFilter","video","muteIntervals","filterMode","isActive","checkIntervalId","isMuted","isFading","isBleeping","audioContext","sourceNode","gainNode","bleepOscillator","bleepGain","currentGainTarget","BLEEP_FREQUENCY","BLEEP_VOLUME","BLEEP_ATTACK","BLEEP_RELEASE","onMuteStart","onMuteEnd","boundHandleVideoPause","handleVideoPause","bind","boundHandleVideoPlay","handleVideoPlay","boundHandleVideoEnded","handleVideoEnded","boundHandleVideoSeeking","handleVideoSeeking","boundHandleVisibilityChange","handleVisibilityChange","initialize","intervals","mode","sort","a","b","initializeAudioContext","AudioContext","createMediaElementSource","createGain","gain","value","connect","destination","addVideoEventListeners","removeVideoEventListeners","removeEventListener","stopBleep","currentTime","findActiveInterval","startBleep","hidden","resume","checkCurrentTime","fadeToVolume","destroy","close","ended","readyState","activeInterval","approachingInterval","findApproachingInterval","startMute","startFadeOut","endMute","time","interval","end","onComplete","now","cancelScheduledValues","setValueAtTime","linearRampToValueAtTime","FADE_DURATION","muted","createOscillator","frequency","oscillator2","mixer","_secondOscillator","_mixer","oscillator","updateIntervals","updateMode","getState","isFiltering","getIntervals","PROFANITY_MAP","word","severity","map","item","toLowerCase","SAFE_WORDS","Set","CHAR_SUBSTITUTIONS","MULTI_CHAR_SUBSTITUTIONS","isSafeWord","findEmbeddedProfanity","lowerText","trim","results","normalizedText","normalized","from","to","split","join","result","char","normalizeSpelling","textsToCheck","push","textToCheck","index","indexOf","isExactMatch","isWholeWord","test","startIndex","endIndex","filtered","lastMatch","seen","filter","key","TranscriptParser","preferences","customBlacklistMap","customBlacklist","customWhitelistSet","customWhitelist","shouldFilterSeverity","severityLevels","shouldFilterWord","lowerWord","getWordSeverity","getCharacterLevelTiming","segment","startTime","start_time","endTime","end_time","characters","startChar","endChar","min","substring","toFixed","findProfanityMatches","segments","matches","i","exactSeverity","segmentIndex","isPartialMatch","embeddedMatches","customWord","embedded","matchedPortion","createMuteIntervals","paddingBeforeSeconds","paddingBeforeMs","paddingMs","paddingAfterSeconds","paddingAfterMs","max","mergeIntervals","sorted","mergeThresholdSeconds","mergeThresholdMs","merged","current","last","severityRank","mild","religious","moderate","severe","parse","transcript","parseTranscript","VideoController","youtubeId","status","statusOverlay","audioFilter","updateStatus","findVideoElement","waitForVideo","applyFilter","enabled","chrome","runtime","isExtensionContextValid","response","sendMessage","payload","success","Error","data","processTranscript","message","showStatusOverlay","onTranscriptReceived","onProcessingProgress","onProcessingError","hideStatusOverlay","updatePreferences","filterState","currentlyMuting","getMuteIntervals","timeout","Promise","resolve","Date","check","requestAnimationFrame","onStateChange","playerContainer","notifyStateChange","SmoothProgressAnimator","callback","baseText","displayProgress","targetProgress","isComplete","animationId","ANIMATION_INTERVAL","CATCH_UP_SPEED","MIN_INCREMENT","MAX_INCREMENT","startAnimation","setTarget","complete","getProgress","tick","gap","increment","displayValue","WORD_END","CENSORED_PATTERNS","pattern","RegExp","CaptionFilter","_options","censoredWordCount","lastProcessedTexts","_muteIntervals","setupCaptionObserver","getCensoredCount","captionContainerSelectors","processCaptionNode","nodeType","Node","TEXT_NODE","filterTextNode","characterData","scanForCaptions","filterCaptionElement","ELEMENT_NODE","isCaptionElement","baseVal","walker","createTreeWalker","NodeFilter","SHOW_TEXT","textNodes","currentNode","nextNode","textNode","originalText","filteredText","censorText","modified","replaceCensoredPatterns","tokens","newResult","token","profanityMatches","enabledMatches","tokenLower","some","banned","lastIndex","TimelineMarkers","overlayContainer","resizeObserver","progressBarElement","isInitialized","retryCount","maxRetries","retryDelay","injectOverlayWithRetry","setupEventListeners","progressBar","findProgressBar","createOverlay","timedMarkersContainer","removeOverlay","position","pointerEvents","renderMarkers","setupResizeObserver","duration","isFinite","marker","createMarker","once","videoDuration","leftPercent","widthPercent","minWidth","adjustedLeft","formatTimestamp","opacity","zIndex","seconds","floor","toString","padStart","ResizeObserver","update","show","display","hide","formatDuration","mins","secs","CreditConfirmation","dialog","previewData","createDialogHTML","injectStyles","setupListeners","dialogContent","focus","creditCost","creditCostNote","creditCostUnknown","userCredits","hasSufficientCredits","isCached","costDisplay","escapeHtml","_data","confirmBtn","onConfirm","cancelBtn","onCancel","handleKeydown","div","getElementById","styles","head","showFilterErrorNotification","overlay","closeDialog","escHandler","showAuthRequiredMessage","autoEnableForFilteredVideos","STORAGE_KEYS","async","getFilteredVideos","storage","local","safeSendMessage","String","SafePlayContentScript","videoController","filteringVideoId","isProcessing","videoWasPlaying","progressAnimator","lastIntervalCount","isFilterActive","timelineMarkers","navigationId","pendingAuthVideoId","injector","onFilterButtonClick","toggleFilterFromButton","onVideoStateChange","captionFilter","loadPreferences","getVideoIdFromUrl","checkAutoEnable","setupMessageListener","getVideoElement","resumeVideoIfNeeded","play","authResponse","authenticated","previewResponse","proceedWithFiltering","videoWasPlayingBeforeDialog","pause","errorMessage","startNavigationId","filterType","jobId","error_code","pollJobStatus","attempts","segmentCount","sampleSegment","times","hasCharacters","charCount","sampleChars","slice","videos","trimmedVideos","addFilteredVideo","injectPlayerControls","waitForControls","rightControls","createPlayerButton","toggleFilter","settingsButton","playerButton","catch","onMessage","addListener","_sender","sendResponse","handleMessage","then","newPrefs","isAuthenticated","authModal","isVideoFiltered"],"ignoreList":[],"sourceRoot":""}