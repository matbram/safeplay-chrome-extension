{"version":3,"file":"content.js","mappings":"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","sources":["webpack://safeplay-chrome-extension/./src/content/resilient-injector.ts","webpack://safeplay-chrome-extension/./src/filter/audio-filter.ts","webpack://safeplay-chrome-extension/./src/filter/profanity-list.ts","webpack://safeplay-chrome-extension/./src/filter/transcript-parser.ts","webpack://safeplay-chrome-extension/./src/content/video-controller.ts","webpack://safeplay-chrome-extension/./src/types/index.ts","webpack://safeplay-chrome-extension/./src/content/index.ts"],"sourcesContent":["// SafePlay Video Page Button Injector\n// Injects the SafePlay button next to the Subscribe button on YouTube watch pages\n\nexport interface InjectorOptions {\n  onButtonClick: (youtubeId: string) => void;\n  debug?: boolean;\n}\n\nconst PROCESSED_ATTR = 'data-safeplay-processed';\nconst BUTTON_CONTAINER_CLASS = 'safeplay-video-page-button-container';\n\nexport class ResilientInjector {\n  private options: InjectorOptions;\n  private observer: MutationObserver | null = null;\n  private currentVideoId: string | null = null;\n  private injectionAttempts = 0;\n  private maxAttempts = 50;\n  private retryInterval: number | null = null;\n\n  constructor(options: InjectorOptions) {\n    this.options = options;\n  }\n\n  // Start observing and injecting\n  start(): void {\n    this.log('Starting video page injector');\n\n    // Only run on watch pages\n    if (!this.isWatchPage()) {\n      this.log('Not a watch page, waiting for navigation');\n    }\n\n    // Initial injection attempt\n    this.attemptInjection();\n\n    // Set up mutation observer for SPA navigation\n    this.setupMutationObserver();\n\n    // Listen for YouTube SPA navigation\n    this.setupNavigationListener();\n  }\n\n  // Stop observing\n  stop(): void {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = null;\n    }\n\n    if (this.retryInterval !== null) {\n      clearInterval(this.retryInterval);\n      this.retryInterval = null;\n    }\n\n    this.log('Stopped video page injector');\n  }\n\n  private isWatchPage(): boolean {\n    return window.location.pathname === '/watch' &&\n           window.location.search.includes('v=');\n  }\n\n  private getVideoId(): string | null {\n    const urlParams = new URLSearchParams(window.location.search);\n    return urlParams.get('v');\n  }\n\n  // Main injection function\n  private attemptInjection(): void {\n    if (!this.isWatchPage()) {\n      return;\n    }\n\n    const videoId = this.getVideoId();\n    if (!videoId) {\n      this.log('No video ID found');\n      return;\n    }\n\n    // Check if already injected for this video\n    if (this.currentVideoId === videoId && this.isButtonPresent()) {\n      this.log('Button already present for this video');\n      return;\n    }\n\n    // Try to find the subscribe button container\n    const subscribeButton = this.findSubscribeButton();\n\n    if (subscribeButton) {\n      this.injectButton(subscribeButton, videoId);\n      this.currentVideoId = videoId;\n      this.injectionAttempts = 0;\n      if (this.retryInterval !== null) {\n        clearInterval(this.retryInterval);\n        this.retryInterval = null;\n      }\n    } else {\n      this.injectionAttempts++;\n      this.log(`Subscribe button not found, attempt ${this.injectionAttempts}/${this.maxAttempts}`);\n\n      // Retry with exponential backoff\n      if (this.injectionAttempts < this.maxAttempts && this.retryInterval === null) {\n        this.retryInterval = window.setInterval(() => {\n          this.attemptInjection();\n        }, 200);\n      }\n    }\n  }\n\n  private findSubscribeButton(): HTMLElement | null {\n    // Primary selector: the subscribe button container in watch metadata\n    const selectors = [\n      '#subscribe-button.ytd-watch-metadata',\n      'ytd-watch-metadata #subscribe-button',\n      '#owner #subscribe-button',\n      '#subscribe-button',\n    ];\n\n    for (const selector of selectors) {\n      const element = document.querySelector<HTMLElement>(selector);\n      if (element) {\n        this.log(`Found subscribe button with selector: ${selector}`);\n        return element;\n      }\n    }\n\n    return null;\n  }\n\n  private isButtonPresent(): boolean {\n    return document.querySelector(`.${BUTTON_CONTAINER_CLASS}`) !== null;\n  }\n\n  private injectButton(subscribeButton: HTMLElement, videoId: string): void {\n    // Remove any existing SafePlay button\n    const existingButton = document.querySelector(`.${BUTTON_CONTAINER_CLASS}`);\n    if (existingButton) {\n      existingButton.remove();\n    }\n\n    // Create button container\n    const container = document.createElement('div');\n    container.className = `${BUTTON_CONTAINER_CLASS} style-scope ytd-watch-metadata`;\n    container.style.cssText = 'display: inline-block; margin-left: 8px;';\n    container.setAttribute(PROCESSED_ATTR, 'true');\n\n    // Create the button matching YouTube's style\n    const button = document.createElement('button');\n    button.className = 'yt-spec-button-shape-next yt-spec-button-shape-next--tonal yt-spec-button-shape-next--mono yt-spec-button-shape-next--size-m yt-spec-button-shape-next--icon-leading yt-spec-button-shape-next--enable-backdrop-filter-experiment';\n    button.title = 'Filter profanity with SafePlay';\n    button.setAttribute('aria-label', 'SafePlay Filter');\n    button.style.cssText = `\n      border: 1px solid var(--yt-spec-outline);\n      background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);\n      color: #ffffff;\n      border-radius: 18px;\n      padding: 0 16px;\n      height: 36px;\n      font-family: \"Roboto\", \"Arial\", sans-serif;\n      font-size: 14px;\n      font-weight: 500;\n      line-height: 36px;\n      display: inline-flex;\n      align-items: center;\n      justify-content: center;\n      gap: 6px;\n      cursor: pointer;\n      transition: all 0.2s ease;\n      min-width: 110px;\n      box-shadow: 0 1px 3px rgba(76, 175, 80, 0.3);\n    `;\n\n    // Add icon\n    const iconWrapper = document.createElement('div');\n    iconWrapper.style.cssText = 'display: inline-block; width: 20px; height: 20px; vertical-align: middle; flex-shrink: 0;';\n    iconWrapper.innerHTML = `\n      <svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n        <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z\"/>\n      </svg>\n    `;\n\n    // Add text\n    const textSpan = document.createElement('span');\n    textSpan.style.cssText = 'color: currentColor; font-size: 14px; font-weight: 500; line-height: 1;';\n    textSpan.textContent = 'SafePlay';\n\n    button.appendChild(iconWrapper);\n    button.appendChild(textSpan);\n\n    // Add hover effects\n    button.addEventListener('mouseenter', () => {\n      button.style.background = 'linear-gradient(135deg, #45a049 0%, #3d8b40 100%)';\n      button.style.boxShadow = '0 2px 6px rgba(76, 175, 80, 0.4)';\n      button.style.transform = 'translateY(-1px)';\n    });\n\n    button.addEventListener('mouseleave', () => {\n      button.style.background = 'linear-gradient(135deg, #4CAF50 0%, #45a049 100%)';\n      button.style.boxShadow = '0 1px 3px rgba(76, 175, 80, 0.3)';\n      button.style.transform = 'translateY(0)';\n    });\n\n    // Add click handler\n    button.addEventListener('click', (e) => {\n      e.preventDefault();\n      e.stopPropagation();\n      this.options.onButtonClick(videoId);\n    });\n\n    container.appendChild(button);\n\n    // Insert after subscribe button\n    subscribeButton.parentElement?.insertBefore(container, subscribeButton.nextSibling);\n\n    this.log(`Injected SafePlay button for video: ${videoId}`);\n  }\n\n  // Update button state (loading, active, error)\n  updateButtonState(state: 'idle' | 'loading' | 'active' | 'error', message?: string): void {\n    const container = document.querySelector(`.${BUTTON_CONTAINER_CLASS}`);\n    if (!container) return;\n\n    const button = container.querySelector('button');\n    const textSpan = container.querySelector('span');\n    if (!button || !textSpan) return;\n\n    switch (state) {\n      case 'loading':\n        button.style.background = 'linear-gradient(135deg, #888 0%, #666 100%)';\n        button.style.cursor = 'wait';\n        textSpan.textContent = message || 'Loading...';\n        break;\n\n      case 'active':\n        button.style.background = 'linear-gradient(135deg, #2196F3 0%, #1976D2 100%)';\n        button.style.boxShadow = '0 1px 3px rgba(33, 150, 243, 0.3)';\n        button.style.cursor = 'pointer';\n        textSpan.textContent = message || 'Filtering';\n        break;\n\n      case 'error':\n        button.style.background = 'linear-gradient(135deg, #f44336 0%, #d32f2f 100%)';\n        button.style.boxShadow = '0 1px 3px rgba(244, 67, 54, 0.3)';\n        button.style.cursor = 'pointer';\n        textSpan.textContent = message || 'Error';\n        break;\n\n      case 'idle':\n      default:\n        button.style.background = 'linear-gradient(135deg, #4CAF50 0%, #45a049 100%)';\n        button.style.boxShadow = '0 1px 3px rgba(76, 175, 80, 0.3)';\n        button.style.cursor = 'pointer';\n        textSpan.textContent = 'SafePlay';\n        break;\n    }\n  }\n\n  // Set up mutation observer for dynamic content changes\n  private setupMutationObserver(): void {\n    this.observer = new MutationObserver((mutations) => {\n      // Check if we need to re-inject (e.g., after YouTube updates the page)\n      for (const mutation of mutations) {\n        if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {\n          // Check if subscribe button area was modified\n          for (const node of mutation.addedNodes) {\n            if (node instanceof HTMLElement) {\n              if (node.id === 'subscribe-button' ||\n                  node.querySelector?.('#subscribe-button') ||\n                  node.closest?.('ytd-watch-metadata')) {\n                this.log('Subscribe button area changed, re-injecting');\n                this.attemptInjection();\n                return;\n              }\n            }\n          }\n        }\n      }\n    });\n\n    this.observer.observe(document.body, {\n      childList: true,\n      subtree: true,\n    });\n  }\n\n  // Listen for YouTube SPA navigation\n  private setupNavigationListener(): void {\n    // YouTube uses History API for navigation\n    const originalPushState = history.pushState;\n    const originalReplaceState = history.replaceState;\n\n    history.pushState = (...args) => {\n      originalPushState.apply(history, args);\n      this.onNavigation();\n    };\n\n    history.replaceState = (...args) => {\n      originalReplaceState.apply(history, args);\n      this.onNavigation();\n    };\n\n    window.addEventListener('popstate', () => {\n      this.onNavigation();\n    });\n\n    // YouTube's custom navigation event\n    document.addEventListener('yt-navigate-finish', () => {\n      this.onNavigation();\n    });\n\n    // Also handle yt-page-data-updated for video changes within watch page\n    document.addEventListener('yt-page-data-updated', () => {\n      this.log('Page data updated');\n      this.onNavigation();\n    });\n  }\n\n  private onNavigation(): void {\n    this.log('Navigation detected');\n    this.currentVideoId = null;\n    this.injectionAttempts = 0;\n\n    if (this.retryInterval !== null) {\n      clearInterval(this.retryInterval);\n      this.retryInterval = null;\n    }\n\n    // Wait for DOM to update\n    setTimeout(() => {\n      this.attemptInjection();\n    }, 300);\n  }\n\n  // Debug logging\n  private log(...args: unknown[]): void {\n    if (this.options.debug) {\n      console.log('[SafePlay Injector]', ...args);\n    }\n  }\n}\n","import { MuteInterval, FilterMode } from '../types';\n\nexport class AudioFilter {\n  private video: HTMLVideoElement | null = null;\n  private muteIntervals: MuteInterval[] = [];\n  private filterMode: FilterMode = 'mute';\n  private isActive = false;\n  private checkIntervalId: number | null = null;\n  private isMuted = false;\n\n  // Audio context for bleep sound\n  private audioContext: AudioContext | null = null;\n  private bleepOscillator: OscillatorNode | null = null;\n  private bleepGain: GainNode | null = null;\n\n  // Callbacks\n  private onMuteStart?: (interval: MuteInterval) => void;\n  private onMuteEnd?: () => void;\n\n  constructor(options?: {\n    onMuteStart?: (interval: MuteInterval) => void;\n    onMuteEnd?: () => void;\n  }) {\n    this.onMuteStart = options?.onMuteStart;\n    this.onMuteEnd = options?.onMuteEnd;\n  }\n\n  // Initialize with video element and mute intervals\n  initialize(\n    video: HTMLVideoElement,\n    intervals: MuteInterval[],\n    mode: FilterMode = 'mute'\n  ): void {\n    this.video = video;\n    this.muteIntervals = intervals;\n    this.filterMode = mode;\n\n    // Sort intervals by start time for efficient lookup\n    this.muteIntervals.sort((a, b) => a.start - b.start);\n\n    // Initialize audio context for bleep mode\n    if (mode === 'bleep') {\n      this.initializeAudioContext();\n    }\n  }\n\n  private initializeAudioContext(): void {\n    try {\n      this.audioContext = new AudioContext();\n      this.bleepGain = this.audioContext.createGain();\n      this.bleepGain.gain.value = 0; // Start silent\n      this.bleepGain.connect(this.audioContext.destination);\n    } catch (error) {\n      console.error('[SafePlay] Failed to initialize audio context:', error);\n    }\n  }\n\n  // Start monitoring playback\n  start(): void {\n    if (this.isActive || !this.video) {\n      return;\n    }\n\n    this.isActive = true;\n\n    // Check every 10ms for precise timing\n    this.checkIntervalId = window.setInterval(() => {\n      this.checkCurrentTime();\n    }, 10);\n\n    console.log('[SafePlay] Audio filter started with', this.muteIntervals.length, 'intervals');\n  }\n\n  // Stop monitoring\n  stop(): void {\n    if (!this.isActive) {\n      return;\n    }\n\n    this.isActive = false;\n\n    if (this.checkIntervalId !== null) {\n      clearInterval(this.checkIntervalId);\n      this.checkIntervalId = null;\n    }\n\n    // Restore audio state\n    this.unmute();\n\n    // Clean up audio context\n    if (this.bleepOscillator) {\n      this.bleepOscillator.stop();\n      this.bleepOscillator = null;\n    }\n\n    if (this.audioContext) {\n      this.audioContext.close();\n      this.audioContext = null;\n    }\n\n    console.log('[SafePlay] Audio filter stopped');\n  }\n\n  // Check if current time falls within any mute interval\n  private checkCurrentTime(): void {\n    if (!this.video || !this.isActive) {\n      return;\n    }\n\n    const currentTime = this.video.currentTime;\n    const activeInterval = this.findActiveInterval(currentTime);\n\n    if (activeInterval && !this.isMuted) {\n      this.mute(activeInterval);\n    } else if (!activeInterval && this.isMuted) {\n      this.unmute();\n    }\n  }\n\n  // Binary search for active interval (optimized for sorted intervals)\n  private findActiveInterval(time: number): MuteInterval | null {\n    let low = 0;\n    let high = this.muteIntervals.length - 1;\n\n    while (low <= high) {\n      const mid = Math.floor((low + high) / 2);\n      const interval = this.muteIntervals[mid];\n\n      if (time >= interval.start && time <= interval.end) {\n        return interval;\n      } else if (time < interval.start) {\n        high = mid - 1;\n      } else {\n        low = mid + 1;\n      }\n    }\n\n    return null;\n  }\n\n  private mute(interval: MuteInterval): void {\n    if (!this.video) return;\n\n    this.isMuted = true;\n\n    if (this.filterMode === 'mute') {\n      // Simple mute - set volume to 0\n      this.video.muted = true;\n    } else if (this.filterMode === 'bleep') {\n      // Bleep mode - mute video and play bleep tone\n      this.video.muted = true;\n      this.startBleep();\n    }\n\n    if (this.onMuteStart) {\n      this.onMuteStart(interval);\n    }\n  }\n\n  private unmute(): void {\n    if (!this.video) return;\n\n    this.isMuted = false;\n    this.video.muted = false;\n\n    if (this.filterMode === 'bleep') {\n      this.stopBleep();\n    }\n\n    if (this.onMuteEnd) {\n      this.onMuteEnd();\n    }\n  }\n\n  private startBleep(): void {\n    if (!this.audioContext || !this.bleepGain) return;\n\n    // Resume audio context if suspended\n    if (this.audioContext.state === 'suspended') {\n      this.audioContext.resume();\n    }\n\n    // Create oscillator for bleep sound\n    this.bleepOscillator = this.audioContext.createOscillator();\n    this.bleepOscillator.type = 'sine';\n    this.bleepOscillator.frequency.value = 1000; // 1kHz bleep\n    this.bleepOscillator.connect(this.bleepGain);\n\n    // Fade in\n    this.bleepGain.gain.setValueAtTime(0, this.audioContext.currentTime);\n    this.bleepGain.gain.linearRampToValueAtTime(0.3, this.audioContext.currentTime + 0.01);\n\n    this.bleepOscillator.start();\n  }\n\n  private stopBleep(): void {\n    if (!this.audioContext || !this.bleepGain || !this.bleepOscillator) return;\n\n    // Fade out\n    this.bleepGain.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + 0.01);\n\n    // Stop and disconnect\n    setTimeout(() => {\n      if (this.bleepOscillator) {\n        this.bleepOscillator.stop();\n        this.bleepOscillator.disconnect();\n        this.bleepOscillator = null;\n      }\n    }, 20);\n  }\n\n  // Update intervals (e.g., when preferences change)\n  updateIntervals(intervals: MuteInterval[]): void {\n    this.muteIntervals = intervals;\n    this.muteIntervals.sort((a, b) => a.start - b.start);\n  }\n\n  // Update filter mode\n  updateMode(mode: FilterMode): void {\n    this.filterMode = mode;\n\n    // Initialize audio context if switching to bleep mode\n    if (mode === 'bleep' && !this.audioContext) {\n      this.initializeAudioContext();\n    }\n  }\n\n  // Get current state\n  getState(): {\n    isActive: boolean;\n    isMuted: boolean;\n    intervalCount: number;\n    filterMode: FilterMode;\n  } {\n    return {\n      isActive: this.isActive,\n      isMuted: this.isMuted,\n      intervalCount: this.muteIntervals.length,\n      filterMode: this.filterMode,\n    };\n  }\n\n  // Check if filtering is active\n  isFiltering(): boolean {\n    return this.isActive;\n  }\n\n  // Get all intervals (for debugging/display)\n  getIntervals(): MuteInterval[] {\n    return [...this.muteIntervals];\n  }\n}\n","import { ProfanityWord, SeverityLevel } from '../types';\n\n// Comprehensive profanity list with severity levels\n// Severity: mild (common/casual), moderate (offensive), severe (highly offensive)\n\nexport const PROFANITY_LIST: ProfanityWord[] = [\n  // Severe\n  { word: 'fuck', severity: 'severe' },\n  { word: 'fucking', severity: 'severe' },\n  { word: 'fucked', severity: 'severe' },\n  { word: 'fucker', severity: 'severe' },\n  { word: 'fuckers', severity: 'severe' },\n  { word: 'fucks', severity: 'severe' },\n  { word: 'motherfucker', severity: 'severe' },\n  { word: 'motherfucking', severity: 'severe' },\n  { word: 'motherfuckers', severity: 'severe' },\n  { word: 'cunt', severity: 'severe' },\n  { word: 'cunts', severity: 'severe' },\n  { word: 'nigger', severity: 'severe' },\n  { word: 'niggers', severity: 'severe' },\n  { word: 'nigga', severity: 'severe' },\n  { word: 'niggas', severity: 'severe' },\n  { word: 'faggot', severity: 'severe' },\n  { word: 'faggots', severity: 'severe' },\n  { word: 'fag', severity: 'severe' },\n  { word: 'fags', severity: 'severe' },\n  { word: 'retard', severity: 'severe' },\n  { word: 'retarded', severity: 'severe' },\n  { word: 'retards', severity: 'severe' },\n\n  // Moderate\n  { word: 'shit', severity: 'moderate' },\n  { word: 'shits', severity: 'moderate' },\n  { word: 'shitty', severity: 'moderate' },\n  { word: 'bullshit', severity: 'moderate' },\n  { word: 'horseshit', severity: 'moderate' },\n  { word: 'shithead', severity: 'moderate' },\n  { word: 'shitheads', severity: 'moderate' },\n  { word: 'ass', severity: 'moderate' },\n  { word: 'asses', severity: 'moderate' },\n  { word: 'asshole', severity: 'moderate' },\n  { word: 'assholes', severity: 'moderate' },\n  { word: 'bastard', severity: 'moderate' },\n  { word: 'bastards', severity: 'moderate' },\n  { word: 'bitch', severity: 'moderate' },\n  { word: 'bitches', severity: 'moderate' },\n  { word: 'bitchy', severity: 'moderate' },\n  { word: 'cock', severity: 'moderate' },\n  { word: 'cocks', severity: 'moderate' },\n  { word: 'cocksucker', severity: 'moderate' },\n  { word: 'cocksuckers', severity: 'moderate' },\n  { word: 'dick', severity: 'moderate' },\n  { word: 'dicks', severity: 'moderate' },\n  { word: 'dickhead', severity: 'moderate' },\n  { word: 'dickheads', severity: 'moderate' },\n  { word: 'pussy', severity: 'moderate' },\n  { word: 'pussies', severity: 'moderate' },\n  { word: 'prick', severity: 'moderate' },\n  { word: 'pricks', severity: 'moderate' },\n  { word: 'slut', severity: 'moderate' },\n  { word: 'sluts', severity: 'moderate' },\n  { word: 'slutty', severity: 'moderate' },\n  { word: 'whore', severity: 'moderate' },\n  { word: 'whores', severity: 'moderate' },\n  { word: 'twat', severity: 'moderate' },\n  { word: 'twats', severity: 'moderate' },\n  { word: 'wanker', severity: 'moderate' },\n  { word: 'wankers', severity: 'moderate' },\n  { word: 'bollocks', severity: 'moderate' },\n\n  // Mild\n  { word: 'damn', severity: 'mild' },\n  { word: 'damned', severity: 'mild' },\n  { word: 'dammit', severity: 'mild' },\n  { word: 'goddamn', severity: 'mild' },\n  { word: 'goddamnit', severity: 'mild' },\n  { word: 'hell', severity: 'mild' },\n  { word: 'crap', severity: 'mild' },\n  { word: 'crappy', severity: 'mild' },\n  { word: 'piss', severity: 'mild' },\n  { word: 'pissed', severity: 'mild' },\n  { word: 'pissing', severity: 'mild' },\n  { word: 'suck', severity: 'mild' },\n  { word: 'sucks', severity: 'mild' },\n  { word: 'sucked', severity: 'mild' },\n  { word: 'balls', severity: 'mild' },\n  { word: 'butt', severity: 'mild' },\n  { word: 'butthole', severity: 'mild' },\n  { word: 'screw', severity: 'mild' },\n  { word: 'screwed', severity: 'mild' },\n  { word: 'douche', severity: 'mild' },\n  { word: 'douchebag', severity: 'mild' },\n  { word: 'douchebags', severity: 'mild' },\n];\n\n// Create a Map for O(1) lookup\nexport const PROFANITY_MAP: Map<string, SeverityLevel> = new Map(\n  PROFANITY_LIST.map((item) => [item.word.toLowerCase(), item.severity])\n);\n\n// Get all words of a specific severity\nexport function getWordsBySeverity(severity: SeverityLevel): string[] {\n  return PROFANITY_LIST\n    .filter((item) => item.severity === severity)\n    .map((item) => item.word);\n}\n\n// Check if a word is profanity\nexport function isProfanity(word: string): boolean {\n  return PROFANITY_MAP.has(word.toLowerCase());\n}\n\n// Get the severity of a word\nexport function getSeverity(word: string): SeverityLevel | null {\n  return PROFANITY_MAP.get(word.toLowerCase()) || null;\n}\n\n// Find profanity within a longer word (e.g., \"fuck\" in \"motherfucker\")\nexport function findEmbeddedProfanity(\n  text: string\n): { word: string; severity: SeverityLevel; startIndex: number; endIndex: number }[] {\n  const results: {\n    word: string;\n    severity: SeverityLevel;\n    startIndex: number;\n    endIndex: number;\n  }[] = [];\n  const lowerText = text.toLowerCase();\n\n  for (const [word, severity] of PROFANITY_MAP) {\n    let index = lowerText.indexOf(word);\n    while (index !== -1) {\n      results.push({\n        word,\n        severity,\n        startIndex: index,\n        endIndex: index + word.length,\n      });\n      index = lowerText.indexOf(word, index + 1);\n    }\n  }\n\n  // Sort by start index and remove duplicates (prefer longer matches)\n  results.sort((a, b) => a.startIndex - b.startIndex);\n\n  // Remove overlapping matches, keeping the longer one\n  const filtered: typeof results = [];\n  for (const match of results) {\n    const lastMatch = filtered[filtered.length - 1];\n    if (!lastMatch || match.startIndex >= lastMatch.endIndex) {\n      filtered.push(match);\n    } else if (match.endIndex - match.startIndex > lastMatch.endIndex - lastMatch.startIndex) {\n      filtered[filtered.length - 1] = match;\n    }\n  }\n\n  return filtered;\n}\n","import {\n  TranscriptSegment,\n  Transcript,\n  MuteInterval,\n  UserPreferences,\n  SeverityLevel,\n  ProfanityMatch,\n} from '../types';\nimport {\n  PROFANITY_MAP,\n  findEmbeddedProfanity,\n} from './profanity-list';\n\nexport class TranscriptParser {\n  private preferences: UserPreferences;\n  private customBlacklistMap: Map<string, SeverityLevel>;\n  private customWhitelistSet: Set<string>;\n\n  constructor(preferences: UserPreferences) {\n    this.preferences = preferences;\n\n    // Build custom blacklist map (all custom words are severe by default)\n    this.customBlacklistMap = new Map(\n      preferences.customBlacklist.map((word) => [word.toLowerCase(), 'severe' as SeverityLevel])\n    );\n\n    // Build whitelist set\n    this.customWhitelistSet = new Set(\n      preferences.customWhitelist.map((word) => word.toLowerCase())\n    );\n  }\n\n  // Check if a severity level should be filtered based on preferences\n  private shouldFilterSeverity(severity: SeverityLevel): boolean {\n    return this.preferences.severityLevels[severity];\n  }\n\n  // Check if a word should be filtered (considering whitelist/blacklist)\n  private shouldFilterWord(word: string, severity: SeverityLevel): boolean {\n    const lowerWord = word.toLowerCase();\n\n    // Check whitelist first (user explicitly allowed)\n    if (this.customWhitelistSet.has(lowerWord)) {\n      return false;\n    }\n\n    // Check custom blacklist (always filter)\n    if (this.customBlacklistMap.has(lowerWord)) {\n      return true;\n    }\n\n    // Check severity level preference\n    return this.shouldFilterSeverity(severity);\n  }\n\n  // Get severity for a word (checking custom blacklist too)\n  private getWordSeverity(word: string): SeverityLevel | null {\n    const lowerWord = word.toLowerCase();\n\n    // Check custom blacklist first\n    if (this.customBlacklistMap.has(lowerWord)) {\n      return this.customBlacklistMap.get(lowerWord)!;\n    }\n\n    // Check built-in profanity list\n    return PROFANITY_MAP.get(lowerWord) || null;\n  }\n\n  // Find profanity matches in transcript segments\n  findProfanityMatches(segments: TranscriptSegment[]): ProfanityMatch[] {\n    const matches: ProfanityMatch[] = [];\n\n    for (let i = 0; i < segments.length; i++) {\n      const segment = segments[i];\n      const normalizedText = segment.text.toLowerCase().trim();\n\n      // Check for exact word match first\n      const exactSeverity = this.getWordSeverity(normalizedText);\n      if (exactSeverity && this.shouldFilterWord(normalizedText, exactSeverity)) {\n        matches.push({\n          segmentIndex: i,\n          word: segment.text,\n          severity: exactSeverity,\n          startTime: segment.start_time,\n          endTime: segment.end_time,\n          isPartialMatch: false,\n        });\n        continue;\n      }\n\n      // Check for embedded profanity within longer words\n      const embeddedMatches = findEmbeddedProfanity(normalizedText);\n\n      // Also check custom blacklist for embedded matches\n      for (const [customWord] of this.customBlacklistMap) {\n        const index = normalizedText.indexOf(customWord);\n        if (index !== -1) {\n          embeddedMatches.push({\n            word: customWord,\n            severity: 'severe',\n            startIndex: index,\n            endIndex: index + customWord.length,\n          });\n        }\n      }\n\n      for (const embedded of embeddedMatches) {\n        if (!this.shouldFilterWord(embedded.word, embedded.severity)) {\n          continue;\n        }\n\n        // Calculate timing using character-level data if available\n        let startTime = segment.start_time;\n        let endTime = segment.end_time;\n\n        if (segment.characters && segment.characters.length > 0) {\n          // Use character-level timing for precision\n          const startChar = segment.characters[embedded.startIndex];\n          const endChar = segment.characters[embedded.endIndex - 1];\n\n          if (startChar) {\n            startTime = startChar.start_time;\n          }\n          if (endChar) {\n            endTime = endChar.end_time;\n          }\n        }\n\n        matches.push({\n          segmentIndex: i,\n          word: embedded.word,\n          severity: embedded.severity,\n          startTime,\n          endTime,\n          isPartialMatch: true,\n          matchedPortion: segment.text.substring(embedded.startIndex, embedded.endIndex),\n        });\n      }\n    }\n\n    return matches;\n  }\n\n  // Convert profanity matches to mute intervals with padding\n  createMuteIntervals(matches: ProfanityMatch[]): MuteInterval[] {\n    const paddingSeconds = this.preferences.paddingMs / 1000;\n\n    return matches.map((match) => ({\n      start: Math.max(0, match.startTime - paddingSeconds),\n      end: match.endTime + paddingSeconds,\n      word: match.word,\n      severity: match.severity,\n    }));\n  }\n\n  // Merge overlapping or close intervals\n  mergeIntervals(intervals: MuteInterval[]): MuteInterval[] {\n    if (intervals.length === 0) {\n      return [];\n    }\n\n    // Sort by start time\n    const sorted = [...intervals].sort((a, b) => a.start - b.start);\n    const mergeThresholdSeconds = this.preferences.mergeThresholdMs / 1000;\n\n    const merged: MuteInterval[] = [sorted[0]];\n\n    for (let i = 1; i < sorted.length; i++) {\n      const current = sorted[i];\n      const last = merged[merged.length - 1];\n\n      // Merge if overlapping or within threshold\n      if (current.start <= last.end + mergeThresholdSeconds) {\n        // Extend the end time and combine words\n        last.end = Math.max(last.end, current.end);\n        // Keep the more severe classification\n        if (this.severityRank(current.severity) > this.severityRank(last.severity)) {\n          last.severity = current.severity;\n        }\n        // Append word if different\n        if (!last.word.includes(current.word)) {\n          last.word = `${last.word}, ${current.word}`;\n        }\n      } else {\n        merged.push({ ...current });\n      }\n    }\n\n    return merged;\n  }\n\n  private severityRank(severity: SeverityLevel): number {\n    const ranks: Record<SeverityLevel, number> = {\n      mild: 1,\n      moderate: 2,\n      severe: 3,\n    };\n    return ranks[severity];\n  }\n\n  // Main parsing function: transcript -> mute intervals\n  parse(transcript: Transcript): MuteInterval[] {\n    const matches = this.findProfanityMatches(transcript.segments);\n    const intervals = this.createMuteIntervals(matches);\n    return this.mergeIntervals(intervals);\n  }\n}\n\n// Utility function for quick parsing\nexport function parseTranscript(\n  transcript: Transcript,\n  preferences: UserPreferences\n): MuteInterval[] {\n  const parser = new TranscriptParser(preferences);\n  return parser.parse(transcript);\n}\n","// Controller for managing video filtering on watch pages\nimport { Transcript, MuteInterval, UserPreferences } from '../types';\nimport { AudioFilter } from '../filter/audio-filter';\nimport { parseTranscript } from '../filter/transcript-parser';\n\nexport type FilterStatus =\n  | 'idle'\n  | 'loading'\n  | 'processing'\n  | 'active'\n  | 'error'\n  | 'disabled';\n\nexport interface VideoControllerState {\n  status: FilterStatus;\n  progress: number;\n  error?: string;\n  intervalCount: number;\n  currentlyMuting: boolean;\n}\n\ninterface VideoControllerOptions {\n  onStateChange?: (state: VideoControllerState) => void;\n  debug?: boolean;\n}\n\nexport class VideoController {\n  private youtubeId: string | null = null;\n  private video: HTMLVideoElement | null = null;\n  private audioFilter: AudioFilter;\n  private transcript: Transcript | null = null;\n  private muteIntervals: MuteInterval[] = [];\n  private preferences: UserPreferences | null = null;\n  private status: FilterStatus = 'idle';\n  private progress = 0;\n  private error?: string;\n  private options: VideoControllerOptions;\n  private statusOverlay: HTMLElement | null = null;\n\n  constructor(options: VideoControllerOptions = {}) {\n    this.options = options;\n    this.audioFilter = new AudioFilter({\n      onMuteStart: (interval) => this.onMuteStart(interval),\n      onMuteEnd: () => this.onMuteEnd(),\n    });\n  }\n\n  // Initialize controller for a video\n  async initialize(\n    youtubeId: string,\n    preferences: UserPreferences\n  ): Promise<void> {\n    this.youtubeId = youtubeId;\n    this.preferences = preferences;\n    this.updateStatus('idle');\n\n    // Find video element\n    this.video = this.findVideoElement();\n    if (!this.video) {\n      this.log('Video element not found, waiting...');\n      await this.waitForVideo();\n    }\n\n    if (!this.video) {\n      this.updateStatus('error', 0, 'Could not find video element');\n      return;\n    }\n\n    this.log('Video controller initialized for:', youtubeId);\n  }\n\n  // Request and apply filter\n  async applyFilter(): Promise<void> {\n    if (!this.youtubeId || !this.video || !this.preferences) {\n      this.log('Cannot apply filter: missing required data');\n      return;\n    }\n\n    if (!this.preferences.enabled) {\n      this.updateStatus('disabled');\n      return;\n    }\n\n    try {\n      this.updateStatus('loading');\n\n      // Request transcript from background script\n      const response = await chrome.runtime.sendMessage({\n        type: 'GET_FILTER',\n        payload: { youtubeId: this.youtubeId },\n      });\n\n      if (!response.success) {\n        throw new Error(response.error || 'Failed to get transcript');\n      }\n\n      // If processing, we'll receive progress updates\n      if (response.data.status === 'processing') {\n        this.updateStatus('processing', response.data.progress || 0);\n        return; // Background will send completion message\n      }\n\n      // Parse transcript and create mute intervals\n      this.transcript = response.data.transcript;\n      await this.processTranscript();\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Unknown error';\n      this.updateStatus('error', 0, message);\n      this.log('Filter error:', error);\n    }\n  }\n\n  // Process transcript and start filtering\n  async processTranscript(): Promise<void> {\n    if (!this.transcript || !this.preferences || !this.video) {\n      return;\n    }\n\n    // Parse transcript for profanity\n    this.muteIntervals = parseTranscript(this.transcript, this.preferences);\n    this.log('Found', this.muteIntervals.length, 'mute intervals');\n\n    if (this.muteIntervals.length === 0) {\n      this.updateStatus('active');\n      this.log('No profanity detected in video');\n      return;\n    }\n\n    // Initialize and start audio filter\n    this.audioFilter.initialize(\n      this.video,\n      this.muteIntervals,\n      this.preferences.filterMode\n    );\n    this.audioFilter.start();\n\n    this.updateStatus('active');\n    this.showStatusOverlay();\n  }\n\n  // Handle transcript received from background\n  onTranscriptReceived(transcript: Transcript): void {\n    this.transcript = transcript;\n    this.processTranscript();\n  }\n\n  // Handle processing progress\n  onProcessingProgress(progress: number): void {\n    this.updateStatus('processing', progress);\n  }\n\n  // Handle processing error\n  onProcessingError(error: string): void {\n    this.updateStatus('error', 0, error);\n  }\n\n  // Stop filtering\n  stop(): void {\n    this.audioFilter.stop();\n    this.hideStatusOverlay();\n    this.updateStatus('idle');\n  }\n\n  // Update preferences\n  updatePreferences(preferences: UserPreferences): void {\n    this.preferences = preferences;\n\n    if (!preferences.enabled) {\n      this.stop();\n      return;\n    }\n\n    // Re-parse with new preferences\n    if (this.transcript) {\n      this.muteIntervals = parseTranscript(this.transcript, preferences);\n      this.audioFilter.updateIntervals(this.muteIntervals);\n      this.audioFilter.updateMode(preferences.filterMode);\n    }\n  }\n\n  // Get current state\n  getState(): VideoControllerState {\n    const filterState = this.audioFilter.getState();\n    return {\n      status: this.status,\n      progress: this.progress,\n      error: this.error,\n      intervalCount: filterState.intervalCount,\n      currentlyMuting: filterState.isMuted,\n    };\n  }\n\n  // Find the YouTube video element\n  private findVideoElement(): HTMLVideoElement | null {\n    // Main player video\n    const selectors = [\n      'video.html5-main-video',\n      'video.video-stream',\n      '#movie_player video',\n      'ytd-player video',\n      'video',\n    ];\n\n    for (const selector of selectors) {\n      const video = document.querySelector<HTMLVideoElement>(selector);\n      if (video && video.src) {\n        return video;\n      }\n    }\n\n    return null;\n  }\n\n  // Wait for video element to appear\n  private waitForVideo(timeout = 10000): Promise<HTMLVideoElement | null> {\n    return new Promise((resolve) => {\n      const startTime = Date.now();\n\n      const check = () => {\n        this.video = this.findVideoElement();\n        if (this.video) {\n          resolve(this.video);\n          return;\n        }\n\n        if (Date.now() - startTime > timeout) {\n          resolve(null);\n          return;\n        }\n\n        requestAnimationFrame(check);\n      };\n\n      check();\n    });\n  }\n\n  // Update status and notify listeners\n  private updateStatus(\n    status: FilterStatus,\n    progress = 0,\n    error?: string\n  ): void {\n    this.status = status;\n    this.progress = progress;\n    this.error = error;\n\n    if (this.options.onStateChange) {\n      this.options.onStateChange(this.getState());\n    }\n  }\n\n  // Show status overlay on video\n  private showStatusOverlay(): void {\n    if (this.statusOverlay) return;\n\n    const playerContainer = document.querySelector('#movie_player');\n    if (!playerContainer) return;\n\n    this.statusOverlay = document.createElement('div');\n    this.statusOverlay.className = 'safeplay-status-overlay';\n    this.statusOverlay.innerHTML = `\n      <div class=\"safeplay-status-badge\">\n        <svg class=\"safeplay-status-icon\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n          <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z\"/>\n        </svg>\n        <span>SafePlay Active</span>\n      </div>\n    `;\n\n    playerContainer.appendChild(this.statusOverlay);\n\n    // Auto-hide after 3 seconds\n    setTimeout(() => {\n      this.statusOverlay?.classList.add('safeplay-status-hidden');\n    }, 3000);\n  }\n\n  // Hide status overlay\n  private hideStatusOverlay(): void {\n    if (this.statusOverlay) {\n      this.statusOverlay.remove();\n      this.statusOverlay = null;\n    }\n  }\n\n  // Event handlers\n  private onMuteStart(interval: MuteInterval): void {\n    this.log('Muting:', interval.word);\n    this.notifyStateChange();\n  }\n\n  private onMuteEnd(): void {\n    this.notifyStateChange();\n  }\n\n  private notifyStateChange(): void {\n    if (this.options.onStateChange) {\n      this.options.onStateChange(this.getState());\n    }\n  }\n\n  // Debug logging\n  private log(...args: unknown[]): void {\n    if (this.options.debug) {\n      console.log('[SafePlay Controller]', ...args);\n    }\n  }\n}\n","// API Response Types\n\nexport interface CharacterTiming {\n  character: string;\n  start_time: number;\n  end_time: number;\n}\n\nexport interface TranscriptSegment {\n  text: string;\n  start_time: number;\n  end_time: number;\n  characters: CharacterTiming[];\n}\n\nexport interface Transcript {\n  youtube_id: string;\n  segments: TranscriptSegment[];\n  duration: number;\n  language: string;\n  created_at: string;\n}\n\nexport interface FilterResponse {\n  status: 'cached' | 'processing';\n  transcript?: Transcript;\n  job_id?: string;\n  message?: string;\n}\n\nexport interface JobStatusResponse {\n  status: 'pending' | 'processing' | 'completed' | 'failed';\n  progress: number;\n  transcript?: Transcript;\n  error?: string;\n}\n\n// Profanity Types\n\nexport type SeverityLevel = 'mild' | 'moderate' | 'severe';\n\nexport interface ProfanityWord {\n  word: string;\n  severity: SeverityLevel;\n}\n\nexport interface MuteInterval {\n  start: number;\n  end: number;\n  word: string;\n  severity: SeverityLevel;\n}\n\nexport interface ProfanityMatch {\n  segmentIndex: number;\n  word: string;\n  severity: SeverityLevel;\n  startTime: number;\n  endTime: number;\n  isPartialMatch: boolean;\n  matchedPortion?: string;\n}\n\n// User Preferences\n\nexport type FilterMode = 'mute' | 'bleep';\n\nexport interface UserPreferences {\n  enabled: boolean;\n  filterMode: FilterMode;\n  severityLevels: {\n    mild: boolean;\n    moderate: boolean;\n    severe: boolean;\n  };\n  customBlacklist: string[];\n  customWhitelist: string[];\n  paddingMs: number;\n  mergeThresholdMs: number;\n}\n\nexport const DEFAULT_PREFERENCES: UserPreferences = {\n  enabled: true,\n  filterMode: 'mute',\n  severityLevels: {\n    mild: false,\n    moderate: true,\n    severe: true,\n  },\n  customBlacklist: [],\n  customWhitelist: [],\n  paddingMs: 50,\n  mergeThresholdMs: 100,\n};\n\n// Storage Types\n\nexport interface StorageData {\n  preferences: UserPreferences;\n  authToken?: string;\n  userId?: string;\n  subscriptionTier?: 'free' | 'basic' | 'professional' | 'unlimited';\n  cachedTranscripts: Record<string, Transcript>;\n}\n\n// Message Types (between content script and background)\n\nexport type MessageType =\n  | 'GET_FILTER'\n  | 'CHECK_JOB'\n  | 'GET_PREFERENCES'\n  | 'SET_PREFERENCES'\n  | 'GET_AUTH_STATUS'\n  | 'CLEAR_CACHE';\n\nexport interface Message<T = unknown> {\n  type: MessageType;\n  payload?: T;\n}\n\nexport interface MessageResponse<T = unknown> {\n  success: boolean;\n  data?: T;\n  error?: string;\n}\n","// SafePlay Content Script - Main Entry Point\nimport { ResilientInjector } from './resilient-injector';\nimport { VideoController } from './video-controller';\nimport { UserPreferences, DEFAULT_PREFERENCES } from '../types';\nimport './styles.css';\n\nconst DEBUG = true;\n\nfunction log(...args: unknown[]): void {\n  if (DEBUG) {\n    console.log('[SafePlay]', ...args);\n  }\n}\n\nclass SafePlayContentScript {\n  private injector: ResilientInjector;\n  private videoController: VideoController | null = null;\n  private preferences: UserPreferences = DEFAULT_PREFERENCES;\n  private currentVideoId: string | null = null;\n\n  constructor() {\n    // Initialize resilient injector for video watch page\n    this.injector = new ResilientInjector({\n      onButtonClick: (youtubeId) => this.onFilterButtonClick(youtubeId),\n      debug: DEBUG,\n    });\n\n    // Initialize video controller\n    this.videoController = new VideoController({\n      onStateChange: (state) => this.onVideoStateChange(state),\n      debug: DEBUG,\n    });\n  }\n\n  async initialize(): Promise<void> {\n    log('Initializing SafePlay content script');\n\n    // Load user preferences\n    await this.loadPreferences();\n\n    // Start injector - it handles watch page detection internally\n    this.injector.start();\n\n    // Check if we're on a watch page and auto-filter if enabled\n    if (this.isWatchPage()) {\n      await this.handleWatchPage();\n    }\n\n    // Listen for messages from background/popup\n    this.setupMessageListener();\n\n    // Listen for URL changes (YouTube SPA)\n    this.setupNavigationListener();\n\n    log('SafePlay initialized');\n  }\n\n  private async loadPreferences(): Promise<void> {\n    try {\n      const response = await chrome.runtime.sendMessage({\n        type: 'GET_PREFERENCES',\n      });\n\n      if (response.success && response.data) {\n        this.preferences = response.data;\n      }\n    } catch (error) {\n      log('Failed to load preferences:', error);\n    }\n  }\n\n  private isWatchPage(): boolean {\n    return window.location.pathname === '/watch';\n  }\n\n  private getVideoIdFromUrl(): string | null {\n    const params = new URLSearchParams(window.location.search);\n    return params.get('v');\n  }\n\n  private async handleWatchPage(): Promise<void> {\n    const videoId = this.getVideoIdFromUrl();\n    if (!videoId) return;\n\n    // Don't re-initialize for same video\n    if (videoId === this.currentVideoId) return;\n\n    this.currentVideoId = videoId;\n    log('Watch page detected, video ID:', videoId);\n\n    // Create player controls\n    this.injectPlayerControls();\n  }\n\n  private async startFiltering(videoId: string): Promise<void> {\n    if (!this.videoController) return;\n\n    // Update button state to loading\n    this.injector.updateButtonState('loading', 'Loading...');\n\n    try {\n      await this.videoController.initialize(videoId, this.preferences);\n      await this.videoController.applyFilter();\n      this.injector.updateButtonState('active', 'Filtering');\n    } catch (error) {\n      log('Failed to start filtering:', error);\n      this.injector.updateButtonState('error', 'Error');\n    }\n  }\n\n  private injectPlayerControls(): void {\n    // Check if already injected\n    if (document.querySelector('.safeplay-player-controls')) return;\n\n    // Wait for player controls to be available\n    const waitForControls = () => {\n      const rightControls = document.querySelector('.ytp-right-controls');\n      if (rightControls) {\n        this.createPlayerButton(rightControls);\n      } else {\n        setTimeout(waitForControls, 500);\n      }\n    };\n\n    waitForControls();\n  }\n\n  private createPlayerButton(container: Element): void {\n    const button = document.createElement('button');\n    button.className = 'ytp-button safeplay-player-controls';\n    button.title = 'SafePlay Filter';\n    button.innerHTML = `\n      <svg viewBox=\"0 0 24 24\" fill=\"currentColor\" width=\"24\" height=\"24\">\n        <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z\"/>\n      </svg>\n    `;\n\n    button.addEventListener('click', () => this.toggleFilter());\n\n    // Insert before settings button\n    const settingsButton = container.querySelector('.ytp-settings-button');\n    if (settingsButton) {\n      container.insertBefore(button, settingsButton);\n    } else {\n      container.appendChild(button);\n    }\n\n    this.updatePlayerButtonState();\n  }\n\n  private updatePlayerButtonState(): void {\n    const button = document.querySelector('.safeplay-player-controls');\n    if (!button) return;\n\n    const state = this.videoController?.getState();\n    const isActive = state?.status === 'active';\n\n    button.classList.toggle('safeplay-active', isActive);\n    button.setAttribute('title', isActive ? 'SafePlay Active' : 'SafePlay Inactive');\n  }\n\n  private async toggleFilter(): Promise<void> {\n    if (!this.videoController) return;\n\n    const state = this.videoController.getState();\n\n    if (state.status === 'active') {\n      this.videoController.stop();\n      this.injector.updateButtonState('idle');\n    } else if (this.currentVideoId) {\n      await this.startFiltering(this.currentVideoId);\n    }\n\n    this.updatePlayerButtonState();\n  }\n\n  private onFilterButtonClick(youtubeId: string): void {\n    log('Filter button clicked for:', youtubeId);\n\n    // Start filtering for this video\n    this.startFiltering(youtubeId);\n  }\n\n  private onVideoStateChange(state: ReturnType<VideoController['getState']>): void {\n    log('Video state changed:', state);\n    this.updatePlayerButtonState();\n\n    // Update the SafePlay button based on state\n    if (state.status === 'active') {\n      this.injector.updateButtonState('active', 'Filtering');\n    } else if (state.status === 'error') {\n      this.injector.updateButtonState('error', 'Error');\n    } else if (state.status === 'loading') {\n      this.injector.updateButtonState('loading', 'Loading...');\n    } else {\n      this.injector.updateButtonState('idle');\n    }\n\n    // Notify popup of state change\n    chrome.runtime.sendMessage({\n      type: 'VIDEO_STATE_CHANGED',\n      payload: state,\n    }).catch(() => {\n      // Popup might not be open\n    });\n  }\n\n  private setupMessageListener(): void {\n    chrome.runtime.onMessage.addListener((message, _sender, sendResponse) => {\n      this.handleMessage(message).then(sendResponse);\n      return true; // Keep channel open for async response\n    });\n  }\n\n  private async handleMessage(message: { type: string; payload?: unknown }): Promise<unknown> {\n    switch (message.type) {\n      case 'PREFERENCES_UPDATED': {\n        const newPrefs = message.payload as UserPreferences;\n        this.preferences = newPrefs;\n        this.videoController?.updatePreferences(newPrefs);\n        return { success: true };\n      }\n\n      case 'TRANSCRIPT_RECEIVED': {\n        const transcript = message.payload as { transcript: unknown };\n        this.videoController?.onTranscriptReceived(transcript.transcript as import('../types').Transcript);\n        return { success: true };\n      }\n\n      case 'PROCESSING_PROGRESS': {\n        const progress = (message.payload as { progress: number }).progress;\n        this.videoController?.onProcessingProgress(progress);\n        return { success: true };\n      }\n\n      case 'PROCESSING_ERROR': {\n        const error = (message.payload as { error: string }).error;\n        this.videoController?.onProcessingError(error);\n        return { success: true };\n      }\n\n      case 'GET_VIDEO_STATE': {\n        return {\n          success: true,\n          data: this.videoController?.getState() || null,\n        };\n      }\n\n      default:\n        return { success: false, error: 'Unknown message type' };\n    }\n  }\n\n  private setupNavigationListener(): void {\n    // YouTube SPA navigation\n    document.addEventListener('yt-navigate-finish', () => {\n      log('YouTube navigation detected');\n      this.onNavigation();\n    });\n\n    // Fallback: popstate\n    window.addEventListener('popstate', () => {\n      this.onNavigation();\n    });\n  }\n\n  private onNavigation(): void {\n    // Stop current filter if any\n    if (this.videoController) {\n      this.videoController.stop();\n    }\n\n    // Reset current video\n    this.currentVideoId = null;\n\n    // Check if on watch page\n    if (this.isWatchPage()) {\n      setTimeout(() => {\n        this.handleWatchPage();\n      }, 500);\n    }\n  }\n}\n\n// Initialize when DOM is ready\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', () => {\n    const safeplay = new SafePlayContentScript();\n    safeplay.initialize();\n  });\n} else {\n  const safeplay = new SafePlayContentScript();\n  safeplay.initialize();\n}\n"],"names":["BUTTON_CONTAINER_CLASS","ResilientInjector","constructor","options","observer","currentVideoId","injectionAttempts","maxAttempts","retryInterval","this","start","log","isWatchPage","attemptInjection","setupMutationObserver","setupNavigationListener","stop","disconnect","clearInterval","window","location","pathname","search","includes","getVideoId","URLSearchParams","get","videoId","isButtonPresent","subscribeButton","findSubscribeButton","injectButton","setInterval","selectors","selector","element","document","querySelector","existingButton","remove","container","createElement","className","style","cssText","setAttribute","button","title","iconWrapper","innerHTML","textSpan","textContent","appendChild","addEventListener","background","boxShadow","transform","e","preventDefault","stopPropagation","onButtonClick","parentElement","insertBefore","nextSibling","updateButtonState","state","message","cursor","MutationObserver","mutations","mutation","type","addedNodes","length","node","HTMLElement","id","closest","observe","body","childList","subtree","originalPushState","history","pushState","originalReplaceState","replaceState","args","apply","onNavigation","setTimeout","debug","console","AudioFilter","video","muteIntervals","filterMode","isActive","checkIntervalId","isMuted","audioContext","bleepOscillator","bleepGain","onMuteStart","onMuteEnd","initialize","intervals","mode","sort","a","b","initializeAudioContext","AudioContext","createGain","gain","value","connect","destination","error","checkCurrentTime","unmute","close","currentTime","activeInterval","findActiveInterval","mute","time","low","high","mid","Math","floor","interval","end","muted","startBleep","stopBleep","resume","createOscillator","frequency","setValueAtTime","linearRampToValueAtTime","updateIntervals","updateMode","getState","intervalCount","isFiltering","getIntervals","PROFANITY_MAP","Map","word","severity","map","item","toLowerCase","findEmbeddedProfanity","text","results","lowerText","index","indexOf","push","startIndex","endIndex","filtered","match","lastMatch","TranscriptParser","preferences","customBlacklistMap","customBlacklist","customWhitelistSet","Set","customWhitelist","shouldFilterSeverity","severityLevels","shouldFilterWord","lowerWord","has","getWordSeverity","findProfanityMatches","segments","matches","i","segment","normalizedText","trim","exactSeverity","segmentIndex","startTime","start_time","endTime","end_time","isPartialMatch","embeddedMatches","customWord","embedded","characters","startChar","endChar","matchedPortion","substring","createMuteIntervals","paddingSeconds","paddingMs","max","mergeIntervals","sorted","mergeThresholdSeconds","mergeThresholdMs","merged","current","last","severityRank","mild","moderate","severe","parse","transcript","parseTranscript","VideoController","youtubeId","status","progress","statusOverlay","audioFilter","updateStatus","findVideoElement","waitForVideo","applyFilter","enabled","response","chrome","runtime","sendMessage","payload","success","Error","data","processTranscript","showStatusOverlay","onTranscriptReceived","onProcessingProgress","onProcessingError","hideStatusOverlay","updatePreferences","filterState","currentlyMuting","src","timeout","Promise","resolve","Date","now","check","requestAnimationFrame","onStateChange","playerContainer","classList","add","notifyStateChange","DEFAULT_PREFERENCES","DEBUG","SafePlayContentScript","videoController","injector","onFilterButtonClick","onVideoStateChange","loadPreferences","handleWatchPage","setupMessageListener","getVideoIdFromUrl","injectPlayerControls","startFiltering","waitForControls","rightControls","createPlayerButton","toggleFilter","settingsButton","updatePlayerButtonState","toggle","catch","onMessage","addListener","_sender","sendResponse","handleMessage","then","newPrefs","readyState"],"ignoreList":[],"sourceRoot":""}