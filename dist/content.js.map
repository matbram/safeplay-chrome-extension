{"version":3,"file":"content.js","mappings":"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","sources":["webpack://safeplay-chrome-extension/./src/content/resilient-injector.ts","webpack://safeplay-chrome-extension/./src/filter/audio-filter.ts","webpack://safeplay-chrome-extension/./src/filter/profanity-list.ts","webpack://safeplay-chrome-extension/./src/filter/transcript-parser.ts","webpack://safeplay-chrome-extension/./src/content/video-controller.ts","webpack://safeplay-chrome-extension/./src/types/index.ts","webpack://safeplay-chrome-extension/./src/content/index.ts"],"sourcesContent":["// SafePlay Video Page Button Injector\n// Injects the SafePlay button next to the Subscribe button on YouTube watch pages\n\nimport { ButtonState, ButtonStateInfo } from '../types';\n\nexport interface InjectorOptions {\n  onButtonClick: (youtubeId: string) => void;\n  debug?: boolean;\n}\n\nconst PROCESSED_ATTR = 'data-safeplay-processed';\nconst BUTTON_CONTAINER_CLASS = 'safeplay-video-page-button-container';\n\n// Button state configurations with colors and text\nconst BUTTON_STATES: Record<ButtonState, { bg: string; hoverBg: string; text: string; shadow: string }> = {\n  idle: {\n    bg: 'linear-gradient(135deg, #4CAF50 0%, #45a049 100%)',\n    hoverBg: 'linear-gradient(135deg, #45a049 0%, #3d8b40 100%)',\n    text: 'SafePlay',\n    shadow: 'rgba(76, 175, 80, 0.3)',\n  },\n  connecting: {\n    bg: 'linear-gradient(135deg, #607D8B 0%, #546E7A 100%)',\n    hoverBg: 'linear-gradient(135deg, #546E7A 0%, #455A64 100%)',\n    text: 'Connecting...',\n    shadow: 'rgba(96, 125, 139, 0.3)',\n  },\n  downloading: {\n    bg: 'linear-gradient(135deg, #7E57C2 0%, #673AB7 100%)',\n    hoverBg: 'linear-gradient(135deg, #673AB7 0%, #5E35B1 100%)',\n    text: 'Analyzing...',\n    shadow: 'rgba(126, 87, 194, 0.3)',\n  },\n  transcribing: {\n    bg: 'linear-gradient(135deg, #7E57C2 0%, #673AB7 100%)',\n    hoverBg: 'linear-gradient(135deg, #673AB7 0%, #5E35B1 100%)',\n    text: 'Analyzing...',\n    shadow: 'rgba(126, 87, 194, 0.3)',\n  },\n  processing: {\n    bg: 'linear-gradient(135deg, #7E57C2 0%, #673AB7 100%)',\n    hoverBg: 'linear-gradient(135deg, #673AB7 0%, #5E35B1 100%)',\n    text: 'Analyzing...',\n    shadow: 'rgba(126, 87, 194, 0.3)',\n  },\n  filtering: {\n    bg: 'linear-gradient(135deg, #26A69A 0%, #00897B 100%)',\n    hoverBg: 'linear-gradient(135deg, #00897B 0%, #00796B 100%)',\n    text: 'Active',\n    shadow: 'rgba(38, 166, 154, 0.3)',\n  },\n  error: {\n    bg: 'linear-gradient(135deg, #EF5350 0%, #E53935 100%)',\n    hoverBg: 'linear-gradient(135deg, #E53935 0%, #D32F2F 100%)',\n    text: 'Retry',\n    shadow: 'rgba(239, 83, 80, 0.3)',\n  },\n};\n\nexport class ResilientInjector {\n  private options: InjectorOptions;\n  private observer: MutationObserver | null = null;\n  private currentVideoId: string | null = null;\n  private injectionAttempts = 0;\n  private maxAttempts = 50;\n  private retryInterval: number | null = null;\n  private currentState: ButtonState = 'idle';\n\n  constructor(options: InjectorOptions) {\n    this.options = options;\n  }\n\n  // Start observing and injecting\n  start(): void {\n    this.log('Starting video page injector');\n\n    // Initial injection attempt\n    this.attemptInjection();\n\n    // Set up mutation observer for SPA navigation\n    this.setupMutationObserver();\n\n    // Listen for YouTube SPA navigation\n    this.setupNavigationListener();\n  }\n\n  // Stop observing\n  stop(): void {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = null;\n    }\n\n    if (this.retryInterval !== null) {\n      clearInterval(this.retryInterval);\n      this.retryInterval = null;\n    }\n\n    this.log('Stopped video page injector');\n  }\n\n  private isWatchPage(): boolean {\n    return window.location.pathname === '/watch' &&\n           window.location.search.includes('v=');\n  }\n\n  private getVideoId(): string | null {\n    const urlParams = new URLSearchParams(window.location.search);\n    return urlParams.get('v');\n  }\n\n  // Main injection function\n  private attemptInjection(): void {\n    if (!this.isWatchPage()) {\n      return;\n    }\n\n    const videoId = this.getVideoId();\n    if (!videoId) {\n      this.log('No video ID found');\n      return;\n    }\n\n    // Check if already injected for this video\n    if (this.currentVideoId === videoId && this.isButtonPresent()) {\n      this.log('Button already present for this video');\n      return;\n    }\n\n    // Try to find the subscribe button container\n    const subscribeButton = this.findSubscribeButton();\n\n    if (subscribeButton) {\n      this.injectButton(subscribeButton, videoId);\n      this.currentVideoId = videoId;\n      this.injectionAttempts = 0;\n      if (this.retryInterval !== null) {\n        clearInterval(this.retryInterval);\n        this.retryInterval = null;\n      }\n    } else {\n      this.injectionAttempts++;\n      this.log(`Subscribe button not found, attempt ${this.injectionAttempts}/${this.maxAttempts}`);\n\n      // Retry with interval\n      if (this.injectionAttempts < this.maxAttempts && this.retryInterval === null) {\n        this.retryInterval = window.setInterval(() => {\n          this.attemptInjection();\n        }, 200);\n      }\n    }\n  }\n\n  private findSubscribeButton(): HTMLElement | null {\n    const selectors = [\n      '#subscribe-button.ytd-watch-metadata',\n      'ytd-watch-metadata #subscribe-button',\n      '#owner #subscribe-button',\n      '#subscribe-button',\n    ];\n\n    for (const selector of selectors) {\n      const element = document.querySelector<HTMLElement>(selector);\n      if (element) {\n        this.log(`Found subscribe button with selector: ${selector}`);\n        return element;\n      }\n    }\n\n    return null;\n  }\n\n  private isButtonPresent(): boolean {\n    return document.querySelector(`.${BUTTON_CONTAINER_CLASS}`) !== null;\n  }\n\n  private injectButton(subscribeButton: HTMLElement, videoId: string): void {\n    // Remove any existing SafePlay button\n    const existingButton = document.querySelector(`.${BUTTON_CONTAINER_CLASS}`);\n    if (existingButton) {\n      existingButton.remove();\n    }\n\n    // Reset state for new video\n    this.currentState = 'idle';\n\n    // Create button container\n    const container = document.createElement('div');\n    container.className = `${BUTTON_CONTAINER_CLASS} style-scope ytd-watch-metadata`;\n    container.style.cssText = 'display: inline-flex; align-items: center; margin-left: 8px;';\n    container.setAttribute(PROCESSED_ATTR, 'true');\n\n    // Create the button matching YouTube's style\n    const button = document.createElement('button');\n    button.className = 'safeplay-main-button yt-spec-button-shape-next yt-spec-button-shape-next--tonal yt-spec-button-shape-next--mono yt-spec-button-shape-next--size-m yt-spec-button-shape-next--icon-leading';\n    button.title = 'Filter profanity with SafePlay';\n    button.setAttribute('aria-label', 'SafePlay Filter');\n    button.setAttribute('data-video-id', videoId);\n\n    const stateConfig = BUTTON_STATES.idle;\n    button.style.cssText = `\n      border: none;\n      background: ${stateConfig.bg};\n      color: #ffffff;\n      border-radius: 18px;\n      padding: 0 16px;\n      height: 36px;\n      font-family: \"Roboto\", \"Arial\", sans-serif;\n      font-size: 14px;\n      font-weight: 500;\n      line-height: 36px;\n      display: inline-flex;\n      align-items: center;\n      justify-content: center;\n      gap: 6px;\n      cursor: pointer;\n      transition: all 0.2s ease;\n      min-width: 120px;\n      box-shadow: 0 2px 4px ${stateConfig.shadow};\n      position: relative;\n      overflow: hidden;\n    `;\n\n    // Create progress bar (hidden initially)\n    const progressBar = document.createElement('div');\n    progressBar.className = 'safeplay-progress-bar';\n    progressBar.style.cssText = `\n      position: absolute;\n      bottom: 0;\n      left: 0;\n      height: 3px;\n      width: 0%;\n      background: rgba(255, 255, 255, 0.5);\n      transition: width 0.3s ease;\n      border-radius: 0 0 18px 18px;\n    `;\n\n    // Add icon\n    const iconWrapper = document.createElement('div');\n    iconWrapper.className = 'safeplay-icon';\n    iconWrapper.style.cssText = 'display: inline-flex; align-items: center; justify-content: center; width: 20px; height: 20px; flex-shrink: 0;';\n    iconWrapper.innerHTML = this.getIconSVG('idle');\n\n    // Add text\n    const textSpan = document.createElement('span');\n    textSpan.className = 'safeplay-text';\n    textSpan.style.cssText = 'color: currentColor; font-size: 14px; font-weight: 500; line-height: 1; white-space: nowrap;';\n    textSpan.textContent = stateConfig.text;\n\n    button.appendChild(iconWrapper);\n    button.appendChild(textSpan);\n    button.appendChild(progressBar);\n\n    // Add hover effects\n    button.addEventListener('mouseenter', () => {\n      const config = BUTTON_STATES[this.currentState];\n      button.style.background = config.hoverBg;\n      button.style.boxShadow = `0 4px 8px ${config.shadow}`;\n      button.style.transform = 'translateY(-1px)';\n    });\n\n    button.addEventListener('mouseleave', () => {\n      const config = BUTTON_STATES[this.currentState];\n      button.style.background = config.bg;\n      button.style.boxShadow = `0 2px 4px ${config.shadow}`;\n      button.style.transform = 'translateY(0)';\n    });\n\n    // Add click handler\n    button.addEventListener('click', (e) => {\n      e.preventDefault();\n      e.stopPropagation();\n\n      // Only allow click in idle or error state\n      if (this.currentState === 'idle' || this.currentState === 'error') {\n        this.options.onButtonClick(videoId);\n      }\n    });\n\n    container.appendChild(button);\n\n    // Insert after subscribe button\n    subscribeButton.parentElement?.insertBefore(container, subscribeButton.nextSibling);\n\n    this.log(`Injected SafePlay button for video: ${videoId}`);\n  }\n\n  private getIconSVG(state: ButtonState): string {\n    switch (state) {\n      case 'connecting':\n      case 'downloading':\n      case 'transcribing':\n      case 'processing':\n        // Spinning loader icon\n        return `\n          <svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" class=\"safeplay-spinner\">\n            <style>.safeplay-spinner { animation: safeplay-spin 1s linear infinite; } @keyframes safeplay-spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }</style>\n            <circle cx=\"12\" cy=\"12\" r=\"10\" stroke-opacity=\"0.25\"/>\n            <path d=\"M12 2a10 10 0 0 1 10 10\" stroke-linecap=\"round\"/>\n          </svg>\n        `;\n      case 'filtering':\n        // Active shield icon\n        return `\n          <svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n            <path d=\"M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm-2 16l-4-4 1.41-1.41L10 14.17l6.59-6.59L18 9l-8 8z\"/>\n          </svg>\n        `;\n      case 'error':\n        // Error icon\n        return `\n          <svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n            <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z\"/>\n          </svg>\n        `;\n      default:\n        // Default checkmark icon\n        return `\n          <svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n            <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z\"/>\n          </svg>\n        `;\n    }\n  }\n\n  // Update button state with detailed info\n  updateButtonState(stateInfo: ButtonStateInfo): void {\n    const container = document.querySelector(`.${BUTTON_CONTAINER_CLASS}`);\n    if (!container) return;\n\n    const button = container.querySelector<HTMLButtonElement>('.safeplay-main-button');\n    const textSpan = container.querySelector<HTMLSpanElement>('.safeplay-text');\n    const iconWrapper = container.querySelector<HTMLDivElement>('.safeplay-icon');\n    const progressBar = container.querySelector<HTMLDivElement>('.safeplay-progress-bar');\n\n    if (!button || !textSpan || !iconWrapper) return;\n\n    this.currentState = stateInfo.state;\n    const config = BUTTON_STATES[stateInfo.state];\n\n    // Update colors\n    button.style.background = config.bg;\n    button.style.boxShadow = `0 2px 4px ${config.shadow}`;\n\n    // Update icon\n    iconWrapper.innerHTML = this.getIconSVG(stateInfo.state);\n\n    // Update text\n    let displayText = stateInfo.text || config.text;\n\n    // Add progress percentage for processing states\n    if (stateInfo.progress !== undefined && stateInfo.progress > 0) {\n      if (stateInfo.state === 'downloading' || stateInfo.state === 'transcribing' || stateInfo.state === 'processing') {\n        displayText = `${config.text.replace('...', '')} ${Math.round(stateInfo.progress)}%`;\n      }\n    }\n\n    // Add interval count for filtering state\n    if (stateInfo.state === 'filtering' && stateInfo.intervalCount !== undefined) {\n      displayText = `Filtering (${stateInfo.intervalCount})`;\n    }\n\n    textSpan.textContent = displayText;\n\n    // Update progress bar\n    if (progressBar) {\n      if (stateInfo.progress !== undefined && stateInfo.progress > 0 && stateInfo.progress < 100) {\n        progressBar.style.width = `${stateInfo.progress}%`;\n        progressBar.style.display = 'block';\n      } else {\n        progressBar.style.width = '0%';\n        progressBar.style.display = 'none';\n      }\n    }\n\n    // Update cursor\n    if (stateInfo.state === 'idle' || stateInfo.state === 'error') {\n      button.style.cursor = 'pointer';\n    } else {\n      button.style.cursor = 'default';\n    }\n\n    // Update title/tooltip\n    switch (stateInfo.state) {\n      case 'connecting':\n        button.title = 'Connecting to SafePlay service...';\n        break;\n      case 'downloading':\n        button.title = `Downloading video audio${stateInfo.progress ? ` (${Math.round(stateInfo.progress)}%)` : '...'}`;\n        break;\n      case 'transcribing':\n        button.title = `Transcribing audio${stateInfo.progress ? ` (${Math.round(stateInfo.progress)}%)` : '...'}`;\n        break;\n      case 'processing':\n        button.title = 'Processing transcript...';\n        break;\n      case 'filtering':\n        button.title = `Filtering profanity${stateInfo.intervalCount ? ` - ${stateInfo.intervalCount} instances found` : ''}`;\n        break;\n      case 'error':\n        button.title = stateInfo.error || 'An error occurred. Click to retry.';\n        break;\n      default:\n        button.title = 'Click to filter profanity with SafePlay';\n    }\n\n    this.log(`Button state updated to: ${stateInfo.state}`, stateInfo);\n  }\n\n  // Convenience method for simple state updates\n  setButtonState(state: ButtonState, text?: string, progress?: number): void {\n    this.updateButtonState({ state, text: text || '', progress });\n  }\n\n  // Set up mutation observer for dynamic content changes\n  private setupMutationObserver(): void {\n    this.observer = new MutationObserver((mutations) => {\n      for (const mutation of mutations) {\n        if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {\n          for (const node of mutation.addedNodes) {\n            if (node instanceof HTMLElement) {\n              if (node.id === 'subscribe-button' ||\n                  node.querySelector?.('#subscribe-button') ||\n                  node.closest?.('ytd-watch-metadata')) {\n                this.log('Subscribe button area changed, re-injecting');\n                this.attemptInjection();\n                return;\n              }\n            }\n          }\n        }\n      }\n    });\n\n    this.observer.observe(document.body, {\n      childList: true,\n      subtree: true,\n    });\n  }\n\n  // Listen for YouTube SPA navigation\n  private setupNavigationListener(): void {\n    const originalPushState = history.pushState;\n    const originalReplaceState = history.replaceState;\n\n    history.pushState = (...args) => {\n      originalPushState.apply(history, args);\n      this.onNavigation();\n    };\n\n    history.replaceState = (...args) => {\n      originalReplaceState.apply(history, args);\n      this.onNavigation();\n    };\n\n    window.addEventListener('popstate', () => {\n      this.onNavigation();\n    });\n\n    document.addEventListener('yt-navigate-finish', () => {\n      this.onNavigation();\n    });\n\n    document.addEventListener('yt-page-data-updated', () => {\n      this.log('Page data updated');\n      this.onNavigation();\n    });\n  }\n\n  private onNavigation(): void {\n    this.log('Navigation detected');\n    this.currentVideoId = null;\n    this.currentState = 'idle';\n    this.injectionAttempts = 0;\n\n    if (this.retryInterval !== null) {\n      clearInterval(this.retryInterval);\n      this.retryInterval = null;\n    }\n\n    setTimeout(() => {\n      this.attemptInjection();\n    }, 300);\n  }\n\n  // Get current video ID\n  getCurrentVideoId(): string | null {\n    return this.currentVideoId;\n  }\n\n  // Debug logging\n  private log(...args: unknown[]): void {\n    if (this.options.debug) {\n      console.log('[SafePlay Injector]', ...args);\n    }\n  }\n}\n","import { MuteInterval, FilterMode } from '../types';\n\n// Fade duration in seconds for smooth transitions\nconst FADE_DURATION = 0.04; // 40ms fade - fast but smooth\nconst FADE_BUFFER = 0.05; // 50ms - start fading before interval begins\n\nexport class AudioFilter {\n  private video: HTMLVideoElement | null = null;\n  private muteIntervals: MuteInterval[] = [];\n  private filterMode: FilterMode = 'mute';\n  private isActive = false;\n  private checkIntervalId: number | null = null;\n  private isMuted = false;\n  private isFading = false;\n\n  // Web Audio API for smooth volume control\n  private audioContext: AudioContext | null = null;\n  private sourceNode: MediaElementAudioSourceNode | null = null;\n  private gainNode: GainNode | null = null;\n\n  // Bleep sound nodes\n  private bleepOscillator: OscillatorNode | null = null;\n  private bleepGain: GainNode | null = null;\n\n  // Track current gain target to avoid redundant fades\n  private currentGainTarget = 1;\n\n  // Callbacks\n  private onMuteStart?: (interval: MuteInterval) => void;\n  private onMuteEnd?: () => void;\n\n  constructor(options?: {\n    onMuteStart?: (interval: MuteInterval) => void;\n    onMuteEnd?: () => void;\n  }) {\n    this.onMuteStart = options?.onMuteStart;\n    this.onMuteEnd = options?.onMuteEnd;\n  }\n\n  // Initialize with video element and mute intervals\n  initialize(\n    video: HTMLVideoElement,\n    intervals: MuteInterval[],\n    mode: FilterMode = 'mute'\n  ): void {\n    this.video = video;\n    this.muteIntervals = intervals;\n    this.filterMode = mode;\n\n    // Sort intervals by start time for efficient lookup\n    this.muteIntervals.sort((a, b) => a.start - b.start);\n\n    // Initialize Web Audio API for smooth volume control\n    this.initializeAudioContext();\n  }\n\n  private initializeAudioContext(): void {\n    if (!this.video || this.audioContext) return;\n\n    try {\n      this.audioContext = new AudioContext();\n\n      // Create source from video element\n      this.sourceNode = this.audioContext.createMediaElementSource(this.video);\n\n      // Create gain node for volume control\n      this.gainNode = this.audioContext.createGain();\n      this.gainNode.gain.value = 1; // Start at full volume\n\n      // Connect: video -> gain -> destination (speakers)\n      this.sourceNode.connect(this.gainNode);\n      this.gainNode.connect(this.audioContext.destination);\n\n      // Setup bleep gain for bleep mode\n      if (this.filterMode === 'bleep') {\n        this.bleepGain = this.audioContext.createGain();\n        this.bleepGain.gain.value = 0;\n        this.bleepGain.connect(this.audioContext.destination);\n      }\n\n      console.log('[SafePlay] Audio context initialized with smooth fading');\n    } catch (error) {\n      console.error('[SafePlay] Failed to initialize audio context:', error);\n      // Fallback: will use video.muted instead\n    }\n  }\n\n  // Start monitoring playback\n  start(): void {\n    if (this.isActive || !this.video) {\n      return;\n    }\n\n    this.isActive = true;\n\n    // Resume audio context if suspended (browser autoplay policy)\n    if (this.audioContext?.state === 'suspended') {\n      this.audioContext.resume();\n    }\n\n    // Check every 5ms for precise timing\n    this.checkIntervalId = window.setInterval(() => {\n      this.checkCurrentTime();\n    }, 5);\n\n    console.log('[SafePlay] Audio filter started with', this.muteIntervals.length, 'intervals (smooth fading enabled)');\n  }\n\n  // Stop monitoring\n  stop(): void {\n    if (!this.isActive) {\n      return;\n    }\n\n    this.isActive = false;\n\n    if (this.checkIntervalId !== null) {\n      clearInterval(this.checkIntervalId);\n      this.checkIntervalId = null;\n    }\n\n    // Restore full volume\n    this.fadeToVolume(1);\n\n    // Stop bleep if playing\n    if (this.bleepOscillator) {\n      this.bleepOscillator.stop();\n      this.bleepOscillator = null;\n    }\n\n    console.log('[SafePlay] Audio filter stopped');\n  }\n\n  // Clean up resources\n  destroy(): void {\n    this.stop();\n\n    if (this.sourceNode) {\n      this.sourceNode.disconnect();\n      this.sourceNode = null;\n    }\n\n    if (this.gainNode) {\n      this.gainNode.disconnect();\n      this.gainNode = null;\n    }\n\n    if (this.audioContext) {\n      this.audioContext.close();\n      this.audioContext = null;\n    }\n  }\n\n  // Check if current time falls within or is approaching any mute interval\n  private checkCurrentTime(): void {\n    if (!this.video || !this.isActive) {\n      return;\n    }\n\n    const currentTime = this.video.currentTime;\n\n    // Check if we're in an interval OR approaching one (within fade buffer)\n    const activeInterval = this.findActiveInterval(currentTime);\n    const approachingInterval = this.findApproachingInterval(currentTime);\n\n    if (activeInterval) {\n      // We're inside a mute interval - ensure volume is 0\n      if (!this.isMuted) {\n        this.startMute(activeInterval);\n      }\n    } else if (approachingInterval) {\n      // We're approaching an interval - start fading out\n      if (!this.isMuted && !this.isFading) {\n        this.startFadeOut(approachingInterval);\n      }\n    } else {\n      // We're outside all intervals - ensure volume is restored\n      if (this.isMuted) {\n        this.endMute();\n      }\n    }\n  }\n\n  // Find if we're currently inside a mute interval\n  private findActiveInterval(time: number): MuteInterval | null {\n    for (const interval of this.muteIntervals) {\n      if (time >= interval.start && time <= interval.end) {\n        return interval;\n      }\n      // Since sorted, we can break early\n      if (interval.start > time + FADE_BUFFER) {\n        break;\n      }\n    }\n    return null;\n  }\n\n  // Find if we're approaching a mute interval (within fade buffer)\n  private findApproachingInterval(time: number): MuteInterval | null {\n    for (const interval of this.muteIntervals) {\n      // Check if we're within the fade buffer before the interval starts\n      const fadeStartTime = interval.start - FADE_BUFFER;\n      if (time >= fadeStartTime && time < interval.start) {\n        return interval;\n      }\n      // Since sorted, we can break early\n      if (interval.start > time + FADE_BUFFER) {\n        break;\n      }\n    }\n    return null;\n  }\n\n  // Start fading out before the interval\n  private startFadeOut(interval: MuteInterval): void {\n    this.isFading = true;\n    this.fadeToVolume(0, () => {\n      this.isFading = false;\n      this.isMuted = true;\n      if (this.onMuteStart) {\n        this.onMuteStart(interval);\n      }\n    });\n\n    // Start bleep if in bleep mode\n    if (this.filterMode === 'bleep') {\n      this.startBleep();\n    }\n  }\n\n  // Immediately mute (when we enter an interval without approaching it first, e.g., seeking)\n  private startMute(interval: MuteInterval): void {\n    this.isMuted = true;\n    this.fadeToVolume(0);\n\n    if (this.filterMode === 'bleep') {\n      this.startBleep();\n    }\n\n    if (this.onMuteStart) {\n      this.onMuteStart(interval);\n    }\n  }\n\n  // End mute - fade back in\n  private endMute(): void {\n    this.isMuted = false;\n    this.fadeToVolume(1);\n\n    if (this.filterMode === 'bleep') {\n      this.stopBleep();\n    }\n\n    if (this.onMuteEnd) {\n      this.onMuteEnd();\n    }\n  }\n\n  // Smooth fade to target volume\n  private fadeToVolume(target: number, onComplete?: () => void): void {\n    // Skip if already at target\n    if (this.currentGainTarget === target) {\n      onComplete?.();\n      return;\n    }\n\n    this.currentGainTarget = target;\n\n    if (this.gainNode && this.audioContext) {\n      const now = this.audioContext.currentTime;\n\n      // Cancel any ongoing transitions\n      this.gainNode.gain.cancelScheduledValues(now);\n\n      // Set current value\n      this.gainNode.gain.setValueAtTime(this.gainNode.gain.value, now);\n\n      // Ramp to target over fade duration\n      this.gainNode.gain.linearRampToValueAtTime(target, now + FADE_DURATION);\n\n      // Call completion callback after fade\n      if (onComplete) {\n        setTimeout(onComplete, FADE_DURATION * 1000);\n      }\n    } else {\n      // Fallback to hard mute if no audio context\n      if (this.video) {\n        this.video.muted = target === 0;\n      }\n      onComplete?.();\n    }\n  }\n\n  private startBleep(): void {\n    if (!this.audioContext || !this.bleepGain) return;\n\n    // Resume audio context if suspended\n    if (this.audioContext.state === 'suspended') {\n      this.audioContext.resume();\n    }\n\n    // Create oscillator for bleep sound\n    this.bleepOscillator = this.audioContext.createOscillator();\n    this.bleepOscillator.type = 'sine';\n    this.bleepOscillator.frequency.value = 1000; // 1kHz bleep\n    this.bleepOscillator.connect(this.bleepGain);\n\n    // Fade in bleep\n    const now = this.audioContext.currentTime;\n    this.bleepGain.gain.setValueAtTime(0, now);\n    this.bleepGain.gain.linearRampToValueAtTime(0.3, now + FADE_DURATION);\n\n    this.bleepOscillator.start();\n  }\n\n  private stopBleep(): void {\n    if (!this.audioContext || !this.bleepGain || !this.bleepOscillator) return;\n\n    // Fade out bleep\n    const now = this.audioContext.currentTime;\n    this.bleepGain.gain.linearRampToValueAtTime(0, now + FADE_DURATION);\n\n    // Stop and disconnect after fade\n    const oscillator = this.bleepOscillator;\n    setTimeout(() => {\n      try {\n        oscillator.stop();\n        oscillator.disconnect();\n      } catch (e) {\n        // Already stopped\n      }\n    }, FADE_DURATION * 1000 + 10);\n\n    this.bleepOscillator = null;\n  }\n\n  // Update intervals (e.g., when preferences change)\n  updateIntervals(intervals: MuteInterval[]): void {\n    this.muteIntervals = intervals;\n    this.muteIntervals.sort((a, b) => a.start - b.start);\n  }\n\n  // Update filter mode\n  updateMode(mode: FilterMode): void {\n    this.filterMode = mode;\n\n    // Initialize bleep gain if switching to bleep mode\n    if (mode === 'bleep' && this.audioContext && !this.bleepGain) {\n      this.bleepGain = this.audioContext.createGain();\n      this.bleepGain.gain.value = 0;\n      this.bleepGain.connect(this.audioContext.destination);\n    }\n  }\n\n  // Get current state\n  getState(): {\n    isActive: boolean;\n    isMuted: boolean;\n    intervalCount: number;\n    filterMode: FilterMode;\n  } {\n    return {\n      isActive: this.isActive,\n      isMuted: this.isMuted,\n      intervalCount: this.muteIntervals.length,\n      filterMode: this.filterMode,\n    };\n  }\n\n  // Check if filtering is active\n  isFiltering(): boolean {\n    return this.isActive;\n  }\n\n  // Get all intervals (for debugging/display)\n  getIntervals(): MuteInterval[] {\n    return [...this.muteIntervals];\n  }\n}\n","import { ProfanityWord, SeverityLevel } from '../types';\n\n// Comprehensive profanity list with severity levels\n// Severity: mild (common/casual), moderate (offensive), severe (highly offensive)\n\nexport const PROFANITY_LIST: ProfanityWord[] = [\n  // Severe\n  { word: 'fuck', severity: 'severe' },\n  { word: 'fucking', severity: 'severe' },\n  { word: 'fucked', severity: 'severe' },\n  { word: 'fucker', severity: 'severe' },\n  { word: 'fuckers', severity: 'severe' },\n  { word: 'fucks', severity: 'severe' },\n  { word: 'motherfucker', severity: 'severe' },\n  { word: 'motherfucking', severity: 'severe' },\n  { word: 'motherfuckers', severity: 'severe' },\n  { word: 'cunt', severity: 'severe' },\n  { word: 'cunts', severity: 'severe' },\n  { word: 'nigger', severity: 'severe' },\n  { word: 'niggers', severity: 'severe' },\n  { word: 'nigga', severity: 'severe' },\n  { word: 'niggas', severity: 'severe' },\n  { word: 'faggot', severity: 'severe' },\n  { word: 'faggots', severity: 'severe' },\n  { word: 'fag', severity: 'severe' },\n  { word: 'fags', severity: 'severe' },\n  { word: 'retard', severity: 'severe' },\n  { word: 'retarded', severity: 'severe' },\n  { word: 'retards', severity: 'severe' },\n\n  // Moderate\n  { word: 'shit', severity: 'moderate' },\n  { word: 'shits', severity: 'moderate' },\n  { word: 'shitty', severity: 'moderate' },\n  { word: 'bullshit', severity: 'moderate' },\n  { word: 'horseshit', severity: 'moderate' },\n  { word: 'shithead', severity: 'moderate' },\n  { word: 'shitheads', severity: 'moderate' },\n  { word: 'ass', severity: 'moderate' },\n  { word: 'asses', severity: 'moderate' },\n  { word: 'asshole', severity: 'moderate' },\n  { word: 'assholes', severity: 'moderate' },\n  { word: 'bastard', severity: 'moderate' },\n  { word: 'bastards', severity: 'moderate' },\n  { word: 'bitch', severity: 'moderate' },\n  { word: 'bitches', severity: 'moderate' },\n  { word: 'bitchy', severity: 'moderate' },\n  { word: 'cock', severity: 'moderate' },\n  { word: 'cocks', severity: 'moderate' },\n  { word: 'cocksucker', severity: 'moderate' },\n  { word: 'cocksuckers', severity: 'moderate' },\n  { word: 'dick', severity: 'moderate' },\n  { word: 'dicks', severity: 'moderate' },\n  { word: 'dickhead', severity: 'moderate' },\n  { word: 'dickheads', severity: 'moderate' },\n  { word: 'pussy', severity: 'moderate' },\n  { word: 'pussies', severity: 'moderate' },\n  { word: 'prick', severity: 'moderate' },\n  { word: 'pricks', severity: 'moderate' },\n  { word: 'slut', severity: 'moderate' },\n  { word: 'sluts', severity: 'moderate' },\n  { word: 'slutty', severity: 'moderate' },\n  { word: 'whore', severity: 'moderate' },\n  { word: 'whores', severity: 'moderate' },\n  { word: 'twat', severity: 'moderate' },\n  { word: 'twats', severity: 'moderate' },\n  { word: 'wanker', severity: 'moderate' },\n  { word: 'wankers', severity: 'moderate' },\n  { word: 'bollocks', severity: 'moderate' },\n\n  // Mild\n  { word: 'damn', severity: 'mild' },\n  { word: 'damned', severity: 'mild' },\n  { word: 'dammit', severity: 'mild' },\n  { word: 'goddamn', severity: 'mild' },\n  { word: 'goddamnit', severity: 'mild' },\n  { word: 'hell', severity: 'mild' },\n  { word: 'crap', severity: 'mild' },\n  { word: 'crappy', severity: 'mild' },\n  { word: 'piss', severity: 'mild' },\n  { word: 'pissed', severity: 'mild' },\n  { word: 'pissing', severity: 'mild' },\n  { word: 'suck', severity: 'mild' },\n  { word: 'sucks', severity: 'mild' },\n  { word: 'sucked', severity: 'mild' },\n  { word: 'balls', severity: 'mild' },\n  { word: 'butt', severity: 'mild' },\n  { word: 'butthole', severity: 'mild' },\n  { word: 'screw', severity: 'mild' },\n  { word: 'screwed', severity: 'mild' },\n  { word: 'douche', severity: 'mild' },\n  { word: 'douchebag', severity: 'mild' },\n  { word: 'douchebags', severity: 'mild' },\n];\n\n// Create a Map for O(1) lookup\nexport const PROFANITY_MAP: Map<string, SeverityLevel> = new Map(\n  PROFANITY_LIST.map((item) => [item.word.toLowerCase(), item.severity])\n);\n\n// Get all words of a specific severity\nexport function getWordsBySeverity(severity: SeverityLevel): string[] {\n  return PROFANITY_LIST\n    .filter((item) => item.severity === severity)\n    .map((item) => item.word);\n}\n\n// Check if a word is profanity\nexport function isProfanity(word: string): boolean {\n  return PROFANITY_MAP.has(word.toLowerCase());\n}\n\n// Get the severity of a word\nexport function getSeverity(word: string): SeverityLevel | null {\n  return PROFANITY_MAP.get(word.toLowerCase()) || null;\n}\n\n// Find profanity within a longer word (e.g., \"fuck\" in \"motherfucker\")\nexport function findEmbeddedProfanity(\n  text: string\n): { word: string; severity: SeverityLevel; startIndex: number; endIndex: number }[] {\n  const results: {\n    word: string;\n    severity: SeverityLevel;\n    startIndex: number;\n    endIndex: number;\n  }[] = [];\n  const lowerText = text.toLowerCase();\n\n  for (const [word, severity] of PROFANITY_MAP) {\n    let index = lowerText.indexOf(word);\n    while (index !== -1) {\n      results.push({\n        word,\n        severity,\n        startIndex: index,\n        endIndex: index + word.length,\n      });\n      index = lowerText.indexOf(word, index + 1);\n    }\n  }\n\n  // Sort by start index and remove duplicates (prefer longer matches)\n  results.sort((a, b) => a.startIndex - b.startIndex);\n\n  // Remove overlapping matches, keeping the longer one\n  const filtered: typeof results = [];\n  for (const match of results) {\n    const lastMatch = filtered[filtered.length - 1];\n    if (!lastMatch || match.startIndex >= lastMatch.endIndex) {\n      filtered.push(match);\n    } else if (match.endIndex - match.startIndex > lastMatch.endIndex - lastMatch.startIndex) {\n      filtered[filtered.length - 1] = match;\n    }\n  }\n\n  return filtered;\n}\n","import {\n  TranscriptSegment,\n  Transcript,\n  MuteInterval,\n  UserPreferences,\n  SeverityLevel,\n  ProfanityMatch,\n} from '../types';\nimport {\n  PROFANITY_MAP,\n  findEmbeddedProfanity,\n} from './profanity-list';\n\nexport class TranscriptParser {\n  private preferences: UserPreferences;\n  private customBlacklistMap: Map<string, SeverityLevel>;\n  private customWhitelistSet: Set<string>;\n\n  constructor(preferences: UserPreferences) {\n    this.preferences = preferences;\n\n    // Build custom blacklist map (all custom words are severe by default)\n    this.customBlacklistMap = new Map(\n      preferences.customBlacklist.map((word) => [word.toLowerCase(), 'severe' as SeverityLevel])\n    );\n\n    // Build whitelist set\n    this.customWhitelistSet = new Set(\n      preferences.customWhitelist.map((word) => word.toLowerCase())\n    );\n  }\n\n  // Check if a severity level should be filtered based on preferences\n  private shouldFilterSeverity(severity: SeverityLevel): boolean {\n    return this.preferences.severityLevels[severity];\n  }\n\n  // Check if a word should be filtered (considering whitelist/blacklist)\n  private shouldFilterWord(word: string, severity: SeverityLevel): boolean {\n    const lowerWord = word.toLowerCase();\n\n    // Check whitelist first (user explicitly allowed)\n    if (this.customWhitelistSet.has(lowerWord)) {\n      return false;\n    }\n\n    // Check custom blacklist (always filter)\n    if (this.customBlacklistMap.has(lowerWord)) {\n      return true;\n    }\n\n    // Check severity level preference\n    return this.shouldFilterSeverity(severity);\n  }\n\n  // Get severity for a word (checking custom blacklist too)\n  private getWordSeverity(word: string): SeverityLevel | null {\n    const lowerWord = word.toLowerCase();\n\n    // Check custom blacklist first\n    if (this.customBlacklistMap.has(lowerWord)) {\n      return this.customBlacklistMap.get(lowerWord)!;\n    }\n\n    // Check built-in profanity list\n    return PROFANITY_MAP.get(lowerWord) || null;\n  }\n\n  // Get precise timing using character-level data\n  private getCharacterLevelTiming(\n    segment: TranscriptSegment,\n    startIndex: number,\n    endIndex: number\n  ): { startTime: number; endTime: number } {\n    let startTime = segment.start_time;\n    let endTime = segment.end_time;\n\n    if (segment.characters && segment.characters.length > 0) {\n      // Use character-level timing for precision\n      // Find the first character of the word\n      const startChar = segment.characters[startIndex];\n      // Find the last character of the word (endIndex is exclusive, so -1)\n      const endChar = segment.characters[Math.min(endIndex - 1, segment.characters.length - 1)];\n\n      if (startChar) {\n        startTime = startChar.start;\n      }\n      if (endChar) {\n        endTime = endChar.end;\n      }\n\n      console.log(`[SafePlay Parser] Character timing: \"${segment.text.substring(startIndex, endIndex)}\" ` +\n        `chars[${startIndex}..${endIndex-1}] -> ${startTime.toFixed(3)}s - ${endTime.toFixed(3)}s`);\n    }\n\n    return { startTime, endTime };\n  }\n\n  // Find profanity matches in transcript segments\n  findProfanityMatches(segments: TranscriptSegment[]): ProfanityMatch[] {\n    const matches: ProfanityMatch[] = [];\n\n    for (let i = 0; i < segments.length; i++) {\n      const segment = segments[i];\n      const normalizedText = segment.text.toLowerCase().trim();\n\n      // Check for exact word match first\n      const exactSeverity = this.getWordSeverity(normalizedText);\n      if (exactSeverity && this.shouldFilterWord(normalizedText, exactSeverity)) {\n        // Use character-level timing for precision even on exact matches\n        const { startTime, endTime } = this.getCharacterLevelTiming(segment, 0, segment.text.length);\n\n        matches.push({\n          segmentIndex: i,\n          word: segment.text,\n          severity: exactSeverity,\n          startTime,\n          endTime,\n          isPartialMatch: false,\n        });\n        continue;\n      }\n\n      // Check for embedded profanity within longer words\n      const embeddedMatches = findEmbeddedProfanity(normalizedText);\n\n      // Also check custom blacklist for embedded matches\n      for (const [customWord] of this.customBlacklistMap) {\n        const index = normalizedText.indexOf(customWord);\n        if (index !== -1) {\n          embeddedMatches.push({\n            word: customWord,\n            severity: 'severe',\n            startIndex: index,\n            endIndex: index + customWord.length,\n          });\n        }\n      }\n\n      for (const embedded of embeddedMatches) {\n        if (!this.shouldFilterWord(embedded.word, embedded.severity)) {\n          continue;\n        }\n\n        // Use character-level timing for precision\n        const { startTime, endTime } = this.getCharacterLevelTiming(\n          segment,\n          embedded.startIndex,\n          embedded.endIndex\n        );\n\n        matches.push({\n          segmentIndex: i,\n          word: embedded.word,\n          severity: embedded.severity,\n          startTime,\n          endTime,\n          isPartialMatch: true,\n          matchedPortion: segment.text.substring(embedded.startIndex, embedded.endIndex),\n        });\n      }\n    }\n\n    return matches;\n  }\n\n  // Convert profanity matches to mute intervals with padding\n  createMuteIntervals(matches: ProfanityMatch[]): MuteInterval[] {\n    // Use asymmetric padding if available, otherwise fall back to symmetric\n    const paddingBeforeSeconds = (this.preferences.paddingBeforeMs ?? this.preferences.paddingMs) / 1000;\n    const paddingAfterSeconds = (this.preferences.paddingAfterMs ?? this.preferences.paddingMs) / 1000;\n\n    return matches.map((match) => {\n      const interval = {\n        start: Math.max(0, match.startTime - paddingBeforeSeconds),\n        end: match.endTime + paddingAfterSeconds,\n        word: match.word,\n        severity: match.severity,\n      };\n\n      console.log(`[SafePlay Parser] Mute interval: \"${match.word}\" ` +\n        `${interval.start.toFixed(3)}s - ${interval.end.toFixed(3)}s ` +\n        `(padding: -${paddingBeforeSeconds * 1000}ms / +${paddingAfterSeconds * 1000}ms)`);\n\n      return interval;\n    });\n  }\n\n  // Merge overlapping or close intervals\n  mergeIntervals(intervals: MuteInterval[]): MuteInterval[] {\n    if (intervals.length === 0) {\n      return [];\n    }\n\n    // Sort by start time\n    const sorted = [...intervals].sort((a, b) => a.start - b.start);\n    const mergeThresholdSeconds = this.preferences.mergeThresholdMs / 1000;\n\n    const merged: MuteInterval[] = [sorted[0]];\n\n    for (let i = 1; i < sorted.length; i++) {\n      const current = sorted[i];\n      const last = merged[merged.length - 1];\n\n      // Merge if overlapping or within threshold\n      if (current.start <= last.end + mergeThresholdSeconds) {\n        // Extend the end time and combine words\n        last.end = Math.max(last.end, current.end);\n        // Keep the more severe classification\n        if (this.severityRank(current.severity) > this.severityRank(last.severity)) {\n          last.severity = current.severity;\n        }\n        // Append word if different\n        if (!last.word.includes(current.word)) {\n          last.word = `${last.word}, ${current.word}`;\n        }\n      } else {\n        merged.push({ ...current });\n      }\n    }\n\n    return merged;\n  }\n\n  private severityRank(severity: SeverityLevel): number {\n    const ranks: Record<SeverityLevel, number> = {\n      mild: 1,\n      moderate: 2,\n      severe: 3,\n    };\n    return ranks[severity];\n  }\n\n  // Main parsing function: transcript -> mute intervals\n  parse(transcript: Transcript): MuteInterval[] {\n    const matches = this.findProfanityMatches(transcript.segments);\n    const intervals = this.createMuteIntervals(matches);\n    return this.mergeIntervals(intervals);\n  }\n}\n\n// Utility function for quick parsing\nexport function parseTranscript(\n  transcript: Transcript,\n  preferences: UserPreferences\n): MuteInterval[] {\n  const parser = new TranscriptParser(preferences);\n  return parser.parse(transcript);\n}\n","// Controller for managing video filtering on watch pages\nimport { Transcript, MuteInterval, UserPreferences } from '../types';\nimport { AudioFilter } from '../filter/audio-filter';\nimport { parseTranscript } from '../filter/transcript-parser';\n\nexport type FilterStatus =\n  | 'idle'\n  | 'loading'\n  | 'processing'\n  | 'active'\n  | 'error'\n  | 'disabled';\n\nexport interface VideoControllerState {\n  status: FilterStatus;\n  progress: number;\n  error?: string;\n  intervalCount: number;\n  currentlyMuting: boolean;\n}\n\ninterface VideoControllerOptions {\n  onStateChange?: (state: VideoControllerState) => void;\n  debug?: boolean;\n}\n\nexport class VideoController {\n  private youtubeId: string | null = null;\n  private video: HTMLVideoElement | null = null;\n  private audioFilter: AudioFilter;\n  private transcript: Transcript | null = null;\n  private muteIntervals: MuteInterval[] = [];\n  private preferences: UserPreferences | null = null;\n  private status: FilterStatus = 'idle';\n  private progress = 0;\n  private error?: string;\n  private options: VideoControllerOptions;\n  private statusOverlay: HTMLElement | null = null;\n\n  constructor(options: VideoControllerOptions = {}) {\n    this.options = options;\n    this.audioFilter = new AudioFilter({\n      onMuteStart: (interval) => this.onMuteStart(interval),\n      onMuteEnd: () => this.onMuteEnd(),\n    });\n  }\n\n  // Initialize controller for a video\n  async initialize(\n    youtubeId: string,\n    preferences: UserPreferences\n  ): Promise<void> {\n    this.youtubeId = youtubeId;\n    this.preferences = preferences;\n    this.updateStatus('idle');\n\n    // Find video element\n    this.video = this.findVideoElement();\n    if (!this.video) {\n      this.log('Video element not found, waiting...');\n      await this.waitForVideo();\n    }\n\n    if (!this.video) {\n      this.updateStatus('error', 0, 'Could not find video element');\n      return;\n    }\n\n    this.log('Video controller initialized for:', youtubeId);\n  }\n\n  // Request and apply filter\n  async applyFilter(): Promise<void> {\n    if (!this.youtubeId || !this.video || !this.preferences) {\n      this.log('Cannot apply filter: missing required data');\n      return;\n    }\n\n    if (!this.preferences.enabled) {\n      this.updateStatus('disabled');\n      return;\n    }\n\n    try {\n      this.updateStatus('loading');\n\n      // Request transcript from background script\n      const response = await chrome.runtime.sendMessage({\n        type: 'GET_FILTER',\n        payload: { youtubeId: this.youtubeId },\n      });\n\n      if (!response.success) {\n        throw new Error(response.error || 'Failed to get transcript');\n      }\n\n      // If processing, we'll receive progress updates\n      if (response.data.status === 'processing') {\n        this.updateStatus('processing', response.data.progress || 0);\n        return; // Background will send completion message\n      }\n\n      // Parse transcript and create mute intervals\n      this.transcript = response.data.transcript;\n      await this.processTranscript();\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Unknown error';\n      this.updateStatus('error', 0, message);\n      this.log('Filter error:', error);\n    }\n  }\n\n  // Process transcript and start filtering\n  async processTranscript(): Promise<void> {\n    if (!this.transcript || !this.preferences || !this.video) {\n      return;\n    }\n\n    // Parse transcript for profanity\n    this.muteIntervals = parseTranscript(this.transcript, this.preferences);\n    this.log('Found', this.muteIntervals.length, 'mute intervals');\n\n    if (this.muteIntervals.length === 0) {\n      this.updateStatus('active');\n      this.log('No profanity detected in video');\n      return;\n    }\n\n    // Initialize and start audio filter\n    this.audioFilter.initialize(\n      this.video,\n      this.muteIntervals,\n      this.preferences.filterMode\n    );\n    this.audioFilter.start();\n\n    this.updateStatus('active');\n    this.showStatusOverlay();\n  }\n\n  // Handle transcript received from background\n  onTranscriptReceived(transcript: Transcript): void {\n    this.transcript = transcript;\n    this.processTranscript();\n  }\n\n  // Handle processing progress\n  onProcessingProgress(progress: number): void {\n    this.updateStatus('processing', progress);\n  }\n\n  // Handle processing error\n  onProcessingError(error: string): void {\n    this.updateStatus('error', 0, error);\n  }\n\n  // Stop filtering\n  stop(): void {\n    this.audioFilter.stop();\n    this.hideStatusOverlay();\n    this.updateStatus('idle');\n  }\n\n  // Resume filtering (re-start audio filter)\n  resume(): void {\n    if (!this.video || this.muteIntervals.length === 0) {\n      return;\n    }\n    this.audioFilter.start();\n    this.updateStatus('active');\n    this.showStatusOverlay();\n  }\n\n  // Update preferences\n  updatePreferences(preferences: UserPreferences): void {\n    this.preferences = preferences;\n\n    if (!preferences.enabled) {\n      this.stop();\n      return;\n    }\n\n    // Re-parse with new preferences\n    if (this.transcript) {\n      this.muteIntervals = parseTranscript(this.transcript, preferences);\n      this.audioFilter.updateIntervals(this.muteIntervals);\n      this.audioFilter.updateMode(preferences.filterMode);\n    }\n  }\n\n  // Get current state\n  getState(): VideoControllerState {\n    const filterState = this.audioFilter.getState();\n    return {\n      status: this.status,\n      progress: this.progress,\n      error: this.error,\n      intervalCount: filterState.intervalCount,\n      currentlyMuting: filterState.isMuted,\n    };\n  }\n\n  // Find the YouTube video element\n  private findVideoElement(): HTMLVideoElement | null {\n    // Main player video\n    const selectors = [\n      'video.html5-main-video',\n      'video.video-stream',\n      '#movie_player video',\n      'ytd-player video',\n      'video',\n    ];\n\n    for (const selector of selectors) {\n      const video = document.querySelector<HTMLVideoElement>(selector);\n      if (video && video.src) {\n        return video;\n      }\n    }\n\n    return null;\n  }\n\n  // Wait for video element to appear\n  private waitForVideo(timeout = 10000): Promise<HTMLVideoElement | null> {\n    return new Promise((resolve) => {\n      const startTime = Date.now();\n\n      const check = () => {\n        this.video = this.findVideoElement();\n        if (this.video) {\n          resolve(this.video);\n          return;\n        }\n\n        if (Date.now() - startTime > timeout) {\n          resolve(null);\n          return;\n        }\n\n        requestAnimationFrame(check);\n      };\n\n      check();\n    });\n  }\n\n  // Update status and notify listeners\n  private updateStatus(\n    status: FilterStatus,\n    progress = 0,\n    error?: string\n  ): void {\n    this.status = status;\n    this.progress = progress;\n    this.error = error;\n\n    if (this.options.onStateChange) {\n      this.options.onStateChange(this.getState());\n    }\n  }\n\n  // Show status overlay on video\n  private showStatusOverlay(): void {\n    if (this.statusOverlay) return;\n\n    const playerContainer = document.querySelector('#movie_player');\n    if (!playerContainer) return;\n\n    this.statusOverlay = document.createElement('div');\n    this.statusOverlay.className = 'safeplay-status-overlay';\n    this.statusOverlay.innerHTML = `\n      <div class=\"safeplay-status-badge\">\n        <svg class=\"safeplay-status-icon\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n          <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z\"/>\n        </svg>\n        <span>SafePlay Active</span>\n      </div>\n    `;\n\n    playerContainer.appendChild(this.statusOverlay);\n\n    // Auto-hide after 3 seconds\n    setTimeout(() => {\n      this.statusOverlay?.classList.add('safeplay-status-hidden');\n    }, 3000);\n  }\n\n  // Hide status overlay\n  private hideStatusOverlay(): void {\n    if (this.statusOverlay) {\n      this.statusOverlay.remove();\n      this.statusOverlay = null;\n    }\n  }\n\n  // Event handlers\n  private onMuteStart(interval: MuteInterval): void {\n    this.log('Muting:', interval.word);\n    this.notifyStateChange();\n  }\n\n  private onMuteEnd(): void {\n    this.notifyStateChange();\n  }\n\n  private notifyStateChange(): void {\n    if (this.options.onStateChange) {\n      this.options.onStateChange(this.getState());\n    }\n  }\n\n  // Debug logging\n  private log(...args: unknown[]): void {\n    if (this.options.debug) {\n      console.log('[SafePlay Controller]', ...args);\n    }\n  }\n}\n","// API Response Types\n\nexport interface CharacterTiming {\n  char: string;\n  start: number;\n  end: number;\n}\n\nexport interface TranscriptSegment {\n  text: string;\n  start_time: number;\n  end_time: number;\n  characters: CharacterTiming[];\n}\n\nexport interface Transcript {\n  id: string;\n  youtube_id?: string; // May be set from context\n  full_text?: string;\n  segments: TranscriptSegment[];\n  duration?: number;\n  language?: string;\n  created_at?: string;\n}\n\nexport interface FilterResponse {\n  status: 'completed' | 'processing';\n  cached?: boolean;\n  transcript?: Transcript;\n  job_id?: string;\n  message?: string;\n}\n\nexport interface JobStatusResponse {\n  status: 'pending' | 'downloading' | 'transcribing' | 'completed' | 'failed';\n  progress: number;\n  transcript?: Transcript;\n  error?: string;\n  video?: {\n    youtube_id: string;\n    title?: string;\n  };\n}\n\n// Button state for UX\nexport type ButtonState =\n  | 'idle'\n  | 'connecting'\n  | 'downloading'\n  | 'transcribing'\n  | 'processing'\n  | 'filtering'\n  | 'error';\n\nexport interface ButtonStateInfo {\n  state: ButtonState;\n  text: string;\n  progress?: number;\n  intervalCount?: number;\n  error?: string;\n}\n\n// Profanity Types\n\nexport type SeverityLevel = 'mild' | 'moderate' | 'severe';\n\nexport interface ProfanityWord {\n  word: string;\n  severity: SeverityLevel;\n}\n\nexport interface MuteInterval {\n  start: number;\n  end: number;\n  word: string;\n  severity: SeverityLevel;\n}\n\nexport interface ProfanityMatch {\n  segmentIndex: number;\n  word: string;\n  severity: SeverityLevel;\n  startTime: number;\n  endTime: number;\n  isPartialMatch: boolean;\n  matchedPortion?: string;\n}\n\n// User Preferences\n\nexport type FilterMode = 'mute' | 'bleep';\n\nexport interface UserPreferences {\n  enabled: boolean;\n  filterMode: FilterMode;\n  severityLevels: {\n    mild: boolean;\n    moderate: boolean;\n    severe: boolean;\n  };\n  customBlacklist: string[];\n  customWhitelist: string[];\n  paddingMs: number; // Legacy/fallback symmetric padding\n  paddingBeforeMs?: number; // Padding before word starts (catches attack)\n  paddingAfterMs?: number; // Padding after word ends (catches release)\n  mergeThresholdMs: number;\n}\n\nexport const DEFAULT_PREFERENCES: UserPreferences = {\n  enabled: true,\n  filterMode: 'mute',\n  severityLevels: {\n    mild: false,\n    moderate: true,\n    severe: true,\n  },\n  customBlacklist: [],\n  customWhitelist: [],\n  paddingMs: 50, // Legacy/fallback symmetric padding\n  paddingBeforeMs: 75, // Reduced - smooth fade adds ~90ms effective lead time\n  paddingAfterMs: 25, // Reduced - fade-in handles smooth transition\n  mergeThresholdMs: 100,\n};\n\n// Storage Types\n\nexport interface StorageData {\n  preferences: UserPreferences;\n  authToken?: string;\n  userId?: string;\n  subscriptionTier?: 'free' | 'basic' | 'professional' | 'unlimited';\n  cachedTranscripts: Record<string, Transcript>;\n}\n\n// Message Types (between content script and background)\n\nexport type MessageType =\n  | 'GET_FILTER'\n  | 'CHECK_JOB'\n  | 'GET_PREFERENCES'\n  | 'SET_PREFERENCES'\n  | 'GET_AUTH_STATUS'\n  | 'CLEAR_CACHE';\n\nexport interface Message<T = unknown> {\n  type: MessageType;\n  payload?: T;\n}\n\nexport interface MessageResponse<T = unknown> {\n  success: boolean;\n  data?: T;\n  error?: string;\n}\n","// SafePlay Content Script - Main Entry Point\nimport { ResilientInjector } from './resilient-injector';\nimport { VideoController } from './video-controller';\nimport { UserPreferences, DEFAULT_PREFERENCES, Transcript, ButtonStateInfo } from '../types';\nimport './styles.css';\n\nconst DEBUG = true;\n\nfunction log(...args: unknown[]): void {\n  if (DEBUG) {\n    console.log('[SafePlay]', ...args);\n  }\n}\n\nclass SafePlayContentScript {\n  private injector: ResilientInjector;\n  private videoController: VideoController | null = null;\n  private preferences: UserPreferences = DEFAULT_PREFERENCES;\n  private currentVideoId: string | null = null;\n  private isProcessing = false;\n\n  constructor() {\n    // Initialize resilient injector for video watch page\n    this.injector = new ResilientInjector({\n      onButtonClick: (youtubeId) => this.onFilterButtonClick(youtubeId),\n      debug: DEBUG,\n    });\n\n    // Initialize video controller\n    this.videoController = new VideoController({\n      onStateChange: (state) => this.onVideoStateChange(state),\n      debug: DEBUG,\n    });\n  }\n\n  async initialize(): Promise<void> {\n    log('Initializing SafePlay content script');\n\n    // Load user preferences\n    await this.loadPreferences();\n\n    // Start injector - it handles watch page detection internally\n    this.injector.start();\n\n    // Check if we're on a watch page\n    if (this.isWatchPage()) {\n      this.currentVideoId = this.getVideoIdFromUrl();\n    }\n\n    // Listen for messages from background/popup\n    this.setupMessageListener();\n\n    // Listen for URL changes (YouTube SPA)\n    this.setupNavigationListener();\n\n    log('SafePlay initialized');\n  }\n\n  private async loadPreferences(): Promise<void> {\n    try {\n      const response = await chrome.runtime.sendMessage({\n        type: 'GET_PREFERENCES',\n      });\n\n      if (response.success && response.data) {\n        this.preferences = response.data;\n      }\n    } catch (error) {\n      log('Failed to load preferences:', error);\n    }\n  }\n\n  private isWatchPage(): boolean {\n    return window.location.pathname === '/watch';\n  }\n\n  private getVideoIdFromUrl(): string | null {\n    const params = new URLSearchParams(window.location.search);\n    return params.get('v');\n  }\n\n  private updateButtonState(stateInfo: ButtonStateInfo): void {\n    this.injector.updateButtonState(stateInfo);\n  }\n\n  // Main filter flow - called when SafePlay button is clicked\n  private async onFilterButtonClick(youtubeId: string): Promise<void> {\n    if (this.isProcessing) {\n      log('Already processing, ignoring click');\n      return;\n    }\n\n    log('Filter button clicked for:', youtubeId);\n    this.isProcessing = true;\n    this.currentVideoId = youtubeId;\n\n    try {\n      // Step 1: Connecting\n      this.updateButtonState({ state: 'connecting', text: 'Connecting...' });\n\n      // Request filter from background script (which calls the API)\n      const response = await chrome.runtime.sendMessage({\n        type: 'GET_FILTER',\n        payload: { youtubeId },\n      });\n\n      if (!response.success) {\n        throw new Error(response.error || 'Failed to request filter');\n      }\n\n      const { status, transcript, jobId } = response.data;\n\n      if ((status === 'cached' || status === 'completed') && transcript) {\n        // Transcript was cached (locally or on server), skip to processing\n        log('Using cached transcript');\n        this.updateButtonState({ state: 'processing', text: 'Processing...' });\n        await this.applyFilter(transcript);\n      } else if (status === 'processing' && jobId) {\n        // Need to poll for job completion\n        log('Job started, polling for completion:', jobId);\n        await this.pollJobStatus(jobId);\n      } else {\n        throw new Error('Unexpected API response');\n      }\n    } catch (error) {\n      log('Filter request failed:', error);\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      this.updateButtonState({\n        state: 'error',\n        text: 'Error',\n        error: errorMessage,\n      });\n      this.isProcessing = false;\n    }\n  }\n\n  // Poll for job status with progress updates\n  private async pollJobStatus(jobId: string): Promise<void> {\n    const maxAttempts = 180; // 6 minutes max (2s intervals)\n    const pollInterval = 2000;\n    let attempts = 0;\n\n    while (attempts < maxAttempts) {\n      try {\n        const response = await chrome.runtime.sendMessage({\n          type: 'CHECK_JOB',\n          payload: { jobId },\n        });\n\n        if (!response.success) {\n          throw new Error(response.error || 'Failed to check job status');\n        }\n\n        const { status, progress, transcript, error } = response.data;\n\n        log(`Job status: ${status}, progress: ${progress}%`);\n\n        // Update button based on job status with user-friendly messages\n        switch (status) {\n          case 'pending':\n            this.updateButtonState({\n              state: 'processing',\n              text: 'Starting...',\n              progress: 5,\n            });\n            break;\n\n          case 'downloading':\n          case 'transcribing':\n            // Show generic \"Analyzing\" with progress percentage\n            // Scale progress: downloading 0-30%, transcribing 30-90%\n            const scaledProgress = status === 'downloading'\n              ? Math.round(progress * 0.3)\n              : Math.round(30 + progress * 0.6);\n            this.updateButtonState({\n              state: 'processing',\n              text: `Analyzing ${scaledProgress}%`,\n              progress: scaledProgress,\n            });\n            break;\n\n          case 'completed':\n            if (transcript) {\n              this.updateButtonState({\n                state: 'processing',\n                text: 'Analyzing 95%',\n                progress: 95,\n              });\n              await this.applyFilter(transcript);\n              return;\n            } else {\n              throw new Error('Job completed but no transcript returned');\n            }\n\n          case 'failed':\n            throw new Error(error || 'Processing failed');\n\n          default:\n            // Generic processing state\n            this.updateButtonState({\n              state: 'processing',\n              text: `Analyzing ${Math.round(progress)}%`,\n              progress,\n            });\n        }\n\n        // Wait before next poll\n        await new Promise((resolve) => setTimeout(resolve, pollInterval));\n        attempts++;\n      } catch (error) {\n        log('Poll error:', error);\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        this.updateButtonState({\n          state: 'error',\n          text: 'Error',\n          error: errorMessage,\n        });\n        this.isProcessing = false;\n        return;\n      }\n    }\n\n    // Timeout\n    this.updateButtonState({\n      state: 'error',\n      text: 'Timeout',\n      error: 'Processing took too long. Please try again.',\n    });\n    this.isProcessing = false;\n  }\n\n  // Apply the filter using the transcript\n  private async applyFilter(transcript: Transcript): Promise<void> {\n    if (!this.videoController) {\n      throw new Error('Video controller not initialized');\n    }\n\n    const videoId = this.currentVideoId;\n    if (!videoId) {\n      throw new Error('No video ID');\n    }\n\n    // Log transcript structure to verify character-level data\n    log('Transcript received for filtering:', {\n      id: transcript.id,\n      segmentCount: transcript.segments?.length,\n      sampleSegment: transcript.segments?.[0] ? {\n        text: transcript.segments[0].text,\n        times: `${transcript.segments[0].start_time}s - ${transcript.segments[0].end_time}s`,\n        hasCharacters: !!transcript.segments[0].characters,\n        charCount: transcript.segments[0].characters?.length,\n        sampleChars: transcript.segments[0].characters?.slice(0, 3),\n      } : null,\n    });\n\n    try {\n      // Initialize video controller with transcript\n      await this.videoController.initialize(videoId, this.preferences);\n      this.videoController.onTranscriptReceived(transcript);\n\n      // Apply the filter\n      await this.videoController.applyFilter();\n\n      // Get the interval count for display\n      const state = this.videoController.getState();\n      const intervalCount = state.intervalCount || 0;\n\n      // Update button to filtering state\n      this.updateButtonState({\n        state: 'filtering',\n        text: `Filtering (${intervalCount})`,\n        intervalCount,\n      });\n\n      log(`Filter applied successfully. ${intervalCount} profanity instances will be muted.`);\n\n      // Create player controls for toggling\n      this.injectPlayerControls();\n    } catch (error) {\n      log('Failed to apply filter:', error);\n      throw error;\n    } finally {\n      this.isProcessing = false;\n    }\n  }\n\n  private injectPlayerControls(): void {\n    // Check if already injected\n    if (document.querySelector('.safeplay-player-controls')) return;\n\n    // Wait for player controls to be available\n    const waitForControls = () => {\n      const rightControls = document.querySelector('.ytp-right-controls');\n      if (rightControls) {\n        this.createPlayerButton(rightControls);\n      } else {\n        setTimeout(waitForControls, 500);\n      }\n    };\n\n    waitForControls();\n  }\n\n  private createPlayerButton(container: Element): void {\n    const button = document.createElement('button');\n    button.className = 'ytp-button safeplay-player-controls safeplay-active';\n    button.title = 'SafePlay Filter Active - Click to toggle';\n    button.innerHTML = `\n      <svg viewBox=\"0 0 24 24\" fill=\"currentColor\" width=\"24\" height=\"24\">\n        <path d=\"M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm-2 16l-4-4 1.41-1.41L10 14.17l6.59-6.59L18 9l-8 8z\"/>\n      </svg>\n    `;\n\n    button.addEventListener('click', () => this.toggleFilter());\n\n    // Insert before settings button (if it's a direct child)\n    const settingsButton = container.querySelector('.ytp-settings-button');\n    if (settingsButton && settingsButton.parentElement === container) {\n      container.insertBefore(button, settingsButton);\n    } else {\n      // Just prepend to the container\n      container.insertBefore(button, container.firstChild);\n    }\n  }\n\n  private async toggleFilter(): Promise<void> {\n    if (!this.videoController) return;\n\n    const state = this.videoController.getState();\n    const playerButton = document.querySelector('.safeplay-player-controls');\n\n    if (state.status === 'active') {\n      this.videoController.stop();\n      playerButton?.classList.remove('safeplay-active');\n      playerButton?.setAttribute('title', 'SafePlay Filter Paused - Click to resume');\n      this.updateButtonState({ state: 'idle', text: 'SafePlay' });\n    } else if (this.currentVideoId) {\n      // Resume filtering\n      this.videoController.resume();\n      playerButton?.classList.add('safeplay-active');\n      playerButton?.setAttribute('title', 'SafePlay Filter Active - Click to toggle');\n\n      const intervalCount = state.intervalCount || 0;\n      this.updateButtonState({\n        state: 'filtering',\n        text: `Filtering (${intervalCount})`,\n        intervalCount,\n      });\n    }\n  }\n\n  private onVideoStateChange(state: ReturnType<VideoController['getState']>): void {\n    log('Video state changed:', state);\n\n    // Notify popup of state change\n    chrome.runtime.sendMessage({\n      type: 'VIDEO_STATE_CHANGED',\n      payload: state,\n    }).catch(() => {\n      // Popup might not be open\n    });\n  }\n\n  private setupMessageListener(): void {\n    chrome.runtime.onMessage.addListener((message, _sender, sendResponse) => {\n      this.handleMessage(message).then(sendResponse);\n      return true; // Keep channel open for async response\n    });\n  }\n\n  private async handleMessage(message: { type: string; payload?: unknown }): Promise<unknown> {\n    switch (message.type) {\n      case 'PREFERENCES_UPDATED': {\n        const newPrefs = message.payload as UserPreferences;\n        this.preferences = newPrefs;\n        this.videoController?.updatePreferences(newPrefs);\n        return { success: true };\n      }\n\n      case 'GET_VIDEO_STATE': {\n        return {\n          success: true,\n          data: this.videoController?.getState() || null,\n        };\n      }\n\n      default:\n        return { success: false, error: 'Unknown message type' };\n    }\n  }\n\n  private setupNavigationListener(): void {\n    // YouTube SPA navigation\n    document.addEventListener('yt-navigate-finish', () => {\n      log('YouTube navigation detected');\n      this.onNavigation();\n    });\n\n    // Fallback: popstate\n    window.addEventListener('popstate', () => {\n      this.onNavigation();\n    });\n  }\n\n  private onNavigation(): void {\n    // Stop current filter if any\n    if (this.videoController) {\n      this.videoController.stop();\n    }\n\n    // Reset state\n    this.currentVideoId = null;\n    this.isProcessing = false;\n\n    // Remove player button\n    const playerButton = document.querySelector('.safeplay-player-controls');\n    if (playerButton) {\n      playerButton.remove();\n    }\n\n    // Update video ID if on watch page\n    if (this.isWatchPage()) {\n      this.currentVideoId = this.getVideoIdFromUrl();\n    }\n  }\n}\n\n// Initialize when DOM is ready\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', () => {\n    const safeplay = new SafePlayContentScript();\n    safeplay.initialize();\n  });\n} else {\n  const safeplay = new SafePlayContentScript();\n  safeplay.initialize();\n}\n"],"names":["BUTTON_CONTAINER_CLASS","BUTTON_STATES","idle","bg","hoverBg","text","shadow","connecting","downloading","transcribing","processing","filtering","error","ResilientInjector","constructor","options","observer","currentVideoId","injectionAttempts","maxAttempts","retryInterval","currentState","this","start","log","attemptInjection","setupMutationObserver","setupNavigationListener","stop","disconnect","clearInterval","isWatchPage","window","location","pathname","search","includes","getVideoId","URLSearchParams","get","videoId","isButtonPresent","subscribeButton","findSubscribeButton","injectButton","setInterval","selectors","selector","element","document","querySelector","existingButton","remove","container","createElement","className","style","cssText","setAttribute","button","title","stateConfig","progressBar","iconWrapper","innerHTML","getIconSVG","textSpan","textContent","appendChild","addEventListener","config","background","boxShadow","transform","e","preventDefault","stopPropagation","onButtonClick","parentElement","insertBefore","nextSibling","state","updateButtonState","stateInfo","displayText","undefined","progress","replace","Math","round","intervalCount","width","display","cursor","setButtonState","MutationObserver","mutations","mutation","type","addedNodes","length","node","HTMLElement","id","closest","observe","body","childList","subtree","originalPushState","history","pushState","originalReplaceState","replaceState","args","apply","onNavigation","setTimeout","getCurrentVideoId","debug","console","FADE_DURATION","FADE_BUFFER","AudioFilter","video","muteIntervals","filterMode","isActive","checkIntervalId","isMuted","isFading","audioContext","sourceNode","gainNode","bleepOscillator","bleepGain","currentGainTarget","onMuteStart","onMuteEnd","initialize","intervals","mode","sort","a","b","initializeAudioContext","AudioContext","createMediaElementSource","createGain","gain","value","connect","destination","resume","checkCurrentTime","fadeToVolume","destroy","close","currentTime","activeInterval","findActiveInterval","approachingInterval","findApproachingInterval","startMute","startFadeOut","endMute","time","interval","end","startBleep","stopBleep","target","onComplete","now","cancelScheduledValues","setValueAtTime","linearRampToValueAtTime","muted","createOscillator","frequency","oscillator","updateIntervals","updateMode","getState","isFiltering","getIntervals","PROFANITY_MAP","Map","word","severity","map","item","toLowerCase","findEmbeddedProfanity","results","lowerText","index","indexOf","push","startIndex","endIndex","filtered","match","lastMatch","TranscriptParser","preferences","customBlacklistMap","customBlacklist","customWhitelistSet","Set","customWhitelist","shouldFilterSeverity","severityLevels","shouldFilterWord","lowerWord","has","getWordSeverity","getCharacterLevelTiming","segment","startTime","start_time","endTime","end_time","characters","startChar","endChar","min","substring","toFixed","findProfanityMatches","segments","matches","i","normalizedText","trim","exactSeverity","segmentIndex","isPartialMatch","embeddedMatches","customWord","embedded","matchedPortion","createMuteIntervals","paddingBeforeSeconds","paddingBeforeMs","paddingMs","paddingAfterSeconds","paddingAfterMs","max","mergeIntervals","sorted","mergeThresholdSeconds","mergeThresholdMs","merged","current","last","severityRank","mild","moderate","severe","parse","transcript","parseTranscript","VideoController","youtubeId","status","statusOverlay","audioFilter","updateStatus","findVideoElement","waitForVideo","applyFilter","enabled","response","chrome","runtime","sendMessage","payload","success","Error","data","processTranscript","message","showStatusOverlay","onTranscriptReceived","onProcessingProgress","onProcessingError","hideStatusOverlay","updatePreferences","filterState","currentlyMuting","src","timeout","Promise","resolve","Date","check","requestAnimationFrame","onStateChange","playerContainer","classList","add","notifyStateChange","DEFAULT_PREFERENCES","DEBUG","SafePlayContentScript","videoController","isProcessing","injector","onFilterButtonClick","onVideoStateChange","loadPreferences","getVideoIdFromUrl","setupMessageListener","jobId","pollJobStatus","errorMessage","attempts","scaledProgress","segmentCount","sampleSegment","times","hasCharacters","charCount","sampleChars","slice","injectPlayerControls","waitForControls","rightControls","createPlayerButton","toggleFilter","settingsButton","firstChild","playerButton","catch","onMessage","addListener","_sender","sendResponse","handleMessage","then","newPrefs","readyState"],"ignoreList":[],"sourceRoot":""}