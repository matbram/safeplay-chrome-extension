{"version":3,"file":"content.js","mappings":"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","sources":["webpack://safeplay-chrome-extension/./src/content/resilient-injector.ts","webpack://safeplay-chrome-extension/./src/filter/audio-filter.ts","webpack://safeplay-chrome-extension/./src/filter/profanity-list.ts","webpack://safeplay-chrome-extension/./src/filter/transcript-parser.ts","webpack://safeplay-chrome-extension/./src/content/video-controller.ts","webpack://safeplay-chrome-extension/./src/types/index.ts","webpack://safeplay-chrome-extension/./src/content/index.ts"],"sourcesContent":["// Resilient YouTube Button Injector for SafePlay\n// Based on pattern recognition rather than brittle class selectors\n\nexport interface InjectorOptions {\n  onButtonClick: (youtubeId: string, container: HTMLElement) => void;\n  debug?: boolean;\n}\n\ninterface DetectedContainer {\n  element: HTMLElement;\n  youtubeId: string;\n  thumbnail: HTMLElement | null;\n}\n\nconst PROCESSED_ATTR = 'data-safeplay-processed';\nconst BUTTON_CLASS = 'safeplay-filter-btn';\n\nexport class ResilientInjector {\n  private options: InjectorOptions;\n  private observer: MutationObserver | null = null;\n  private intersectionObserver: IntersectionObserver | null = null;\n  private debounceTimer: number | null = null;\n  private processedContainers = new WeakSet<HTMLElement>();\n\n  constructor(options: InjectorOptions) {\n    this.options = options;\n  }\n\n  // Start observing and injecting\n  start(): void {\n    this.log('Starting resilient injector');\n\n    // Initial injection\n    this.injectButtons();\n\n    // Set up mutation observer for dynamic content\n    this.setupMutationObserver();\n\n    // Set up intersection observer for lazy-loaded content\n    this.setupIntersectionObserver();\n\n    // Listen for YouTube SPA navigation\n    this.setupNavigationListener();\n  }\n\n  // Stop observing\n  stop(): void {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = null;\n    }\n\n    if (this.intersectionObserver) {\n      this.intersectionObserver.disconnect();\n      this.intersectionObserver = null;\n    }\n\n    this.log('Stopped resilient injector');\n  }\n\n  // Main injection function\n  injectButtons(): void {\n    const containers = this.detectVideoContainers();\n    this.log(`Found ${containers.length} video containers`);\n\n    for (const container of containers) {\n      this.injectButton(container);\n    }\n  }\n\n  // Detect video containers using multiple strategies\n  private detectVideoContainers(): DetectedContainer[] {\n    const containers: DetectedContainer[] = [];\n    const seen = new Set<HTMLElement>();\n\n    // Strategy 1: Find by video link pattern\n    const videoLinks = document.querySelectorAll<HTMLAnchorElement>(\n      'a[href*=\"/watch?v=\"], a[href*=\"/shorts/\"]'\n    );\n\n    for (const link of videoLinks) {\n      const youtubeId = this.extractYoutubeId(link.href);\n      if (!youtubeId) continue;\n\n      const container = this.findContainerFromLink(link);\n      if (container && !seen.has(container) && !this.isProcessed(container)) {\n        seen.add(container);\n        containers.push({\n          element: container,\n          youtubeId,\n          thumbnail: this.findThumbnail(container),\n        });\n      }\n    }\n\n    // Strategy 2: Find by thumbnail image pattern\n    const thumbnails = document.querySelectorAll<HTMLImageElement>(\n      'img[src*=\"ytimg.com\"], img[src*=\"i.ytimg.com\"]'\n    );\n\n    for (const img of thumbnails) {\n      const container = this.findContainerFromThumbnail(img);\n      if (!container || seen.has(container) || this.isProcessed(container)) continue;\n\n      const link = container.querySelector<HTMLAnchorElement>('a[href*=\"/watch?v=\"], a[href*=\"/shorts/\"]');\n      const youtubeId = link ? this.extractYoutubeId(link.href) : null;\n      if (!youtubeId) continue;\n\n      seen.add(container);\n      containers.push({\n        element: container,\n        youtubeId,\n        thumbnail: img.closest('[class*=\"thumbnail\"]') as HTMLElement || img.parentElement,\n      });\n    }\n\n    return containers;\n  }\n\n  // Extract YouTube video ID from URL\n  private extractYoutubeId(url: string): string | null {\n    // Handle /watch?v= format\n    const watchMatch = url.match(/[?&]v=([a-zA-Z0-9_-]{11})/);\n    if (watchMatch) return watchMatch[1];\n\n    // Handle /shorts/ format\n    const shortsMatch = url.match(/\\/shorts\\/([a-zA-Z0-9_-]{11})/);\n    if (shortsMatch) return shortsMatch[1];\n\n    return null;\n  }\n\n  // Find the container element from a video link\n  private findContainerFromLink(link: HTMLAnchorElement): HTMLElement | null {\n    // Walk up the DOM to find a suitable container\n    let element: HTMLElement | null = link;\n    let lastValidContainer: HTMLElement | null = null;\n\n    while (element && element !== document.body) {\n      // Check for common container patterns\n      if (this.looksLikeVideoContainer(element)) {\n        lastValidContainer = element;\n      }\n\n      // Stop if we've gone too far up\n      if (this.isTooHighInDOM(element)) {\n        break;\n      }\n\n      element = element.parentElement;\n    }\n\n    return lastValidContainer;\n  }\n\n  // Find container from a thumbnail image\n  private findContainerFromThumbnail(img: HTMLImageElement): HTMLElement | null {\n    let element: HTMLElement | null = img;\n    let lastValidContainer: HTMLElement | null = null;\n\n    while (element && element !== document.body) {\n      if (this.looksLikeVideoContainer(element)) {\n        lastValidContainer = element;\n      }\n\n      if (this.isTooHighInDOM(element)) {\n        break;\n      }\n\n      element = element.parentElement;\n    }\n\n    return lastValidContainer;\n  }\n\n  // Check if an element looks like a video container\n  private looksLikeVideoContainer(element: HTMLElement): boolean {\n    const rect = element.getBoundingClientRect();\n\n    // Must have reasonable dimensions\n    if (rect.width < 100 || rect.height < 80) return false;\n\n    // Check for video-related attributes/classes\n    const className = element.className.toLowerCase();\n    const tagName = element.tagName.toLowerCase();\n\n    // Common YouTube container patterns\n    const containerPatterns = [\n      'video', 'item', 'renderer', 'content', 'card', 'tile', 'entry'\n    ];\n\n    const hasContainerPattern = containerPatterns.some(\n      (pattern) => className.includes(pattern) || tagName.includes(pattern)\n    );\n\n    // Must contain both a link and an image\n    const hasLink = element.querySelector('a[href*=\"/watch\"], a[href*=\"/shorts\"]') !== null;\n    const hasImage = element.querySelector('img[src*=\"ytimg.com\"]') !== null;\n\n    return hasContainerPattern || (hasLink && hasImage);\n  }\n\n  // Check if we've gone too high in the DOM tree\n  private isTooHighInDOM(element: HTMLElement): boolean {\n    const className = element.className.toLowerCase();\n    const id = element.id.toLowerCase();\n\n    const stopPatterns = [\n      'page', 'content', 'main', 'body', 'app', 'root',\n      'feed', 'browse', 'results', 'grid', 'list'\n    ];\n\n    return stopPatterns.some(\n      (pattern) => className.includes(pattern) || id.includes(pattern)\n    );\n  }\n\n  // Find thumbnail element within container\n  private findThumbnail(container: HTMLElement): HTMLElement | null {\n    // Look for thumbnail wrapper\n    const thumbnailSelectors = [\n      '[class*=\"thumbnail\"]',\n      '[id*=\"thumbnail\"]',\n      'ytd-thumbnail',\n      '.ytd-thumbnail',\n    ];\n\n    for (const selector of thumbnailSelectors) {\n      const thumb = container.querySelector<HTMLElement>(selector);\n      if (thumb) return thumb;\n    }\n\n    // Fallback: find the element containing the img\n    const img = container.querySelector<HTMLImageElement>('img[src*=\"ytimg.com\"]');\n    return img?.parentElement || null;\n  }\n\n  // Check if container is already processed\n  private isProcessed(container: HTMLElement): boolean {\n    return (\n      this.processedContainers.has(container) ||\n      container.hasAttribute(PROCESSED_ATTR) ||\n      container.querySelector(`.${BUTTON_CLASS}`) !== null\n    );\n  }\n\n  // Inject button into a container\n  private injectButton(detected: DetectedContainer): void {\n    if (this.isProcessed(detected.element)) return;\n\n    // Mark as processed\n    detected.element.setAttribute(PROCESSED_ATTR, 'true');\n    this.processedContainers.add(detected.element);\n\n    // Create button\n    const button = this.createButton(detected.youtubeId);\n\n    // Find injection point (prefer after thumbnail)\n    const injectionPoint = detected.thumbnail || detected.element.firstElementChild;\n\n    if (injectionPoint) {\n      injectionPoint.parentElement?.insertBefore(\n        button,\n        injectionPoint.nextSibling\n      );\n    } else {\n      detected.element.appendChild(button);\n    }\n\n    this.log(`Injected button for video: ${detected.youtubeId}`);\n  }\n\n  // Create the SafePlay button element\n  private createButton(youtubeId: string): HTMLElement {\n    const button = document.createElement('button');\n    button.className = BUTTON_CLASS;\n    button.setAttribute('data-youtube-id', youtubeId);\n    button.innerHTML = `\n      <svg class=\"safeplay-icon\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n        <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z\"/>\n      </svg>\n      <span class=\"safeplay-text\">SafePlay</span>\n    `;\n\n    button.addEventListener('click', (e) => {\n      e.preventDefault();\n      e.stopPropagation();\n\n      const container = button.closest(`[${PROCESSED_ATTR}]`) as HTMLElement;\n      this.options.onButtonClick(youtubeId, container);\n    });\n\n    return button;\n  }\n\n  // Set up mutation observer for dynamic content\n  private setupMutationObserver(): void {\n    this.observer = new MutationObserver((mutations) => {\n      let shouldInject = false;\n\n      for (const mutation of mutations) {\n        if (mutation.addedNodes.length > 0) {\n          for (const node of mutation.addedNodes) {\n            if (node instanceof HTMLElement) {\n              // Check if the added node or its children might contain videos\n              if (\n                node.querySelector?.('a[href*=\"/watch\"], a[href*=\"/shorts\"]') ||\n                node.querySelector?.('img[src*=\"ytimg.com\"]')\n              ) {\n                shouldInject = true;\n                break;\n              }\n            }\n          }\n        }\n\n        if (shouldInject) break;\n      }\n\n      if (shouldInject) {\n        this.debouncedInject();\n      }\n    });\n\n    this.observer.observe(document.body, {\n      childList: true,\n      subtree: true,\n    });\n  }\n\n  // Set up intersection observer for lazy loading\n  private setupIntersectionObserver(): void {\n    this.intersectionObserver = new IntersectionObserver(\n      (entries) => {\n        const hasVisibleUnprocessed = entries.some(\n          (entry) =>\n            entry.isIntersecting &&\n            !this.isProcessed(entry.target as HTMLElement)\n        );\n\n        if (hasVisibleUnprocessed) {\n          this.debouncedInject();\n        }\n      },\n      { rootMargin: '200px' }\n    );\n\n    // Observe potential video containers\n    const containers = document.querySelectorAll<HTMLElement>(\n      'ytd-video-renderer, ytd-grid-video-renderer, ytd-compact-video-renderer, ytd-rich-item-renderer'\n    );\n\n    containers.forEach((container) => {\n      this.intersectionObserver?.observe(container);\n    });\n  }\n\n  // Listen for YouTube SPA navigation\n  private setupNavigationListener(): void {\n    // YouTube uses History API for navigation\n    const originalPushState = history.pushState;\n    const originalReplaceState = history.replaceState;\n\n    history.pushState = (...args) => {\n      originalPushState.apply(history, args);\n      this.onNavigation();\n    };\n\n    history.replaceState = (...args) => {\n      originalReplaceState.apply(history, args);\n      this.onNavigation();\n    };\n\n    window.addEventListener('popstate', () => {\n      this.onNavigation();\n    });\n\n    // Also listen for YouTube's custom navigation event\n    document.addEventListener('yt-navigate-finish', () => {\n      this.onNavigation();\n    });\n  }\n\n  private onNavigation(): void {\n    this.log('Navigation detected, re-injecting buttons');\n    // Wait for DOM to update\n    setTimeout(() => this.injectButtons(), 500);\n  }\n\n  // Debounced injection to prevent excessive processing\n  private debouncedInject(): void {\n    if (this.debounceTimer !== null) {\n      clearTimeout(this.debounceTimer);\n    }\n\n    this.debounceTimer = window.setTimeout(() => {\n      this.injectButtons();\n      this.debounceTimer = null;\n    }, 100);\n  }\n\n  // Debug logging\n  private log(...args: unknown[]): void {\n    if (this.options.debug) {\n      console.log('[SafePlay Injector]', ...args);\n    }\n  }\n}\n","import { MuteInterval, FilterMode } from '../types';\n\nexport class AudioFilter {\n  private video: HTMLVideoElement | null = null;\n  private muteIntervals: MuteInterval[] = [];\n  private filterMode: FilterMode = 'mute';\n  private isActive = false;\n  private checkIntervalId: number | null = null;\n  private isMuted = false;\n\n  // Audio context for bleep sound\n  private audioContext: AudioContext | null = null;\n  private bleepOscillator: OscillatorNode | null = null;\n  private bleepGain: GainNode | null = null;\n\n  // Callbacks\n  private onMuteStart?: (interval: MuteInterval) => void;\n  private onMuteEnd?: () => void;\n\n  constructor(options?: {\n    onMuteStart?: (interval: MuteInterval) => void;\n    onMuteEnd?: () => void;\n  }) {\n    this.onMuteStart = options?.onMuteStart;\n    this.onMuteEnd = options?.onMuteEnd;\n  }\n\n  // Initialize with video element and mute intervals\n  initialize(\n    video: HTMLVideoElement,\n    intervals: MuteInterval[],\n    mode: FilterMode = 'mute'\n  ): void {\n    this.video = video;\n    this.muteIntervals = intervals;\n    this.filterMode = mode;\n\n    // Sort intervals by start time for efficient lookup\n    this.muteIntervals.sort((a, b) => a.start - b.start);\n\n    // Initialize audio context for bleep mode\n    if (mode === 'bleep') {\n      this.initializeAudioContext();\n    }\n  }\n\n  private initializeAudioContext(): void {\n    try {\n      this.audioContext = new AudioContext();\n      this.bleepGain = this.audioContext.createGain();\n      this.bleepGain.gain.value = 0; // Start silent\n      this.bleepGain.connect(this.audioContext.destination);\n    } catch (error) {\n      console.error('[SafePlay] Failed to initialize audio context:', error);\n    }\n  }\n\n  // Start monitoring playback\n  start(): void {\n    if (this.isActive || !this.video) {\n      return;\n    }\n\n    this.isActive = true;\n\n    // Check every 10ms for precise timing\n    this.checkIntervalId = window.setInterval(() => {\n      this.checkCurrentTime();\n    }, 10);\n\n    console.log('[SafePlay] Audio filter started with', this.muteIntervals.length, 'intervals');\n  }\n\n  // Stop monitoring\n  stop(): void {\n    if (!this.isActive) {\n      return;\n    }\n\n    this.isActive = false;\n\n    if (this.checkIntervalId !== null) {\n      clearInterval(this.checkIntervalId);\n      this.checkIntervalId = null;\n    }\n\n    // Restore audio state\n    this.unmute();\n\n    // Clean up audio context\n    if (this.bleepOscillator) {\n      this.bleepOscillator.stop();\n      this.bleepOscillator = null;\n    }\n\n    if (this.audioContext) {\n      this.audioContext.close();\n      this.audioContext = null;\n    }\n\n    console.log('[SafePlay] Audio filter stopped');\n  }\n\n  // Check if current time falls within any mute interval\n  private checkCurrentTime(): void {\n    if (!this.video || !this.isActive) {\n      return;\n    }\n\n    const currentTime = this.video.currentTime;\n    const activeInterval = this.findActiveInterval(currentTime);\n\n    if (activeInterval && !this.isMuted) {\n      this.mute(activeInterval);\n    } else if (!activeInterval && this.isMuted) {\n      this.unmute();\n    }\n  }\n\n  // Binary search for active interval (optimized for sorted intervals)\n  private findActiveInterval(time: number): MuteInterval | null {\n    let low = 0;\n    let high = this.muteIntervals.length - 1;\n\n    while (low <= high) {\n      const mid = Math.floor((low + high) / 2);\n      const interval = this.muteIntervals[mid];\n\n      if (time >= interval.start && time <= interval.end) {\n        return interval;\n      } else if (time < interval.start) {\n        high = mid - 1;\n      } else {\n        low = mid + 1;\n      }\n    }\n\n    return null;\n  }\n\n  private mute(interval: MuteInterval): void {\n    if (!this.video) return;\n\n    this.isMuted = true;\n\n    if (this.filterMode === 'mute') {\n      // Simple mute - set volume to 0\n      this.video.muted = true;\n    } else if (this.filterMode === 'bleep') {\n      // Bleep mode - mute video and play bleep tone\n      this.video.muted = true;\n      this.startBleep();\n    }\n\n    if (this.onMuteStart) {\n      this.onMuteStart(interval);\n    }\n  }\n\n  private unmute(): void {\n    if (!this.video) return;\n\n    this.isMuted = false;\n    this.video.muted = false;\n\n    if (this.filterMode === 'bleep') {\n      this.stopBleep();\n    }\n\n    if (this.onMuteEnd) {\n      this.onMuteEnd();\n    }\n  }\n\n  private startBleep(): void {\n    if (!this.audioContext || !this.bleepGain) return;\n\n    // Resume audio context if suspended\n    if (this.audioContext.state === 'suspended') {\n      this.audioContext.resume();\n    }\n\n    // Create oscillator for bleep sound\n    this.bleepOscillator = this.audioContext.createOscillator();\n    this.bleepOscillator.type = 'sine';\n    this.bleepOscillator.frequency.value = 1000; // 1kHz bleep\n    this.bleepOscillator.connect(this.bleepGain);\n\n    // Fade in\n    this.bleepGain.gain.setValueAtTime(0, this.audioContext.currentTime);\n    this.bleepGain.gain.linearRampToValueAtTime(0.3, this.audioContext.currentTime + 0.01);\n\n    this.bleepOscillator.start();\n  }\n\n  private stopBleep(): void {\n    if (!this.audioContext || !this.bleepGain || !this.bleepOscillator) return;\n\n    // Fade out\n    this.bleepGain.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + 0.01);\n\n    // Stop and disconnect\n    setTimeout(() => {\n      if (this.bleepOscillator) {\n        this.bleepOscillator.stop();\n        this.bleepOscillator.disconnect();\n        this.bleepOscillator = null;\n      }\n    }, 20);\n  }\n\n  // Update intervals (e.g., when preferences change)\n  updateIntervals(intervals: MuteInterval[]): void {\n    this.muteIntervals = intervals;\n    this.muteIntervals.sort((a, b) => a.start - b.start);\n  }\n\n  // Update filter mode\n  updateMode(mode: FilterMode): void {\n    this.filterMode = mode;\n\n    // Initialize audio context if switching to bleep mode\n    if (mode === 'bleep' && !this.audioContext) {\n      this.initializeAudioContext();\n    }\n  }\n\n  // Get current state\n  getState(): {\n    isActive: boolean;\n    isMuted: boolean;\n    intervalCount: number;\n    filterMode: FilterMode;\n  } {\n    return {\n      isActive: this.isActive,\n      isMuted: this.isMuted,\n      intervalCount: this.muteIntervals.length,\n      filterMode: this.filterMode,\n    };\n  }\n\n  // Check if filtering is active\n  isFiltering(): boolean {\n    return this.isActive;\n  }\n\n  // Get all intervals (for debugging/display)\n  getIntervals(): MuteInterval[] {\n    return [...this.muteIntervals];\n  }\n}\n","import { ProfanityWord, SeverityLevel } from '../types';\n\n// Comprehensive profanity list with severity levels\n// Severity: mild (common/casual), moderate (offensive), severe (highly offensive)\n\nexport const PROFANITY_LIST: ProfanityWord[] = [\n  // Severe\n  { word: 'fuck', severity: 'severe' },\n  { word: 'fucking', severity: 'severe' },\n  { word: 'fucked', severity: 'severe' },\n  { word: 'fucker', severity: 'severe' },\n  { word: 'fuckers', severity: 'severe' },\n  { word: 'fucks', severity: 'severe' },\n  { word: 'motherfucker', severity: 'severe' },\n  { word: 'motherfucking', severity: 'severe' },\n  { word: 'motherfuckers', severity: 'severe' },\n  { word: 'cunt', severity: 'severe' },\n  { word: 'cunts', severity: 'severe' },\n  { word: 'nigger', severity: 'severe' },\n  { word: 'niggers', severity: 'severe' },\n  { word: 'nigga', severity: 'severe' },\n  { word: 'niggas', severity: 'severe' },\n  { word: 'faggot', severity: 'severe' },\n  { word: 'faggots', severity: 'severe' },\n  { word: 'fag', severity: 'severe' },\n  { word: 'fags', severity: 'severe' },\n  { word: 'retard', severity: 'severe' },\n  { word: 'retarded', severity: 'severe' },\n  { word: 'retards', severity: 'severe' },\n\n  // Moderate\n  { word: 'shit', severity: 'moderate' },\n  { word: 'shits', severity: 'moderate' },\n  { word: 'shitty', severity: 'moderate' },\n  { word: 'bullshit', severity: 'moderate' },\n  { word: 'horseshit', severity: 'moderate' },\n  { word: 'shithead', severity: 'moderate' },\n  { word: 'shitheads', severity: 'moderate' },\n  { word: 'ass', severity: 'moderate' },\n  { word: 'asses', severity: 'moderate' },\n  { word: 'asshole', severity: 'moderate' },\n  { word: 'assholes', severity: 'moderate' },\n  { word: 'bastard', severity: 'moderate' },\n  { word: 'bastards', severity: 'moderate' },\n  { word: 'bitch', severity: 'moderate' },\n  { word: 'bitches', severity: 'moderate' },\n  { word: 'bitchy', severity: 'moderate' },\n  { word: 'cock', severity: 'moderate' },\n  { word: 'cocks', severity: 'moderate' },\n  { word: 'cocksucker', severity: 'moderate' },\n  { word: 'cocksuckers', severity: 'moderate' },\n  { word: 'dick', severity: 'moderate' },\n  { word: 'dicks', severity: 'moderate' },\n  { word: 'dickhead', severity: 'moderate' },\n  { word: 'dickheads', severity: 'moderate' },\n  { word: 'pussy', severity: 'moderate' },\n  { word: 'pussies', severity: 'moderate' },\n  { word: 'prick', severity: 'moderate' },\n  { word: 'pricks', severity: 'moderate' },\n  { word: 'slut', severity: 'moderate' },\n  { word: 'sluts', severity: 'moderate' },\n  { word: 'slutty', severity: 'moderate' },\n  { word: 'whore', severity: 'moderate' },\n  { word: 'whores', severity: 'moderate' },\n  { word: 'twat', severity: 'moderate' },\n  { word: 'twats', severity: 'moderate' },\n  { word: 'wanker', severity: 'moderate' },\n  { word: 'wankers', severity: 'moderate' },\n  { word: 'bollocks', severity: 'moderate' },\n\n  // Mild\n  { word: 'damn', severity: 'mild' },\n  { word: 'damned', severity: 'mild' },\n  { word: 'dammit', severity: 'mild' },\n  { word: 'goddamn', severity: 'mild' },\n  { word: 'goddamnit', severity: 'mild' },\n  { word: 'hell', severity: 'mild' },\n  { word: 'crap', severity: 'mild' },\n  { word: 'crappy', severity: 'mild' },\n  { word: 'piss', severity: 'mild' },\n  { word: 'pissed', severity: 'mild' },\n  { word: 'pissing', severity: 'mild' },\n  { word: 'suck', severity: 'mild' },\n  { word: 'sucks', severity: 'mild' },\n  { word: 'sucked', severity: 'mild' },\n  { word: 'balls', severity: 'mild' },\n  { word: 'butt', severity: 'mild' },\n  { word: 'butthole', severity: 'mild' },\n  { word: 'screw', severity: 'mild' },\n  { word: 'screwed', severity: 'mild' },\n  { word: 'douche', severity: 'mild' },\n  { word: 'douchebag', severity: 'mild' },\n  { word: 'douchebags', severity: 'mild' },\n];\n\n// Create a Map for O(1) lookup\nexport const PROFANITY_MAP: Map<string, SeverityLevel> = new Map(\n  PROFANITY_LIST.map((item) => [item.word.toLowerCase(), item.severity])\n);\n\n// Get all words of a specific severity\nexport function getWordsBySeverity(severity: SeverityLevel): string[] {\n  return PROFANITY_LIST\n    .filter((item) => item.severity === severity)\n    .map((item) => item.word);\n}\n\n// Check if a word is profanity\nexport function isProfanity(word: string): boolean {\n  return PROFANITY_MAP.has(word.toLowerCase());\n}\n\n// Get the severity of a word\nexport function getSeverity(word: string): SeverityLevel | null {\n  return PROFANITY_MAP.get(word.toLowerCase()) || null;\n}\n\n// Find profanity within a longer word (e.g., \"fuck\" in \"motherfucker\")\nexport function findEmbeddedProfanity(\n  text: string\n): { word: string; severity: SeverityLevel; startIndex: number; endIndex: number }[] {\n  const results: {\n    word: string;\n    severity: SeverityLevel;\n    startIndex: number;\n    endIndex: number;\n  }[] = [];\n  const lowerText = text.toLowerCase();\n\n  for (const [word, severity] of PROFANITY_MAP) {\n    let index = lowerText.indexOf(word);\n    while (index !== -1) {\n      results.push({\n        word,\n        severity,\n        startIndex: index,\n        endIndex: index + word.length,\n      });\n      index = lowerText.indexOf(word, index + 1);\n    }\n  }\n\n  // Sort by start index and remove duplicates (prefer longer matches)\n  results.sort((a, b) => a.startIndex - b.startIndex);\n\n  // Remove overlapping matches, keeping the longer one\n  const filtered: typeof results = [];\n  for (const match of results) {\n    const lastMatch = filtered[filtered.length - 1];\n    if (!lastMatch || match.startIndex >= lastMatch.endIndex) {\n      filtered.push(match);\n    } else if (match.endIndex - match.startIndex > lastMatch.endIndex - lastMatch.startIndex) {\n      filtered[filtered.length - 1] = match;\n    }\n  }\n\n  return filtered;\n}\n","import {\n  TranscriptSegment,\n  Transcript,\n  MuteInterval,\n  UserPreferences,\n  SeverityLevel,\n  ProfanityMatch,\n} from '../types';\nimport {\n  PROFANITY_MAP,\n  findEmbeddedProfanity,\n} from './profanity-list';\n\nexport class TranscriptParser {\n  private preferences: UserPreferences;\n  private customBlacklistMap: Map<string, SeverityLevel>;\n  private customWhitelistSet: Set<string>;\n\n  constructor(preferences: UserPreferences) {\n    this.preferences = preferences;\n\n    // Build custom blacklist map (all custom words are severe by default)\n    this.customBlacklistMap = new Map(\n      preferences.customBlacklist.map((word) => [word.toLowerCase(), 'severe' as SeverityLevel])\n    );\n\n    // Build whitelist set\n    this.customWhitelistSet = new Set(\n      preferences.customWhitelist.map((word) => word.toLowerCase())\n    );\n  }\n\n  // Check if a severity level should be filtered based on preferences\n  private shouldFilterSeverity(severity: SeverityLevel): boolean {\n    return this.preferences.severityLevels[severity];\n  }\n\n  // Check if a word should be filtered (considering whitelist/blacklist)\n  private shouldFilterWord(word: string, severity: SeverityLevel): boolean {\n    const lowerWord = word.toLowerCase();\n\n    // Check whitelist first (user explicitly allowed)\n    if (this.customWhitelistSet.has(lowerWord)) {\n      return false;\n    }\n\n    // Check custom blacklist (always filter)\n    if (this.customBlacklistMap.has(lowerWord)) {\n      return true;\n    }\n\n    // Check severity level preference\n    return this.shouldFilterSeverity(severity);\n  }\n\n  // Get severity for a word (checking custom blacklist too)\n  private getWordSeverity(word: string): SeverityLevel | null {\n    const lowerWord = word.toLowerCase();\n\n    // Check custom blacklist first\n    if (this.customBlacklistMap.has(lowerWord)) {\n      return this.customBlacklistMap.get(lowerWord)!;\n    }\n\n    // Check built-in profanity list\n    return PROFANITY_MAP.get(lowerWord) || null;\n  }\n\n  // Find profanity matches in transcript segments\n  findProfanityMatches(segments: TranscriptSegment[]): ProfanityMatch[] {\n    const matches: ProfanityMatch[] = [];\n\n    for (let i = 0; i < segments.length; i++) {\n      const segment = segments[i];\n      const normalizedText = segment.text.toLowerCase().trim();\n\n      // Check for exact word match first\n      const exactSeverity = this.getWordSeverity(normalizedText);\n      if (exactSeverity && this.shouldFilterWord(normalizedText, exactSeverity)) {\n        matches.push({\n          segmentIndex: i,\n          word: segment.text,\n          severity: exactSeverity,\n          startTime: segment.start_time,\n          endTime: segment.end_time,\n          isPartialMatch: false,\n        });\n        continue;\n      }\n\n      // Check for embedded profanity within longer words\n      const embeddedMatches = findEmbeddedProfanity(normalizedText);\n\n      // Also check custom blacklist for embedded matches\n      for (const [customWord] of this.customBlacklistMap) {\n        const index = normalizedText.indexOf(customWord);\n        if (index !== -1) {\n          embeddedMatches.push({\n            word: customWord,\n            severity: 'severe',\n            startIndex: index,\n            endIndex: index + customWord.length,\n          });\n        }\n      }\n\n      for (const embedded of embeddedMatches) {\n        if (!this.shouldFilterWord(embedded.word, embedded.severity)) {\n          continue;\n        }\n\n        // Calculate timing using character-level data if available\n        let startTime = segment.start_time;\n        let endTime = segment.end_time;\n\n        if (segment.characters && segment.characters.length > 0) {\n          // Use character-level timing for precision\n          const startChar = segment.characters[embedded.startIndex];\n          const endChar = segment.characters[embedded.endIndex - 1];\n\n          if (startChar) {\n            startTime = startChar.start_time;\n          }\n          if (endChar) {\n            endTime = endChar.end_time;\n          }\n        }\n\n        matches.push({\n          segmentIndex: i,\n          word: embedded.word,\n          severity: embedded.severity,\n          startTime,\n          endTime,\n          isPartialMatch: true,\n          matchedPortion: segment.text.substring(embedded.startIndex, embedded.endIndex),\n        });\n      }\n    }\n\n    return matches;\n  }\n\n  // Convert profanity matches to mute intervals with padding\n  createMuteIntervals(matches: ProfanityMatch[]): MuteInterval[] {\n    const paddingSeconds = this.preferences.paddingMs / 1000;\n\n    return matches.map((match) => ({\n      start: Math.max(0, match.startTime - paddingSeconds),\n      end: match.endTime + paddingSeconds,\n      word: match.word,\n      severity: match.severity,\n    }));\n  }\n\n  // Merge overlapping or close intervals\n  mergeIntervals(intervals: MuteInterval[]): MuteInterval[] {\n    if (intervals.length === 0) {\n      return [];\n    }\n\n    // Sort by start time\n    const sorted = [...intervals].sort((a, b) => a.start - b.start);\n    const mergeThresholdSeconds = this.preferences.mergeThresholdMs / 1000;\n\n    const merged: MuteInterval[] = [sorted[0]];\n\n    for (let i = 1; i < sorted.length; i++) {\n      const current = sorted[i];\n      const last = merged[merged.length - 1];\n\n      // Merge if overlapping or within threshold\n      if (current.start <= last.end + mergeThresholdSeconds) {\n        // Extend the end time and combine words\n        last.end = Math.max(last.end, current.end);\n        // Keep the more severe classification\n        if (this.severityRank(current.severity) > this.severityRank(last.severity)) {\n          last.severity = current.severity;\n        }\n        // Append word if different\n        if (!last.word.includes(current.word)) {\n          last.word = `${last.word}, ${current.word}`;\n        }\n      } else {\n        merged.push({ ...current });\n      }\n    }\n\n    return merged;\n  }\n\n  private severityRank(severity: SeverityLevel): number {\n    const ranks: Record<SeverityLevel, number> = {\n      mild: 1,\n      moderate: 2,\n      severe: 3,\n    };\n    return ranks[severity];\n  }\n\n  // Main parsing function: transcript -> mute intervals\n  parse(transcript: Transcript): MuteInterval[] {\n    const matches = this.findProfanityMatches(transcript.segments);\n    const intervals = this.createMuteIntervals(matches);\n    return this.mergeIntervals(intervals);\n  }\n}\n\n// Utility function for quick parsing\nexport function parseTranscript(\n  transcript: Transcript,\n  preferences: UserPreferences\n): MuteInterval[] {\n  const parser = new TranscriptParser(preferences);\n  return parser.parse(transcript);\n}\n","// Controller for managing video filtering on watch pages\nimport { Transcript, MuteInterval, UserPreferences } from '../types';\nimport { AudioFilter } from '../filter/audio-filter';\nimport { parseTranscript } from '../filter/transcript-parser';\n\nexport type FilterStatus =\n  | 'idle'\n  | 'loading'\n  | 'processing'\n  | 'active'\n  | 'error'\n  | 'disabled';\n\nexport interface VideoControllerState {\n  status: FilterStatus;\n  progress: number;\n  error?: string;\n  intervalCount: number;\n  currentlyMuting: boolean;\n}\n\ninterface VideoControllerOptions {\n  onStateChange?: (state: VideoControllerState) => void;\n  debug?: boolean;\n}\n\nexport class VideoController {\n  private youtubeId: string | null = null;\n  private video: HTMLVideoElement | null = null;\n  private audioFilter: AudioFilter;\n  private transcript: Transcript | null = null;\n  private muteIntervals: MuteInterval[] = [];\n  private preferences: UserPreferences | null = null;\n  private status: FilterStatus = 'idle';\n  private progress = 0;\n  private error?: string;\n  private options: VideoControllerOptions;\n  private statusOverlay: HTMLElement | null = null;\n\n  constructor(options: VideoControllerOptions = {}) {\n    this.options = options;\n    this.audioFilter = new AudioFilter({\n      onMuteStart: (interval) => this.onMuteStart(interval),\n      onMuteEnd: () => this.onMuteEnd(),\n    });\n  }\n\n  // Initialize controller for a video\n  async initialize(\n    youtubeId: string,\n    preferences: UserPreferences\n  ): Promise<void> {\n    this.youtubeId = youtubeId;\n    this.preferences = preferences;\n    this.updateStatus('idle');\n\n    // Find video element\n    this.video = this.findVideoElement();\n    if (!this.video) {\n      this.log('Video element not found, waiting...');\n      await this.waitForVideo();\n    }\n\n    if (!this.video) {\n      this.updateStatus('error', 0, 'Could not find video element');\n      return;\n    }\n\n    this.log('Video controller initialized for:', youtubeId);\n  }\n\n  // Request and apply filter\n  async applyFilter(): Promise<void> {\n    if (!this.youtubeId || !this.video || !this.preferences) {\n      this.log('Cannot apply filter: missing required data');\n      return;\n    }\n\n    if (!this.preferences.enabled) {\n      this.updateStatus('disabled');\n      return;\n    }\n\n    try {\n      this.updateStatus('loading');\n\n      // Request transcript from background script\n      const response = await chrome.runtime.sendMessage({\n        type: 'GET_FILTER',\n        payload: { youtubeId: this.youtubeId },\n      });\n\n      if (!response.success) {\n        throw new Error(response.error || 'Failed to get transcript');\n      }\n\n      // If processing, we'll receive progress updates\n      if (response.data.status === 'processing') {\n        this.updateStatus('processing', response.data.progress || 0);\n        return; // Background will send completion message\n      }\n\n      // Parse transcript and create mute intervals\n      this.transcript = response.data.transcript;\n      await this.processTranscript();\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Unknown error';\n      this.updateStatus('error', 0, message);\n      this.log('Filter error:', error);\n    }\n  }\n\n  // Process transcript and start filtering\n  async processTranscript(): Promise<void> {\n    if (!this.transcript || !this.preferences || !this.video) {\n      return;\n    }\n\n    // Parse transcript for profanity\n    this.muteIntervals = parseTranscript(this.transcript, this.preferences);\n    this.log('Found', this.muteIntervals.length, 'mute intervals');\n\n    if (this.muteIntervals.length === 0) {\n      this.updateStatus('active');\n      this.log('No profanity detected in video');\n      return;\n    }\n\n    // Initialize and start audio filter\n    this.audioFilter.initialize(\n      this.video,\n      this.muteIntervals,\n      this.preferences.filterMode\n    );\n    this.audioFilter.start();\n\n    this.updateStatus('active');\n    this.showStatusOverlay();\n  }\n\n  // Handle transcript received from background\n  onTranscriptReceived(transcript: Transcript): void {\n    this.transcript = transcript;\n    this.processTranscript();\n  }\n\n  // Handle processing progress\n  onProcessingProgress(progress: number): void {\n    this.updateStatus('processing', progress);\n  }\n\n  // Handle processing error\n  onProcessingError(error: string): void {\n    this.updateStatus('error', 0, error);\n  }\n\n  // Stop filtering\n  stop(): void {\n    this.audioFilter.stop();\n    this.hideStatusOverlay();\n    this.updateStatus('idle');\n  }\n\n  // Update preferences\n  updatePreferences(preferences: UserPreferences): void {\n    this.preferences = preferences;\n\n    if (!preferences.enabled) {\n      this.stop();\n      return;\n    }\n\n    // Re-parse with new preferences\n    if (this.transcript) {\n      this.muteIntervals = parseTranscript(this.transcript, preferences);\n      this.audioFilter.updateIntervals(this.muteIntervals);\n      this.audioFilter.updateMode(preferences.filterMode);\n    }\n  }\n\n  // Get current state\n  getState(): VideoControllerState {\n    const filterState = this.audioFilter.getState();\n    return {\n      status: this.status,\n      progress: this.progress,\n      error: this.error,\n      intervalCount: filterState.intervalCount,\n      currentlyMuting: filterState.isMuted,\n    };\n  }\n\n  // Find the YouTube video element\n  private findVideoElement(): HTMLVideoElement | null {\n    // Main player video\n    const selectors = [\n      'video.html5-main-video',\n      'video.video-stream',\n      '#movie_player video',\n      'ytd-player video',\n      'video',\n    ];\n\n    for (const selector of selectors) {\n      const video = document.querySelector<HTMLVideoElement>(selector);\n      if (video && video.src) {\n        return video;\n      }\n    }\n\n    return null;\n  }\n\n  // Wait for video element to appear\n  private waitForVideo(timeout = 10000): Promise<HTMLVideoElement | null> {\n    return new Promise((resolve) => {\n      const startTime = Date.now();\n\n      const check = () => {\n        this.video = this.findVideoElement();\n        if (this.video) {\n          resolve(this.video);\n          return;\n        }\n\n        if (Date.now() - startTime > timeout) {\n          resolve(null);\n          return;\n        }\n\n        requestAnimationFrame(check);\n      };\n\n      check();\n    });\n  }\n\n  // Update status and notify listeners\n  private updateStatus(\n    status: FilterStatus,\n    progress = 0,\n    error?: string\n  ): void {\n    this.status = status;\n    this.progress = progress;\n    this.error = error;\n\n    if (this.options.onStateChange) {\n      this.options.onStateChange(this.getState());\n    }\n  }\n\n  // Show status overlay on video\n  private showStatusOverlay(): void {\n    if (this.statusOverlay) return;\n\n    const playerContainer = document.querySelector('#movie_player');\n    if (!playerContainer) return;\n\n    this.statusOverlay = document.createElement('div');\n    this.statusOverlay.className = 'safeplay-status-overlay';\n    this.statusOverlay.innerHTML = `\n      <div class=\"safeplay-status-badge\">\n        <svg class=\"safeplay-status-icon\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n          <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z\"/>\n        </svg>\n        <span>SafePlay Active</span>\n      </div>\n    `;\n\n    playerContainer.appendChild(this.statusOverlay);\n\n    // Auto-hide after 3 seconds\n    setTimeout(() => {\n      this.statusOverlay?.classList.add('safeplay-status-hidden');\n    }, 3000);\n  }\n\n  // Hide status overlay\n  private hideStatusOverlay(): void {\n    if (this.statusOverlay) {\n      this.statusOverlay.remove();\n      this.statusOverlay = null;\n    }\n  }\n\n  // Event handlers\n  private onMuteStart(interval: MuteInterval): void {\n    this.log('Muting:', interval.word);\n    this.notifyStateChange();\n  }\n\n  private onMuteEnd(): void {\n    this.notifyStateChange();\n  }\n\n  private notifyStateChange(): void {\n    if (this.options.onStateChange) {\n      this.options.onStateChange(this.getState());\n    }\n  }\n\n  // Debug logging\n  private log(...args: unknown[]): void {\n    if (this.options.debug) {\n      console.log('[SafePlay Controller]', ...args);\n    }\n  }\n}\n","// API Response Types\n\nexport interface CharacterTiming {\n  character: string;\n  start_time: number;\n  end_time: number;\n}\n\nexport interface TranscriptSegment {\n  text: string;\n  start_time: number;\n  end_time: number;\n  characters: CharacterTiming[];\n}\n\nexport interface Transcript {\n  youtube_id: string;\n  segments: TranscriptSegment[];\n  duration: number;\n  language: string;\n  created_at: string;\n}\n\nexport interface FilterResponse {\n  status: 'cached' | 'processing';\n  transcript?: Transcript;\n  job_id?: string;\n  message?: string;\n}\n\nexport interface JobStatusResponse {\n  status: 'pending' | 'processing' | 'completed' | 'failed';\n  progress: number;\n  transcript?: Transcript;\n  error?: string;\n}\n\n// Profanity Types\n\nexport type SeverityLevel = 'mild' | 'moderate' | 'severe';\n\nexport interface ProfanityWord {\n  word: string;\n  severity: SeverityLevel;\n}\n\nexport interface MuteInterval {\n  start: number;\n  end: number;\n  word: string;\n  severity: SeverityLevel;\n}\n\nexport interface ProfanityMatch {\n  segmentIndex: number;\n  word: string;\n  severity: SeverityLevel;\n  startTime: number;\n  endTime: number;\n  isPartialMatch: boolean;\n  matchedPortion?: string;\n}\n\n// User Preferences\n\nexport type FilterMode = 'mute' | 'bleep';\n\nexport interface UserPreferences {\n  enabled: boolean;\n  filterMode: FilterMode;\n  severityLevels: {\n    mild: boolean;\n    moderate: boolean;\n    severe: boolean;\n  };\n  customBlacklist: string[];\n  customWhitelist: string[];\n  paddingMs: number;\n  mergeThresholdMs: number;\n}\n\nexport const DEFAULT_PREFERENCES: UserPreferences = {\n  enabled: true,\n  filterMode: 'mute',\n  severityLevels: {\n    mild: false,\n    moderate: true,\n    severe: true,\n  },\n  customBlacklist: [],\n  customWhitelist: [],\n  paddingMs: 50,\n  mergeThresholdMs: 100,\n};\n\n// Storage Types\n\nexport interface StorageData {\n  preferences: UserPreferences;\n  authToken?: string;\n  userId?: string;\n  subscriptionTier?: 'free' | 'basic' | 'professional' | 'unlimited';\n  cachedTranscripts: Record<string, Transcript>;\n}\n\n// Message Types (between content script and background)\n\nexport type MessageType =\n  | 'GET_FILTER'\n  | 'CHECK_JOB'\n  | 'GET_PREFERENCES'\n  | 'SET_PREFERENCES'\n  | 'GET_AUTH_STATUS'\n  | 'CLEAR_CACHE';\n\nexport interface Message<T = unknown> {\n  type: MessageType;\n  payload?: T;\n}\n\nexport interface MessageResponse<T = unknown> {\n  success: boolean;\n  data?: T;\n  error?: string;\n}\n","// SafePlay Content Script - Main Entry Point\nimport { ResilientInjector } from './resilient-injector';\nimport { VideoController } from './video-controller';\nimport { UserPreferences, DEFAULT_PREFERENCES } from '../types';\nimport './styles.css';\n\nconst DEBUG = true;\n\nfunction log(...args: unknown[]): void {\n  if (DEBUG) {\n    console.log('[SafePlay]', ...args);\n  }\n}\n\nclass SafePlayContentScript {\n  private injector: ResilientInjector;\n  private videoController: VideoController | null = null;\n  private preferences: UserPreferences = DEFAULT_PREFERENCES;\n  private currentVideoId: string | null = null;\n\n  constructor() {\n    // Initialize resilient injector\n    this.injector = new ResilientInjector({\n      onButtonClick: (youtubeId, container) => this.onFilterButtonClick(youtubeId, container),\n      debug: DEBUG,\n    });\n\n    // Initialize video controller\n    this.videoController = new VideoController({\n      onStateChange: (state) => this.onVideoStateChange(state),\n      debug: DEBUG,\n    });\n  }\n\n  async initialize(): Promise<void> {\n    log('Initializing SafePlay content script');\n\n    // Load user preferences\n    await this.loadPreferences();\n\n    // Start injector for thumbnail buttons\n    this.injector.start();\n\n    // Check if we're on a watch page\n    if (this.isWatchPage()) {\n      await this.handleWatchPage();\n    }\n\n    // Listen for messages from background/popup\n    this.setupMessageListener();\n\n    // Listen for URL changes (YouTube SPA)\n    this.setupNavigationListener();\n\n    log('SafePlay initialized');\n  }\n\n  private async loadPreferences(): Promise<void> {\n    try {\n      const response = await chrome.runtime.sendMessage({\n        type: 'GET_PREFERENCES',\n      });\n\n      if (response.success && response.data) {\n        this.preferences = response.data;\n      }\n    } catch (error) {\n      log('Failed to load preferences:', error);\n    }\n  }\n\n  private isWatchPage(): boolean {\n    return window.location.pathname === '/watch';\n  }\n\n  private getVideoIdFromUrl(): string | null {\n    const params = new URLSearchParams(window.location.search);\n    return params.get('v');\n  }\n\n  private async handleWatchPage(): Promise<void> {\n    const videoId = this.getVideoIdFromUrl();\n    if (!videoId) return;\n\n    // Don't re-initialize for same video\n    if (videoId === this.currentVideoId) return;\n\n    this.currentVideoId = videoId;\n    log('Watch page detected, video ID:', videoId);\n\n    // Create player controls\n    this.injectPlayerControls();\n\n    // Auto-filter if enabled\n    if (this.preferences.enabled) {\n      await this.startFiltering(videoId);\n    }\n  }\n\n  private async startFiltering(videoId: string): Promise<void> {\n    if (!this.videoController) return;\n\n    await this.videoController.initialize(videoId, this.preferences);\n    await this.videoController.applyFilter();\n  }\n\n  private injectPlayerControls(): void {\n    // Check if already injected\n    if (document.querySelector('.safeplay-player-controls')) return;\n\n    // Wait for player controls to be available\n    const waitForControls = () => {\n      const rightControls = document.querySelector('.ytp-right-controls');\n      if (rightControls) {\n        this.createPlayerButton(rightControls);\n      } else {\n        setTimeout(waitForControls, 500);\n      }\n    };\n\n    waitForControls();\n  }\n\n  private createPlayerButton(container: Element): void {\n    const button = document.createElement('button');\n    button.className = 'ytp-button safeplay-player-controls';\n    button.title = 'SafePlay Filter';\n    button.innerHTML = `\n      <svg viewBox=\"0 0 24 24\" fill=\"currentColor\" width=\"24\" height=\"24\">\n        <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z\"/>\n      </svg>\n    `;\n\n    button.addEventListener('click', () => this.toggleFilter());\n\n    // Insert before settings button\n    const settingsButton = container.querySelector('.ytp-settings-button');\n    if (settingsButton) {\n      container.insertBefore(button, settingsButton);\n    } else {\n      container.appendChild(button);\n    }\n\n    this.updatePlayerButtonState();\n  }\n\n  private updatePlayerButtonState(): void {\n    const button = document.querySelector('.safeplay-player-controls');\n    if (!button) return;\n\n    const state = this.videoController?.getState();\n    const isActive = state?.status === 'active';\n\n    button.classList.toggle('safeplay-active', isActive);\n    button.setAttribute('title', isActive ? 'SafePlay Active' : 'SafePlay Inactive');\n  }\n\n  private async toggleFilter(): Promise<void> {\n    if (!this.videoController) return;\n\n    const state = this.videoController.getState();\n\n    if (state.status === 'active') {\n      this.videoController.stop();\n    } else if (this.currentVideoId) {\n      await this.startFiltering(this.currentVideoId);\n    }\n\n    this.updatePlayerButtonState();\n  }\n\n  private onFilterButtonClick(youtubeId: string, container: HTMLElement): void {\n    log('Filter button clicked for:', youtubeId);\n\n    // Update button to show loading state\n    const button = container.querySelector('.safeplay-filter-btn');\n    if (button) {\n      button.classList.add('safeplay-loading');\n    }\n\n    // Navigate to the video with filter enabled\n    // For now, just navigate - filtering will auto-start on watch page\n    window.location.href = `https://www.youtube.com/watch?v=${youtubeId}`;\n  }\n\n  private onVideoStateChange(state: ReturnType<VideoController['getState']>): void {\n    log('Video state changed:', state);\n    this.updatePlayerButtonState();\n\n    // Notify popup of state change\n    chrome.runtime.sendMessage({\n      type: 'VIDEO_STATE_CHANGED',\n      payload: state,\n    }).catch(() => {\n      // Popup might not be open\n    });\n  }\n\n  private setupMessageListener(): void {\n    chrome.runtime.onMessage.addListener((message, _sender, sendResponse) => {\n      this.handleMessage(message).then(sendResponse);\n      return true; // Keep channel open for async response\n    });\n  }\n\n  private async handleMessage(message: { type: string; payload?: unknown }): Promise<unknown> {\n    switch (message.type) {\n      case 'PREFERENCES_UPDATED': {\n        const newPrefs = message.payload as UserPreferences;\n        this.preferences = newPrefs;\n        this.videoController?.updatePreferences(newPrefs);\n        return { success: true };\n      }\n\n      case 'TRANSCRIPT_RECEIVED': {\n        const transcript = message.payload as { transcript: unknown };\n        this.videoController?.onTranscriptReceived(transcript.transcript as import('../types').Transcript);\n        return { success: true };\n      }\n\n      case 'PROCESSING_PROGRESS': {\n        const progress = (message.payload as { progress: number }).progress;\n        this.videoController?.onProcessingProgress(progress);\n        return { success: true };\n      }\n\n      case 'PROCESSING_ERROR': {\n        const error = (message.payload as { error: string }).error;\n        this.videoController?.onProcessingError(error);\n        return { success: true };\n      }\n\n      case 'GET_VIDEO_STATE': {\n        return {\n          success: true,\n          data: this.videoController?.getState() || null,\n        };\n      }\n\n      default:\n        return { success: false, error: 'Unknown message type' };\n    }\n  }\n\n  private setupNavigationListener(): void {\n    // YouTube SPA navigation\n    document.addEventListener('yt-navigate-finish', () => {\n      log('YouTube navigation detected');\n      this.onNavigation();\n    });\n\n    // Fallback: popstate\n    window.addEventListener('popstate', () => {\n      this.onNavigation();\n    });\n  }\n\n  private onNavigation(): void {\n    // Stop current filter if any\n    if (this.videoController) {\n      this.videoController.stop();\n    }\n\n    // Re-inject buttons\n    setTimeout(() => {\n      this.injector.injectButtons();\n    }, 500);\n\n    // Check if on watch page\n    if (this.isWatchPage()) {\n      setTimeout(() => {\n        this.handleWatchPage();\n      }, 1000);\n    } else {\n      this.currentVideoId = null;\n    }\n  }\n}\n\n// Initialize when DOM is ready\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', () => {\n    const safeplay = new SafePlayContentScript();\n    safeplay.initialize();\n  });\n} else {\n  const safeplay = new SafePlayContentScript();\n  safeplay.initialize();\n}\n"],"names":["PROCESSED_ATTR","BUTTON_CLASS","ResilientInjector","constructor","options","observer","intersectionObserver","debounceTimer","processedContainers","WeakSet","this","start","log","injectButtons","setupMutationObserver","setupIntersectionObserver","setupNavigationListener","stop","disconnect","containers","detectVideoContainers","length","container","injectButton","seen","Set","videoLinks","document","querySelectorAll","link","youtubeId","extractYoutubeId","href","findContainerFromLink","has","isProcessed","add","push","element","thumbnail","findThumbnail","thumbnails","img","findContainerFromThumbnail","querySelector","closest","parentElement","url","watchMatch","match","shortsMatch","lastValidContainer","body","looksLikeVideoContainer","isTooHighInDOM","rect","getBoundingClientRect","width","height","className","toLowerCase","tagName","hasContainerPattern","some","pattern","includes","hasLink","hasImage","id","thumbnailSelectors","selector","thumb","hasAttribute","detected","setAttribute","button","createButton","injectionPoint","firstElementChild","insertBefore","nextSibling","appendChild","createElement","innerHTML","addEventListener","e","preventDefault","stopPropagation","onButtonClick","MutationObserver","mutations","shouldInject","mutation","addedNodes","node","HTMLElement","debouncedInject","observe","childList","subtree","IntersectionObserver","entries","entry","isIntersecting","target","rootMargin","forEach","originalPushState","history","pushState","originalReplaceState","replaceState","args","apply","onNavigation","window","setTimeout","clearTimeout","debug","console","AudioFilter","video","muteIntervals","filterMode","isActive","checkIntervalId","isMuted","audioContext","bleepOscillator","bleepGain","onMuteStart","onMuteEnd","initialize","intervals","mode","sort","a","b","initializeAudioContext","AudioContext","createGain","gain","value","connect","destination","error","setInterval","checkCurrentTime","clearInterval","unmute","close","currentTime","activeInterval","findActiveInterval","mute","time","low","high","mid","Math","floor","interval","end","muted","startBleep","stopBleep","state","resume","createOscillator","type","frequency","setValueAtTime","linearRampToValueAtTime","updateIntervals","updateMode","getState","intervalCount","isFiltering","getIntervals","PROFANITY_MAP","Map","word","severity","map","item","findEmbeddedProfanity","text","results","lowerText","index","indexOf","startIndex","endIndex","filtered","lastMatch","TranscriptParser","preferences","customBlacklistMap","customBlacklist","customWhitelistSet","customWhitelist","shouldFilterSeverity","severityLevels","shouldFilterWord","lowerWord","getWordSeverity","get","findProfanityMatches","segments","matches","i","segment","normalizedText","trim","exactSeverity","segmentIndex","startTime","start_time","endTime","end_time","isPartialMatch","embeddedMatches","customWord","embedded","characters","startChar","endChar","matchedPortion","substring","createMuteIntervals","paddingSeconds","paddingMs","max","mergeIntervals","sorted","mergeThresholdSeconds","mergeThresholdMs","merged","current","last","severityRank","mild","moderate","severe","parse","transcript","parseTranscript","VideoController","status","progress","statusOverlay","audioFilter","updateStatus","findVideoElement","waitForVideo","applyFilter","enabled","response","chrome","runtime","sendMessage","payload","success","Error","data","processTranscript","message","showStatusOverlay","onTranscriptReceived","onProcessingProgress","onProcessingError","hideStatusOverlay","updatePreferences","filterState","currentlyMuting","selectors","src","timeout","Promise","resolve","Date","now","check","requestAnimationFrame","onStateChange","playerContainer","classList","remove","notifyStateChange","DEFAULT_PREFERENCES","DEBUG","SafePlayContentScript","videoController","currentVideoId","injector","onFilterButtonClick","onVideoStateChange","loadPreferences","isWatchPage","handleWatchPage","setupMessageListener","location","pathname","getVideoIdFromUrl","URLSearchParams","search","videoId","injectPlayerControls","startFiltering","waitForControls","rightControls","createPlayerButton","title","toggleFilter","settingsButton","updatePlayerButtonState","toggle","catch","onMessage","addListener","_sender","sendResponse","handleMessage","then","newPrefs","readyState"],"ignoreList":[],"sourceRoot":""}