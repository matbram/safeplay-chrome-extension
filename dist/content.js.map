{"version":3,"file":"content.js","mappings":"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","sources":["webpack://safeplay-chrome-extension/./src/content/resilient-injector.ts","webpack://safeplay-chrome-extension/./src/filter/audio-filter.ts","webpack://safeplay-chrome-extension/./src/filter/profanity-list.ts","webpack://safeplay-chrome-extension/./src/filter/transcript-parser.ts","webpack://safeplay-chrome-extension/./src/content/video-controller.ts","webpack://safeplay-chrome-extension/./src/types/index.ts","webpack://safeplay-chrome-extension/./src/content/index.ts"],"sourcesContent":["// SafePlay Video Page Button Injector\n// Injects the SafePlay button next to the Subscribe button on YouTube watch pages\n\nimport { ButtonState, ButtonStateInfo } from '../types';\n\nexport interface InjectorOptions {\n  onButtonClick: (youtubeId: string) => void;\n  debug?: boolean;\n}\n\nconst PROCESSED_ATTR = 'data-safeplay-processed';\nconst BUTTON_CONTAINER_CLASS = 'safeplay-video-page-button-container';\n\n// Button state configurations with colors and text\nconst BUTTON_STATES: Record<ButtonState, { bg: string; hoverBg: string; text: string; shadow: string }> = {\n  idle: {\n    bg: 'linear-gradient(135deg, #4CAF50 0%, #45a049 100%)',\n    hoverBg: 'linear-gradient(135deg, #45a049 0%, #3d8b40 100%)',\n    text: 'SafePlay',\n    shadow: 'rgba(76, 175, 80, 0.3)',\n  },\n  connecting: {\n    bg: 'linear-gradient(135deg, #607D8B 0%, #546E7A 100%)',\n    hoverBg: 'linear-gradient(135deg, #546E7A 0%, #455A64 100%)',\n    text: 'Connecting...',\n    shadow: 'rgba(96, 125, 139, 0.3)',\n  },\n  downloading: {\n    bg: 'linear-gradient(135deg, #7E57C2 0%, #673AB7 100%)',\n    hoverBg: 'linear-gradient(135deg, #673AB7 0%, #5E35B1 100%)',\n    text: 'Analyzing...',\n    shadow: 'rgba(126, 87, 194, 0.3)',\n  },\n  transcribing: {\n    bg: 'linear-gradient(135deg, #7E57C2 0%, #673AB7 100%)',\n    hoverBg: 'linear-gradient(135deg, #673AB7 0%, #5E35B1 100%)',\n    text: 'Analyzing...',\n    shadow: 'rgba(126, 87, 194, 0.3)',\n  },\n  processing: {\n    bg: 'linear-gradient(135deg, #7E57C2 0%, #673AB7 100%)',\n    hoverBg: 'linear-gradient(135deg, #673AB7 0%, #5E35B1 100%)',\n    text: 'Analyzing...',\n    shadow: 'rgba(126, 87, 194, 0.3)',\n  },\n  filtering: {\n    bg: 'linear-gradient(135deg, #26A69A 0%, #00897B 100%)',\n    hoverBg: 'linear-gradient(135deg, #00897B 0%, #00796B 100%)',\n    text: 'Active',\n    shadow: 'rgba(38, 166, 154, 0.3)',\n  },\n  error: {\n    bg: 'linear-gradient(135deg, #EF5350 0%, #E53935 100%)',\n    hoverBg: 'linear-gradient(135deg, #E53935 0%, #D32F2F 100%)',\n    text: 'Retry',\n    shadow: 'rgba(239, 83, 80, 0.3)',\n  },\n};\n\nexport class ResilientInjector {\n  private options: InjectorOptions;\n  private observer: MutationObserver | null = null;\n  private currentVideoId: string | null = null;\n  private injectionAttempts = 0;\n  private maxAttempts = 50;\n  private retryInterval: number | null = null;\n  private currentState: ButtonState = 'idle';\n\n  constructor(options: InjectorOptions) {\n    this.options = options;\n  }\n\n  // Start observing and injecting\n  start(): void {\n    this.log('Starting video page injector');\n\n    // Initial injection attempt\n    this.attemptInjection();\n\n    // Set up mutation observer for SPA navigation\n    this.setupMutationObserver();\n\n    // Listen for YouTube SPA navigation\n    this.setupNavigationListener();\n  }\n\n  // Stop observing\n  stop(): void {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = null;\n    }\n\n    if (this.retryInterval !== null) {\n      clearInterval(this.retryInterval);\n      this.retryInterval = null;\n    }\n\n    this.log('Stopped video page injector');\n  }\n\n  private isWatchPage(): boolean {\n    return window.location.pathname === '/watch' &&\n           window.location.search.includes('v=');\n  }\n\n  private getVideoId(): string | null {\n    const urlParams = new URLSearchParams(window.location.search);\n    return urlParams.get('v');\n  }\n\n  // Main injection function\n  private attemptInjection(): void {\n    if (!this.isWatchPage()) {\n      return;\n    }\n\n    const videoId = this.getVideoId();\n    if (!videoId) {\n      this.log('No video ID found');\n      return;\n    }\n\n    // Check if already injected for this video\n    if (this.currentVideoId === videoId && this.isButtonPresent()) {\n      this.log('Button already present for this video');\n      return;\n    }\n\n    // Try to find the subscribe button container\n    const subscribeButton = this.findSubscribeButton();\n\n    if (subscribeButton) {\n      this.injectButton(subscribeButton, videoId);\n      this.currentVideoId = videoId;\n      this.injectionAttempts = 0;\n      if (this.retryInterval !== null) {\n        clearInterval(this.retryInterval);\n        this.retryInterval = null;\n      }\n    } else {\n      this.injectionAttempts++;\n      this.log(`Subscribe button not found, attempt ${this.injectionAttempts}/${this.maxAttempts}`);\n\n      // Retry with interval\n      if (this.injectionAttempts < this.maxAttempts && this.retryInterval === null) {\n        this.retryInterval = window.setInterval(() => {\n          this.attemptInjection();\n        }, 200);\n      }\n    }\n  }\n\n  private findSubscribeButton(): HTMLElement | null {\n    const selectors = [\n      '#subscribe-button.ytd-watch-metadata',\n      'ytd-watch-metadata #subscribe-button',\n      '#owner #subscribe-button',\n      '#subscribe-button',\n    ];\n\n    for (const selector of selectors) {\n      const element = document.querySelector<HTMLElement>(selector);\n      if (element) {\n        this.log(`Found subscribe button with selector: ${selector}`);\n        return element;\n      }\n    }\n\n    return null;\n  }\n\n  private isButtonPresent(): boolean {\n    return document.querySelector(`.${BUTTON_CONTAINER_CLASS}`) !== null;\n  }\n\n  private injectButton(subscribeButton: HTMLElement, videoId: string): void {\n    // Remove any existing SafePlay button\n    const existingButton = document.querySelector(`.${BUTTON_CONTAINER_CLASS}`);\n    if (existingButton) {\n      existingButton.remove();\n    }\n\n    // Reset state for new video\n    this.currentState = 'idle';\n\n    // Create button container\n    const container = document.createElement('div');\n    container.className = `${BUTTON_CONTAINER_CLASS} style-scope ytd-watch-metadata`;\n    container.style.cssText = 'display: inline-flex; align-items: center; margin-left: 8px;';\n    container.setAttribute(PROCESSED_ATTR, 'true');\n\n    // Create the button matching YouTube's style\n    const button = document.createElement('button');\n    button.className = 'safeplay-main-button yt-spec-button-shape-next yt-spec-button-shape-next--tonal yt-spec-button-shape-next--mono yt-spec-button-shape-next--size-m yt-spec-button-shape-next--icon-leading';\n    button.title = 'Filter profanity with SafePlay';\n    button.setAttribute('aria-label', 'SafePlay Filter');\n    button.setAttribute('data-video-id', videoId);\n\n    const stateConfig = BUTTON_STATES.idle;\n    button.style.cssText = `\n      border: none;\n      background: ${stateConfig.bg};\n      color: #ffffff;\n      border-radius: 18px;\n      padding: 0 16px;\n      height: 36px;\n      font-family: \"Roboto\", \"Arial\", sans-serif;\n      font-size: 14px;\n      font-weight: 500;\n      line-height: 36px;\n      display: inline-flex;\n      align-items: center;\n      justify-content: center;\n      gap: 6px;\n      cursor: pointer;\n      transition: all 0.2s ease;\n      min-width: 120px;\n      box-shadow: 0 2px 4px ${stateConfig.shadow};\n      position: relative;\n      overflow: hidden;\n    `;\n\n    // Create progress bar (hidden initially)\n    const progressBar = document.createElement('div');\n    progressBar.className = 'safeplay-progress-bar';\n    progressBar.style.cssText = `\n      position: absolute;\n      bottom: 0;\n      left: 0;\n      height: 3px;\n      width: 0%;\n      background: rgba(255, 255, 255, 0.5);\n      transition: width 0.3s ease;\n      border-radius: 0 0 18px 18px;\n    `;\n\n    // Add icon\n    const iconWrapper = document.createElement('div');\n    iconWrapper.className = 'safeplay-icon';\n    iconWrapper.style.cssText = 'display: inline-flex; align-items: center; justify-content: center; width: 20px; height: 20px; flex-shrink: 0;';\n    iconWrapper.innerHTML = this.getIconSVG('idle');\n\n    // Add text\n    const textSpan = document.createElement('span');\n    textSpan.className = 'safeplay-text';\n    textSpan.style.cssText = 'color: currentColor; font-size: 14px; font-weight: 500; line-height: 1; white-space: nowrap;';\n    textSpan.textContent = stateConfig.text;\n\n    button.appendChild(iconWrapper);\n    button.appendChild(textSpan);\n    button.appendChild(progressBar);\n\n    // Add hover effects\n    button.addEventListener('mouseenter', () => {\n      const config = BUTTON_STATES[this.currentState];\n      button.style.background = config.hoverBg;\n      button.style.boxShadow = `0 4px 8px ${config.shadow}`;\n      button.style.transform = 'translateY(-1px)';\n    });\n\n    button.addEventListener('mouseleave', () => {\n      const config = BUTTON_STATES[this.currentState];\n      button.style.background = config.bg;\n      button.style.boxShadow = `0 2px 4px ${config.shadow}`;\n      button.style.transform = 'translateY(0)';\n    });\n\n    // Add click handler\n    button.addEventListener('click', (e) => {\n      e.preventDefault();\n      e.stopPropagation();\n\n      // Only allow click in idle or error state\n      if (this.currentState === 'idle' || this.currentState === 'error') {\n        this.options.onButtonClick(videoId);\n      }\n    });\n\n    container.appendChild(button);\n\n    // Insert after subscribe button\n    subscribeButton.parentElement?.insertBefore(container, subscribeButton.nextSibling);\n\n    this.log(`Injected SafePlay button for video: ${videoId}`);\n  }\n\n  private getIconSVG(state: ButtonState): string {\n    switch (state) {\n      case 'connecting':\n      case 'downloading':\n      case 'transcribing':\n      case 'processing':\n        // Spinning loader icon\n        return `\n          <svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" class=\"safeplay-spinner\">\n            <style>.safeplay-spinner { animation: safeplay-spin 1s linear infinite; } @keyframes safeplay-spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }</style>\n            <circle cx=\"12\" cy=\"12\" r=\"10\" stroke-opacity=\"0.25\"/>\n            <path d=\"M12 2a10 10 0 0 1 10 10\" stroke-linecap=\"round\"/>\n          </svg>\n        `;\n      case 'filtering':\n        // Active shield icon\n        return `\n          <svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n            <path d=\"M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm-2 16l-4-4 1.41-1.41L10 14.17l6.59-6.59L18 9l-8 8z\"/>\n          </svg>\n        `;\n      case 'error':\n        // Error icon\n        return `\n          <svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n            <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z\"/>\n          </svg>\n        `;\n      default:\n        // Default checkmark icon\n        return `\n          <svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n            <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z\"/>\n          </svg>\n        `;\n    }\n  }\n\n  // Update button state with detailed info\n  updateButtonState(stateInfo: ButtonStateInfo): void {\n    const container = document.querySelector(`.${BUTTON_CONTAINER_CLASS}`);\n    if (!container) return;\n\n    const button = container.querySelector<HTMLButtonElement>('.safeplay-main-button');\n    const textSpan = container.querySelector<HTMLSpanElement>('.safeplay-text');\n    const iconWrapper = container.querySelector<HTMLDivElement>('.safeplay-icon');\n    const progressBar = container.querySelector<HTMLDivElement>('.safeplay-progress-bar');\n\n    if (!button || !textSpan || !iconWrapper) return;\n\n    this.currentState = stateInfo.state;\n    const config = BUTTON_STATES[stateInfo.state];\n\n    // Update colors\n    button.style.background = config.bg;\n    button.style.boxShadow = `0 2px 4px ${config.shadow}`;\n\n    // Update icon\n    iconWrapper.innerHTML = this.getIconSVG(stateInfo.state);\n\n    // Update text\n    let displayText = stateInfo.text || config.text;\n\n    // Add progress percentage for processing states\n    if (stateInfo.progress !== undefined && stateInfo.progress > 0) {\n      if (stateInfo.state === 'downloading' || stateInfo.state === 'transcribing' || stateInfo.state === 'processing') {\n        displayText = `${config.text.replace('...', '')} ${Math.round(stateInfo.progress)}%`;\n      }\n    }\n\n    // Add interval count for filtering state\n    if (stateInfo.state === 'filtering' && stateInfo.intervalCount !== undefined) {\n      displayText = `Filtering (${stateInfo.intervalCount})`;\n    }\n\n    textSpan.textContent = displayText;\n\n    // Update progress bar\n    if (progressBar) {\n      if (stateInfo.progress !== undefined && stateInfo.progress > 0 && stateInfo.progress < 100) {\n        progressBar.style.width = `${stateInfo.progress}%`;\n        progressBar.style.display = 'block';\n      } else {\n        progressBar.style.width = '0%';\n        progressBar.style.display = 'none';\n      }\n    }\n\n    // Update cursor\n    if (stateInfo.state === 'idle' || stateInfo.state === 'error') {\n      button.style.cursor = 'pointer';\n    } else {\n      button.style.cursor = 'default';\n    }\n\n    // Update title/tooltip\n    switch (stateInfo.state) {\n      case 'connecting':\n        button.title = 'Connecting to SafePlay service...';\n        break;\n      case 'downloading':\n        button.title = `Downloading video audio${stateInfo.progress ? ` (${Math.round(stateInfo.progress)}%)` : '...'}`;\n        break;\n      case 'transcribing':\n        button.title = `Transcribing audio${stateInfo.progress ? ` (${Math.round(stateInfo.progress)}%)` : '...'}`;\n        break;\n      case 'processing':\n        button.title = 'Processing transcript...';\n        break;\n      case 'filtering':\n        button.title = `Filtering profanity${stateInfo.intervalCount ? ` - ${stateInfo.intervalCount} instances found` : ''}`;\n        break;\n      case 'error':\n        button.title = stateInfo.error || 'An error occurred. Click to retry.';\n        break;\n      default:\n        button.title = 'Click to filter profanity with SafePlay';\n    }\n\n    this.log(`Button state updated to: ${stateInfo.state}`, stateInfo);\n  }\n\n  // Convenience method for simple state updates\n  setButtonState(state: ButtonState, text?: string, progress?: number): void {\n    this.updateButtonState({ state, text: text || '', progress });\n  }\n\n  // Set up mutation observer for dynamic content changes\n  private setupMutationObserver(): void {\n    this.observer = new MutationObserver((mutations) => {\n      for (const mutation of mutations) {\n        if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {\n          for (const node of mutation.addedNodes) {\n            if (node instanceof HTMLElement) {\n              if (node.id === 'subscribe-button' ||\n                  node.querySelector?.('#subscribe-button') ||\n                  node.closest?.('ytd-watch-metadata')) {\n                this.log('Subscribe button area changed, re-injecting');\n                this.attemptInjection();\n                return;\n              }\n            }\n          }\n        }\n      }\n    });\n\n    this.observer.observe(document.body, {\n      childList: true,\n      subtree: true,\n    });\n  }\n\n  // Listen for YouTube SPA navigation\n  private setupNavigationListener(): void {\n    const originalPushState = history.pushState;\n    const originalReplaceState = history.replaceState;\n\n    history.pushState = (...args) => {\n      originalPushState.apply(history, args);\n      this.onNavigation();\n    };\n\n    history.replaceState = (...args) => {\n      originalReplaceState.apply(history, args);\n      this.onNavigation();\n    };\n\n    window.addEventListener('popstate', () => {\n      this.onNavigation();\n    });\n\n    document.addEventListener('yt-navigate-finish', () => {\n      this.onNavigation();\n    });\n\n    document.addEventListener('yt-page-data-updated', () => {\n      this.log('Page data updated');\n      this.onNavigation();\n    });\n  }\n\n  private onNavigation(): void {\n    this.log('Navigation detected');\n    this.currentVideoId = null;\n    this.currentState = 'idle';\n    this.injectionAttempts = 0;\n\n    if (this.retryInterval !== null) {\n      clearInterval(this.retryInterval);\n      this.retryInterval = null;\n    }\n\n    setTimeout(() => {\n      this.attemptInjection();\n    }, 300);\n  }\n\n  // Get current video ID\n  getCurrentVideoId(): string | null {\n    return this.currentVideoId;\n  }\n\n  // Debug logging\n  private log(...args: unknown[]): void {\n    if (this.options.debug) {\n      console.log('[SafePlay Injector]', ...args);\n    }\n  }\n}\n","import { MuteInterval, FilterMode } from '../types';\n\nexport class AudioFilter {\n  private video: HTMLVideoElement | null = null;\n  private muteIntervals: MuteInterval[] = [];\n  private filterMode: FilterMode = 'mute';\n  private isActive = false;\n  private checkIntervalId: number | null = null;\n  private isMuted = false;\n\n  // Audio context for bleep sound\n  private audioContext: AudioContext | null = null;\n  private bleepOscillator: OscillatorNode | null = null;\n  private bleepGain: GainNode | null = null;\n\n  // Callbacks\n  private onMuteStart?: (interval: MuteInterval) => void;\n  private onMuteEnd?: () => void;\n\n  constructor(options?: {\n    onMuteStart?: (interval: MuteInterval) => void;\n    onMuteEnd?: () => void;\n  }) {\n    this.onMuteStart = options?.onMuteStart;\n    this.onMuteEnd = options?.onMuteEnd;\n  }\n\n  // Initialize with video element and mute intervals\n  initialize(\n    video: HTMLVideoElement,\n    intervals: MuteInterval[],\n    mode: FilterMode = 'mute'\n  ): void {\n    this.video = video;\n    this.muteIntervals = intervals;\n    this.filterMode = mode;\n\n    // Sort intervals by start time for efficient lookup\n    this.muteIntervals.sort((a, b) => a.start - b.start);\n\n    // Initialize audio context for bleep mode\n    if (mode === 'bleep') {\n      this.initializeAudioContext();\n    }\n  }\n\n  private initializeAudioContext(): void {\n    try {\n      this.audioContext = new AudioContext();\n      this.bleepGain = this.audioContext.createGain();\n      this.bleepGain.gain.value = 0; // Start silent\n      this.bleepGain.connect(this.audioContext.destination);\n    } catch (error) {\n      console.error('[SafePlay] Failed to initialize audio context:', error);\n    }\n  }\n\n  // Start monitoring playback\n  start(): void {\n    if (this.isActive || !this.video) {\n      return;\n    }\n\n    this.isActive = true;\n\n    // Check every 10ms for precise timing\n    this.checkIntervalId = window.setInterval(() => {\n      this.checkCurrentTime();\n    }, 10);\n\n    console.log('[SafePlay] Audio filter started with', this.muteIntervals.length, 'intervals');\n  }\n\n  // Stop monitoring\n  stop(): void {\n    if (!this.isActive) {\n      return;\n    }\n\n    this.isActive = false;\n\n    if (this.checkIntervalId !== null) {\n      clearInterval(this.checkIntervalId);\n      this.checkIntervalId = null;\n    }\n\n    // Restore audio state\n    this.unmute();\n\n    // Clean up audio context\n    if (this.bleepOscillator) {\n      this.bleepOscillator.stop();\n      this.bleepOscillator = null;\n    }\n\n    if (this.audioContext) {\n      this.audioContext.close();\n      this.audioContext = null;\n    }\n\n    console.log('[SafePlay] Audio filter stopped');\n  }\n\n  // Check if current time falls within any mute interval\n  private checkCurrentTime(): void {\n    if (!this.video || !this.isActive) {\n      return;\n    }\n\n    const currentTime = this.video.currentTime;\n    const activeInterval = this.findActiveInterval(currentTime);\n\n    if (activeInterval && !this.isMuted) {\n      this.mute(activeInterval);\n    } else if (!activeInterval && this.isMuted) {\n      this.unmute();\n    }\n  }\n\n  // Binary search for active interval (optimized for sorted intervals)\n  private findActiveInterval(time: number): MuteInterval | null {\n    let low = 0;\n    let high = this.muteIntervals.length - 1;\n\n    while (low <= high) {\n      const mid = Math.floor((low + high) / 2);\n      const interval = this.muteIntervals[mid];\n\n      if (time >= interval.start && time <= interval.end) {\n        return interval;\n      } else if (time < interval.start) {\n        high = mid - 1;\n      } else {\n        low = mid + 1;\n      }\n    }\n\n    return null;\n  }\n\n  private mute(interval: MuteInterval): void {\n    if (!this.video) return;\n\n    this.isMuted = true;\n\n    if (this.filterMode === 'mute') {\n      // Simple mute - set volume to 0\n      this.video.muted = true;\n    } else if (this.filterMode === 'bleep') {\n      // Bleep mode - mute video and play bleep tone\n      this.video.muted = true;\n      this.startBleep();\n    }\n\n    if (this.onMuteStart) {\n      this.onMuteStart(interval);\n    }\n  }\n\n  private unmute(): void {\n    if (!this.video) return;\n\n    this.isMuted = false;\n    this.video.muted = false;\n\n    if (this.filterMode === 'bleep') {\n      this.stopBleep();\n    }\n\n    if (this.onMuteEnd) {\n      this.onMuteEnd();\n    }\n  }\n\n  private startBleep(): void {\n    if (!this.audioContext || !this.bleepGain) return;\n\n    // Resume audio context if suspended\n    if (this.audioContext.state === 'suspended') {\n      this.audioContext.resume();\n    }\n\n    // Create oscillator for bleep sound\n    this.bleepOscillator = this.audioContext.createOscillator();\n    this.bleepOscillator.type = 'sine';\n    this.bleepOscillator.frequency.value = 1000; // 1kHz bleep\n    this.bleepOscillator.connect(this.bleepGain);\n\n    // Fade in\n    this.bleepGain.gain.setValueAtTime(0, this.audioContext.currentTime);\n    this.bleepGain.gain.linearRampToValueAtTime(0.3, this.audioContext.currentTime + 0.01);\n\n    this.bleepOscillator.start();\n  }\n\n  private stopBleep(): void {\n    if (!this.audioContext || !this.bleepGain || !this.bleepOscillator) return;\n\n    // Fade out\n    this.bleepGain.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + 0.01);\n\n    // Stop and disconnect\n    setTimeout(() => {\n      if (this.bleepOscillator) {\n        this.bleepOscillator.stop();\n        this.bleepOscillator.disconnect();\n        this.bleepOscillator = null;\n      }\n    }, 20);\n  }\n\n  // Update intervals (e.g., when preferences change)\n  updateIntervals(intervals: MuteInterval[]): void {\n    this.muteIntervals = intervals;\n    this.muteIntervals.sort((a, b) => a.start - b.start);\n  }\n\n  // Update filter mode\n  updateMode(mode: FilterMode): void {\n    this.filterMode = mode;\n\n    // Initialize audio context if switching to bleep mode\n    if (mode === 'bleep' && !this.audioContext) {\n      this.initializeAudioContext();\n    }\n  }\n\n  // Get current state\n  getState(): {\n    isActive: boolean;\n    isMuted: boolean;\n    intervalCount: number;\n    filterMode: FilterMode;\n  } {\n    return {\n      isActive: this.isActive,\n      isMuted: this.isMuted,\n      intervalCount: this.muteIntervals.length,\n      filterMode: this.filterMode,\n    };\n  }\n\n  // Check if filtering is active\n  isFiltering(): boolean {\n    return this.isActive;\n  }\n\n  // Get all intervals (for debugging/display)\n  getIntervals(): MuteInterval[] {\n    return [...this.muteIntervals];\n  }\n}\n","import { ProfanityWord, SeverityLevel } from '../types';\n\n// Comprehensive profanity list with severity levels\n// Severity: mild (common/casual), moderate (offensive), severe (highly offensive)\n\nexport const PROFANITY_LIST: ProfanityWord[] = [\n  // Severe\n  { word: 'fuck', severity: 'severe' },\n  { word: 'fucking', severity: 'severe' },\n  { word: 'fucked', severity: 'severe' },\n  { word: 'fucker', severity: 'severe' },\n  { word: 'fuckers', severity: 'severe' },\n  { word: 'fucks', severity: 'severe' },\n  { word: 'motherfucker', severity: 'severe' },\n  { word: 'motherfucking', severity: 'severe' },\n  { word: 'motherfuckers', severity: 'severe' },\n  { word: 'cunt', severity: 'severe' },\n  { word: 'cunts', severity: 'severe' },\n  { word: 'nigger', severity: 'severe' },\n  { word: 'niggers', severity: 'severe' },\n  { word: 'nigga', severity: 'severe' },\n  { word: 'niggas', severity: 'severe' },\n  { word: 'faggot', severity: 'severe' },\n  { word: 'faggots', severity: 'severe' },\n  { word: 'fag', severity: 'severe' },\n  { word: 'fags', severity: 'severe' },\n  { word: 'retard', severity: 'severe' },\n  { word: 'retarded', severity: 'severe' },\n  { word: 'retards', severity: 'severe' },\n\n  // Moderate\n  { word: 'shit', severity: 'moderate' },\n  { word: 'shits', severity: 'moderate' },\n  { word: 'shitty', severity: 'moderate' },\n  { word: 'bullshit', severity: 'moderate' },\n  { word: 'horseshit', severity: 'moderate' },\n  { word: 'shithead', severity: 'moderate' },\n  { word: 'shitheads', severity: 'moderate' },\n  { word: 'ass', severity: 'moderate' },\n  { word: 'asses', severity: 'moderate' },\n  { word: 'asshole', severity: 'moderate' },\n  { word: 'assholes', severity: 'moderate' },\n  { word: 'bastard', severity: 'moderate' },\n  { word: 'bastards', severity: 'moderate' },\n  { word: 'bitch', severity: 'moderate' },\n  { word: 'bitches', severity: 'moderate' },\n  { word: 'bitchy', severity: 'moderate' },\n  { word: 'cock', severity: 'moderate' },\n  { word: 'cocks', severity: 'moderate' },\n  { word: 'cocksucker', severity: 'moderate' },\n  { word: 'cocksuckers', severity: 'moderate' },\n  { word: 'dick', severity: 'moderate' },\n  { word: 'dicks', severity: 'moderate' },\n  { word: 'dickhead', severity: 'moderate' },\n  { word: 'dickheads', severity: 'moderate' },\n  { word: 'pussy', severity: 'moderate' },\n  { word: 'pussies', severity: 'moderate' },\n  { word: 'prick', severity: 'moderate' },\n  { word: 'pricks', severity: 'moderate' },\n  { word: 'slut', severity: 'moderate' },\n  { word: 'sluts', severity: 'moderate' },\n  { word: 'slutty', severity: 'moderate' },\n  { word: 'whore', severity: 'moderate' },\n  { word: 'whores', severity: 'moderate' },\n  { word: 'twat', severity: 'moderate' },\n  { word: 'twats', severity: 'moderate' },\n  { word: 'wanker', severity: 'moderate' },\n  { word: 'wankers', severity: 'moderate' },\n  { word: 'bollocks', severity: 'moderate' },\n\n  // Mild\n  { word: 'damn', severity: 'mild' },\n  { word: 'damned', severity: 'mild' },\n  { word: 'dammit', severity: 'mild' },\n  { word: 'goddamn', severity: 'mild' },\n  { word: 'goddamnit', severity: 'mild' },\n  { word: 'hell', severity: 'mild' },\n  { word: 'crap', severity: 'mild' },\n  { word: 'crappy', severity: 'mild' },\n  { word: 'piss', severity: 'mild' },\n  { word: 'pissed', severity: 'mild' },\n  { word: 'pissing', severity: 'mild' },\n  { word: 'suck', severity: 'mild' },\n  { word: 'sucks', severity: 'mild' },\n  { word: 'sucked', severity: 'mild' },\n  { word: 'balls', severity: 'mild' },\n  { word: 'butt', severity: 'mild' },\n  { word: 'butthole', severity: 'mild' },\n  { word: 'screw', severity: 'mild' },\n  { word: 'screwed', severity: 'mild' },\n  { word: 'douche', severity: 'mild' },\n  { word: 'douchebag', severity: 'mild' },\n  { word: 'douchebags', severity: 'mild' },\n];\n\n// Create a Map for O(1) lookup\nexport const PROFANITY_MAP: Map<string, SeverityLevel> = new Map(\n  PROFANITY_LIST.map((item) => [item.word.toLowerCase(), item.severity])\n);\n\n// Get all words of a specific severity\nexport function getWordsBySeverity(severity: SeverityLevel): string[] {\n  return PROFANITY_LIST\n    .filter((item) => item.severity === severity)\n    .map((item) => item.word);\n}\n\n// Check if a word is profanity\nexport function isProfanity(word: string): boolean {\n  return PROFANITY_MAP.has(word.toLowerCase());\n}\n\n// Get the severity of a word\nexport function getSeverity(word: string): SeverityLevel | null {\n  return PROFANITY_MAP.get(word.toLowerCase()) || null;\n}\n\n// Find profanity within a longer word (e.g., \"fuck\" in \"motherfucker\")\nexport function findEmbeddedProfanity(\n  text: string\n): { word: string; severity: SeverityLevel; startIndex: number; endIndex: number }[] {\n  const results: {\n    word: string;\n    severity: SeverityLevel;\n    startIndex: number;\n    endIndex: number;\n  }[] = [];\n  const lowerText = text.toLowerCase();\n\n  for (const [word, severity] of PROFANITY_MAP) {\n    let index = lowerText.indexOf(word);\n    while (index !== -1) {\n      results.push({\n        word,\n        severity,\n        startIndex: index,\n        endIndex: index + word.length,\n      });\n      index = lowerText.indexOf(word, index + 1);\n    }\n  }\n\n  // Sort by start index and remove duplicates (prefer longer matches)\n  results.sort((a, b) => a.startIndex - b.startIndex);\n\n  // Remove overlapping matches, keeping the longer one\n  const filtered: typeof results = [];\n  for (const match of results) {\n    const lastMatch = filtered[filtered.length - 1];\n    if (!lastMatch || match.startIndex >= lastMatch.endIndex) {\n      filtered.push(match);\n    } else if (match.endIndex - match.startIndex > lastMatch.endIndex - lastMatch.startIndex) {\n      filtered[filtered.length - 1] = match;\n    }\n  }\n\n  return filtered;\n}\n","import {\n  TranscriptSegment,\n  Transcript,\n  MuteInterval,\n  UserPreferences,\n  SeverityLevel,\n  ProfanityMatch,\n} from '../types';\nimport {\n  PROFANITY_MAP,\n  findEmbeddedProfanity,\n} from './profanity-list';\n\nexport class TranscriptParser {\n  private preferences: UserPreferences;\n  private customBlacklistMap: Map<string, SeverityLevel>;\n  private customWhitelistSet: Set<string>;\n\n  constructor(preferences: UserPreferences) {\n    this.preferences = preferences;\n\n    // Build custom blacklist map (all custom words are severe by default)\n    this.customBlacklistMap = new Map(\n      preferences.customBlacklist.map((word) => [word.toLowerCase(), 'severe' as SeverityLevel])\n    );\n\n    // Build whitelist set\n    this.customWhitelistSet = new Set(\n      preferences.customWhitelist.map((word) => word.toLowerCase())\n    );\n  }\n\n  // Check if a severity level should be filtered based on preferences\n  private shouldFilterSeverity(severity: SeverityLevel): boolean {\n    return this.preferences.severityLevels[severity];\n  }\n\n  // Check if a word should be filtered (considering whitelist/blacklist)\n  private shouldFilterWord(word: string, severity: SeverityLevel): boolean {\n    const lowerWord = word.toLowerCase();\n\n    // Check whitelist first (user explicitly allowed)\n    if (this.customWhitelistSet.has(lowerWord)) {\n      return false;\n    }\n\n    // Check custom blacklist (always filter)\n    if (this.customBlacklistMap.has(lowerWord)) {\n      return true;\n    }\n\n    // Check severity level preference\n    return this.shouldFilterSeverity(severity);\n  }\n\n  // Get severity for a word (checking custom blacklist too)\n  private getWordSeverity(word: string): SeverityLevel | null {\n    const lowerWord = word.toLowerCase();\n\n    // Check custom blacklist first\n    if (this.customBlacklistMap.has(lowerWord)) {\n      return this.customBlacklistMap.get(lowerWord)!;\n    }\n\n    // Check built-in profanity list\n    return PROFANITY_MAP.get(lowerWord) || null;\n  }\n\n  // Find profanity matches in transcript segments\n  findProfanityMatches(segments: TranscriptSegment[]): ProfanityMatch[] {\n    const matches: ProfanityMatch[] = [];\n\n    for (let i = 0; i < segments.length; i++) {\n      const segment = segments[i];\n      const normalizedText = segment.text.toLowerCase().trim();\n\n      // Check for exact word match first\n      const exactSeverity = this.getWordSeverity(normalizedText);\n      if (exactSeverity && this.shouldFilterWord(normalizedText, exactSeverity)) {\n        matches.push({\n          segmentIndex: i,\n          word: segment.text,\n          severity: exactSeverity,\n          startTime: segment.start_time,\n          endTime: segment.end_time,\n          isPartialMatch: false,\n        });\n        continue;\n      }\n\n      // Check for embedded profanity within longer words\n      const embeddedMatches = findEmbeddedProfanity(normalizedText);\n\n      // Also check custom blacklist for embedded matches\n      for (const [customWord] of this.customBlacklistMap) {\n        const index = normalizedText.indexOf(customWord);\n        if (index !== -1) {\n          embeddedMatches.push({\n            word: customWord,\n            severity: 'severe',\n            startIndex: index,\n            endIndex: index + customWord.length,\n          });\n        }\n      }\n\n      for (const embedded of embeddedMatches) {\n        if (!this.shouldFilterWord(embedded.word, embedded.severity)) {\n          continue;\n        }\n\n        // Calculate timing using character-level data if available\n        let startTime = segment.start_time;\n        let endTime = segment.end_time;\n\n        if (segment.characters && segment.characters.length > 0) {\n          // Use character-level timing for precision\n          const startChar = segment.characters[embedded.startIndex];\n          const endChar = segment.characters[embedded.endIndex - 1];\n\n          if (startChar) {\n            startTime = startChar.start;\n          }\n          if (endChar) {\n            endTime = endChar.end;\n          }\n        }\n\n        matches.push({\n          segmentIndex: i,\n          word: embedded.word,\n          severity: embedded.severity,\n          startTime,\n          endTime,\n          isPartialMatch: true,\n          matchedPortion: segment.text.substring(embedded.startIndex, embedded.endIndex),\n        });\n      }\n    }\n\n    return matches;\n  }\n\n  // Convert profanity matches to mute intervals with padding\n  createMuteIntervals(matches: ProfanityMatch[]): MuteInterval[] {\n    const paddingSeconds = this.preferences.paddingMs / 1000;\n\n    return matches.map((match) => ({\n      start: Math.max(0, match.startTime - paddingSeconds),\n      end: match.endTime + paddingSeconds,\n      word: match.word,\n      severity: match.severity,\n    }));\n  }\n\n  // Merge overlapping or close intervals\n  mergeIntervals(intervals: MuteInterval[]): MuteInterval[] {\n    if (intervals.length === 0) {\n      return [];\n    }\n\n    // Sort by start time\n    const sorted = [...intervals].sort((a, b) => a.start - b.start);\n    const mergeThresholdSeconds = this.preferences.mergeThresholdMs / 1000;\n\n    const merged: MuteInterval[] = [sorted[0]];\n\n    for (let i = 1; i < sorted.length; i++) {\n      const current = sorted[i];\n      const last = merged[merged.length - 1];\n\n      // Merge if overlapping or within threshold\n      if (current.start <= last.end + mergeThresholdSeconds) {\n        // Extend the end time and combine words\n        last.end = Math.max(last.end, current.end);\n        // Keep the more severe classification\n        if (this.severityRank(current.severity) > this.severityRank(last.severity)) {\n          last.severity = current.severity;\n        }\n        // Append word if different\n        if (!last.word.includes(current.word)) {\n          last.word = `${last.word}, ${current.word}`;\n        }\n      } else {\n        merged.push({ ...current });\n      }\n    }\n\n    return merged;\n  }\n\n  private severityRank(severity: SeverityLevel): number {\n    const ranks: Record<SeverityLevel, number> = {\n      mild: 1,\n      moderate: 2,\n      severe: 3,\n    };\n    return ranks[severity];\n  }\n\n  // Main parsing function: transcript -> mute intervals\n  parse(transcript: Transcript): MuteInterval[] {\n    const matches = this.findProfanityMatches(transcript.segments);\n    const intervals = this.createMuteIntervals(matches);\n    return this.mergeIntervals(intervals);\n  }\n}\n\n// Utility function for quick parsing\nexport function parseTranscript(\n  transcript: Transcript,\n  preferences: UserPreferences\n): MuteInterval[] {\n  const parser = new TranscriptParser(preferences);\n  return parser.parse(transcript);\n}\n","// Controller for managing video filtering on watch pages\nimport { Transcript, MuteInterval, UserPreferences } from '../types';\nimport { AudioFilter } from '../filter/audio-filter';\nimport { parseTranscript } from '../filter/transcript-parser';\n\nexport type FilterStatus =\n  | 'idle'\n  | 'loading'\n  | 'processing'\n  | 'active'\n  | 'error'\n  | 'disabled';\n\nexport interface VideoControllerState {\n  status: FilterStatus;\n  progress: number;\n  error?: string;\n  intervalCount: number;\n  currentlyMuting: boolean;\n}\n\ninterface VideoControllerOptions {\n  onStateChange?: (state: VideoControllerState) => void;\n  debug?: boolean;\n}\n\nexport class VideoController {\n  private youtubeId: string | null = null;\n  private video: HTMLVideoElement | null = null;\n  private audioFilter: AudioFilter;\n  private transcript: Transcript | null = null;\n  private muteIntervals: MuteInterval[] = [];\n  private preferences: UserPreferences | null = null;\n  private status: FilterStatus = 'idle';\n  private progress = 0;\n  private error?: string;\n  private options: VideoControllerOptions;\n  private statusOverlay: HTMLElement | null = null;\n\n  constructor(options: VideoControllerOptions = {}) {\n    this.options = options;\n    this.audioFilter = new AudioFilter({\n      onMuteStart: (interval) => this.onMuteStart(interval),\n      onMuteEnd: () => this.onMuteEnd(),\n    });\n  }\n\n  // Initialize controller for a video\n  async initialize(\n    youtubeId: string,\n    preferences: UserPreferences\n  ): Promise<void> {\n    this.youtubeId = youtubeId;\n    this.preferences = preferences;\n    this.updateStatus('idle');\n\n    // Find video element\n    this.video = this.findVideoElement();\n    if (!this.video) {\n      this.log('Video element not found, waiting...');\n      await this.waitForVideo();\n    }\n\n    if (!this.video) {\n      this.updateStatus('error', 0, 'Could not find video element');\n      return;\n    }\n\n    this.log('Video controller initialized for:', youtubeId);\n  }\n\n  // Request and apply filter\n  async applyFilter(): Promise<void> {\n    if (!this.youtubeId || !this.video || !this.preferences) {\n      this.log('Cannot apply filter: missing required data');\n      return;\n    }\n\n    if (!this.preferences.enabled) {\n      this.updateStatus('disabled');\n      return;\n    }\n\n    try {\n      this.updateStatus('loading');\n\n      // Request transcript from background script\n      const response = await chrome.runtime.sendMessage({\n        type: 'GET_FILTER',\n        payload: { youtubeId: this.youtubeId },\n      });\n\n      if (!response.success) {\n        throw new Error(response.error || 'Failed to get transcript');\n      }\n\n      // If processing, we'll receive progress updates\n      if (response.data.status === 'processing') {\n        this.updateStatus('processing', response.data.progress || 0);\n        return; // Background will send completion message\n      }\n\n      // Parse transcript and create mute intervals\n      this.transcript = response.data.transcript;\n      await this.processTranscript();\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Unknown error';\n      this.updateStatus('error', 0, message);\n      this.log('Filter error:', error);\n    }\n  }\n\n  // Process transcript and start filtering\n  async processTranscript(): Promise<void> {\n    if (!this.transcript || !this.preferences || !this.video) {\n      return;\n    }\n\n    // Parse transcript for profanity\n    this.muteIntervals = parseTranscript(this.transcript, this.preferences);\n    this.log('Found', this.muteIntervals.length, 'mute intervals');\n\n    if (this.muteIntervals.length === 0) {\n      this.updateStatus('active');\n      this.log('No profanity detected in video');\n      return;\n    }\n\n    // Initialize and start audio filter\n    this.audioFilter.initialize(\n      this.video,\n      this.muteIntervals,\n      this.preferences.filterMode\n    );\n    this.audioFilter.start();\n\n    this.updateStatus('active');\n    this.showStatusOverlay();\n  }\n\n  // Handle transcript received from background\n  onTranscriptReceived(transcript: Transcript): void {\n    this.transcript = transcript;\n    this.processTranscript();\n  }\n\n  // Handle processing progress\n  onProcessingProgress(progress: number): void {\n    this.updateStatus('processing', progress);\n  }\n\n  // Handle processing error\n  onProcessingError(error: string): void {\n    this.updateStatus('error', 0, error);\n  }\n\n  // Stop filtering\n  stop(): void {\n    this.audioFilter.stop();\n    this.hideStatusOverlay();\n    this.updateStatus('idle');\n  }\n\n  // Resume filtering (re-start audio filter)\n  resume(): void {\n    if (!this.video || this.muteIntervals.length === 0) {\n      return;\n    }\n    this.audioFilter.start();\n    this.updateStatus('active');\n    this.showStatusOverlay();\n  }\n\n  // Update preferences\n  updatePreferences(preferences: UserPreferences): void {\n    this.preferences = preferences;\n\n    if (!preferences.enabled) {\n      this.stop();\n      return;\n    }\n\n    // Re-parse with new preferences\n    if (this.transcript) {\n      this.muteIntervals = parseTranscript(this.transcript, preferences);\n      this.audioFilter.updateIntervals(this.muteIntervals);\n      this.audioFilter.updateMode(preferences.filterMode);\n    }\n  }\n\n  // Get current state\n  getState(): VideoControllerState {\n    const filterState = this.audioFilter.getState();\n    return {\n      status: this.status,\n      progress: this.progress,\n      error: this.error,\n      intervalCount: filterState.intervalCount,\n      currentlyMuting: filterState.isMuted,\n    };\n  }\n\n  // Find the YouTube video element\n  private findVideoElement(): HTMLVideoElement | null {\n    // Main player video\n    const selectors = [\n      'video.html5-main-video',\n      'video.video-stream',\n      '#movie_player video',\n      'ytd-player video',\n      'video',\n    ];\n\n    for (const selector of selectors) {\n      const video = document.querySelector<HTMLVideoElement>(selector);\n      if (video && video.src) {\n        return video;\n      }\n    }\n\n    return null;\n  }\n\n  // Wait for video element to appear\n  private waitForVideo(timeout = 10000): Promise<HTMLVideoElement | null> {\n    return new Promise((resolve) => {\n      const startTime = Date.now();\n\n      const check = () => {\n        this.video = this.findVideoElement();\n        if (this.video) {\n          resolve(this.video);\n          return;\n        }\n\n        if (Date.now() - startTime > timeout) {\n          resolve(null);\n          return;\n        }\n\n        requestAnimationFrame(check);\n      };\n\n      check();\n    });\n  }\n\n  // Update status and notify listeners\n  private updateStatus(\n    status: FilterStatus,\n    progress = 0,\n    error?: string\n  ): void {\n    this.status = status;\n    this.progress = progress;\n    this.error = error;\n\n    if (this.options.onStateChange) {\n      this.options.onStateChange(this.getState());\n    }\n  }\n\n  // Show status overlay on video\n  private showStatusOverlay(): void {\n    if (this.statusOverlay) return;\n\n    const playerContainer = document.querySelector('#movie_player');\n    if (!playerContainer) return;\n\n    this.statusOverlay = document.createElement('div');\n    this.statusOverlay.className = 'safeplay-status-overlay';\n    this.statusOverlay.innerHTML = `\n      <div class=\"safeplay-status-badge\">\n        <svg class=\"safeplay-status-icon\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n          <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z\"/>\n        </svg>\n        <span>SafePlay Active</span>\n      </div>\n    `;\n\n    playerContainer.appendChild(this.statusOverlay);\n\n    // Auto-hide after 3 seconds\n    setTimeout(() => {\n      this.statusOverlay?.classList.add('safeplay-status-hidden');\n    }, 3000);\n  }\n\n  // Hide status overlay\n  private hideStatusOverlay(): void {\n    if (this.statusOverlay) {\n      this.statusOverlay.remove();\n      this.statusOverlay = null;\n    }\n  }\n\n  // Event handlers\n  private onMuteStart(interval: MuteInterval): void {\n    this.log('Muting:', interval.word);\n    this.notifyStateChange();\n  }\n\n  private onMuteEnd(): void {\n    this.notifyStateChange();\n  }\n\n  private notifyStateChange(): void {\n    if (this.options.onStateChange) {\n      this.options.onStateChange(this.getState());\n    }\n  }\n\n  // Debug logging\n  private log(...args: unknown[]): void {\n    if (this.options.debug) {\n      console.log('[SafePlay Controller]', ...args);\n    }\n  }\n}\n","// API Response Types\n\nexport interface CharacterTiming {\n  char: string;\n  start: number;\n  end: number;\n}\n\nexport interface TranscriptSegment {\n  text: string;\n  start_time: number;\n  end_time: number;\n  characters: CharacterTiming[];\n}\n\nexport interface Transcript {\n  id: string;\n  youtube_id?: string; // May be set from context\n  full_text?: string;\n  segments: TranscriptSegment[];\n  duration?: number;\n  language?: string;\n  created_at?: string;\n}\n\nexport interface FilterResponse {\n  status: 'completed' | 'processing';\n  cached?: boolean;\n  transcript?: Transcript;\n  job_id?: string;\n  message?: string;\n}\n\nexport interface JobStatusResponse {\n  status: 'pending' | 'downloading' | 'transcribing' | 'completed' | 'failed';\n  progress: number;\n  transcript?: Transcript;\n  error?: string;\n  video?: {\n    youtube_id: string;\n    title?: string;\n  };\n}\n\n// Button state for UX\nexport type ButtonState =\n  | 'idle'\n  | 'connecting'\n  | 'downloading'\n  | 'transcribing'\n  | 'processing'\n  | 'filtering'\n  | 'error';\n\nexport interface ButtonStateInfo {\n  state: ButtonState;\n  text: string;\n  progress?: number;\n  intervalCount?: number;\n  error?: string;\n}\n\n// Profanity Types\n\nexport type SeverityLevel = 'mild' | 'moderate' | 'severe';\n\nexport interface ProfanityWord {\n  word: string;\n  severity: SeverityLevel;\n}\n\nexport interface MuteInterval {\n  start: number;\n  end: number;\n  word: string;\n  severity: SeverityLevel;\n}\n\nexport interface ProfanityMatch {\n  segmentIndex: number;\n  word: string;\n  severity: SeverityLevel;\n  startTime: number;\n  endTime: number;\n  isPartialMatch: boolean;\n  matchedPortion?: string;\n}\n\n// User Preferences\n\nexport type FilterMode = 'mute' | 'bleep';\n\nexport interface UserPreferences {\n  enabled: boolean;\n  filterMode: FilterMode;\n  severityLevels: {\n    mild: boolean;\n    moderate: boolean;\n    severe: boolean;\n  };\n  customBlacklist: string[];\n  customWhitelist: string[];\n  paddingMs: number;\n  mergeThresholdMs: number;\n}\n\nexport const DEFAULT_PREFERENCES: UserPreferences = {\n  enabled: true,\n  filterMode: 'mute',\n  severityLevels: {\n    mild: false,\n    moderate: true,\n    severe: true,\n  },\n  customBlacklist: [],\n  customWhitelist: [],\n  paddingMs: 50,\n  mergeThresholdMs: 100,\n};\n\n// Storage Types\n\nexport interface StorageData {\n  preferences: UserPreferences;\n  authToken?: string;\n  userId?: string;\n  subscriptionTier?: 'free' | 'basic' | 'professional' | 'unlimited';\n  cachedTranscripts: Record<string, Transcript>;\n}\n\n// Message Types (between content script and background)\n\nexport type MessageType =\n  | 'GET_FILTER'\n  | 'CHECK_JOB'\n  | 'GET_PREFERENCES'\n  | 'SET_PREFERENCES'\n  | 'GET_AUTH_STATUS'\n  | 'CLEAR_CACHE';\n\nexport interface Message<T = unknown> {\n  type: MessageType;\n  payload?: T;\n}\n\nexport interface MessageResponse<T = unknown> {\n  success: boolean;\n  data?: T;\n  error?: string;\n}\n","// SafePlay Content Script - Main Entry Point\nimport { ResilientInjector } from './resilient-injector';\nimport { VideoController } from './video-controller';\nimport { UserPreferences, DEFAULT_PREFERENCES, Transcript, ButtonStateInfo } from '../types';\nimport './styles.css';\n\nconst DEBUG = true;\n\nfunction log(...args: unknown[]): void {\n  if (DEBUG) {\n    console.log('[SafePlay]', ...args);\n  }\n}\n\nclass SafePlayContentScript {\n  private injector: ResilientInjector;\n  private videoController: VideoController | null = null;\n  private preferences: UserPreferences = DEFAULT_PREFERENCES;\n  private currentVideoId: string | null = null;\n  private isProcessing = false;\n\n  constructor() {\n    // Initialize resilient injector for video watch page\n    this.injector = new ResilientInjector({\n      onButtonClick: (youtubeId) => this.onFilterButtonClick(youtubeId),\n      debug: DEBUG,\n    });\n\n    // Initialize video controller\n    this.videoController = new VideoController({\n      onStateChange: (state) => this.onVideoStateChange(state),\n      debug: DEBUG,\n    });\n  }\n\n  async initialize(): Promise<void> {\n    log('Initializing SafePlay content script');\n\n    // Load user preferences\n    await this.loadPreferences();\n\n    // Start injector - it handles watch page detection internally\n    this.injector.start();\n\n    // Check if we're on a watch page\n    if (this.isWatchPage()) {\n      this.currentVideoId = this.getVideoIdFromUrl();\n    }\n\n    // Listen for messages from background/popup\n    this.setupMessageListener();\n\n    // Listen for URL changes (YouTube SPA)\n    this.setupNavigationListener();\n\n    log('SafePlay initialized');\n  }\n\n  private async loadPreferences(): Promise<void> {\n    try {\n      const response = await chrome.runtime.sendMessage({\n        type: 'GET_PREFERENCES',\n      });\n\n      if (response.success && response.data) {\n        this.preferences = response.data;\n      }\n    } catch (error) {\n      log('Failed to load preferences:', error);\n    }\n  }\n\n  private isWatchPage(): boolean {\n    return window.location.pathname === '/watch';\n  }\n\n  private getVideoIdFromUrl(): string | null {\n    const params = new URLSearchParams(window.location.search);\n    return params.get('v');\n  }\n\n  private updateButtonState(stateInfo: ButtonStateInfo): void {\n    this.injector.updateButtonState(stateInfo);\n  }\n\n  // Main filter flow - called when SafePlay button is clicked\n  private async onFilterButtonClick(youtubeId: string): Promise<void> {\n    if (this.isProcessing) {\n      log('Already processing, ignoring click');\n      return;\n    }\n\n    log('Filter button clicked for:', youtubeId);\n    this.isProcessing = true;\n    this.currentVideoId = youtubeId;\n\n    try {\n      // Step 1: Connecting\n      this.updateButtonState({ state: 'connecting', text: 'Connecting...' });\n\n      // Request filter from background script (which calls the API)\n      const response = await chrome.runtime.sendMessage({\n        type: 'GET_FILTER',\n        payload: { youtubeId },\n      });\n\n      if (!response.success) {\n        throw new Error(response.error || 'Failed to request filter');\n      }\n\n      const { status, transcript, jobId } = response.data;\n\n      if ((status === 'cached' || status === 'completed') && transcript) {\n        // Transcript was cached (locally or on server), skip to processing\n        log('Using cached transcript');\n        this.updateButtonState({ state: 'processing', text: 'Processing...' });\n        await this.applyFilter(transcript);\n      } else if (status === 'processing' && jobId) {\n        // Need to poll for job completion\n        log('Job started, polling for completion:', jobId);\n        await this.pollJobStatus(jobId);\n      } else {\n        throw new Error('Unexpected API response');\n      }\n    } catch (error) {\n      log('Filter request failed:', error);\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      this.updateButtonState({\n        state: 'error',\n        text: 'Error',\n        error: errorMessage,\n      });\n      this.isProcessing = false;\n    }\n  }\n\n  // Poll for job status with progress updates\n  private async pollJobStatus(jobId: string): Promise<void> {\n    const maxAttempts = 180; // 6 minutes max (2s intervals)\n    const pollInterval = 2000;\n    let attempts = 0;\n\n    while (attempts < maxAttempts) {\n      try {\n        const response = await chrome.runtime.sendMessage({\n          type: 'CHECK_JOB',\n          payload: { jobId },\n        });\n\n        if (!response.success) {\n          throw new Error(response.error || 'Failed to check job status');\n        }\n\n        const { status, progress, transcript, error } = response.data;\n\n        log(`Job status: ${status}, progress: ${progress}%`);\n\n        // Update button based on job status with user-friendly messages\n        switch (status) {\n          case 'pending':\n            this.updateButtonState({\n              state: 'processing',\n              text: 'Starting...',\n              progress: 5,\n            });\n            break;\n\n          case 'downloading':\n          case 'transcribing':\n            // Show generic \"Analyzing\" with progress percentage\n            // Scale progress: downloading 0-30%, transcribing 30-90%\n            const scaledProgress = status === 'downloading'\n              ? Math.round(progress * 0.3)\n              : Math.round(30 + progress * 0.6);\n            this.updateButtonState({\n              state: 'processing',\n              text: `Analyzing ${scaledProgress}%`,\n              progress: scaledProgress,\n            });\n            break;\n\n          case 'completed':\n            if (transcript) {\n              this.updateButtonState({\n                state: 'processing',\n                text: 'Analyzing 95%',\n                progress: 95,\n              });\n              await this.applyFilter(transcript);\n              return;\n            } else {\n              throw new Error('Job completed but no transcript returned');\n            }\n\n          case 'failed':\n            throw new Error(error || 'Processing failed');\n\n          default:\n            // Generic processing state\n            this.updateButtonState({\n              state: 'processing',\n              text: `Analyzing ${Math.round(progress)}%`,\n              progress,\n            });\n        }\n\n        // Wait before next poll\n        await new Promise((resolve) => setTimeout(resolve, pollInterval));\n        attempts++;\n      } catch (error) {\n        log('Poll error:', error);\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        this.updateButtonState({\n          state: 'error',\n          text: 'Error',\n          error: errorMessage,\n        });\n        this.isProcessing = false;\n        return;\n      }\n    }\n\n    // Timeout\n    this.updateButtonState({\n      state: 'error',\n      text: 'Timeout',\n      error: 'Processing took too long. Please try again.',\n    });\n    this.isProcessing = false;\n  }\n\n  // Apply the filter using the transcript\n  private async applyFilter(transcript: Transcript): Promise<void> {\n    if (!this.videoController) {\n      throw new Error('Video controller not initialized');\n    }\n\n    const videoId = this.currentVideoId;\n    if (!videoId) {\n      throw new Error('No video ID');\n    }\n\n    try {\n      // Initialize video controller with transcript\n      await this.videoController.initialize(videoId, this.preferences);\n      this.videoController.onTranscriptReceived(transcript);\n\n      // Apply the filter\n      await this.videoController.applyFilter();\n\n      // Get the interval count for display\n      const state = this.videoController.getState();\n      const intervalCount = state.intervalCount || 0;\n\n      // Update button to filtering state\n      this.updateButtonState({\n        state: 'filtering',\n        text: `Filtering (${intervalCount})`,\n        intervalCount,\n      });\n\n      log(`Filter applied successfully. ${intervalCount} profanity instances will be muted.`);\n\n      // Create player controls for toggling\n      this.injectPlayerControls();\n    } catch (error) {\n      log('Failed to apply filter:', error);\n      throw error;\n    } finally {\n      this.isProcessing = false;\n    }\n  }\n\n  private injectPlayerControls(): void {\n    // Check if already injected\n    if (document.querySelector('.safeplay-player-controls')) return;\n\n    // Wait for player controls to be available\n    const waitForControls = () => {\n      const rightControls = document.querySelector('.ytp-right-controls');\n      if (rightControls) {\n        this.createPlayerButton(rightControls);\n      } else {\n        setTimeout(waitForControls, 500);\n      }\n    };\n\n    waitForControls();\n  }\n\n  private createPlayerButton(container: Element): void {\n    const button = document.createElement('button');\n    button.className = 'ytp-button safeplay-player-controls safeplay-active';\n    button.title = 'SafePlay Filter Active - Click to toggle';\n    button.innerHTML = `\n      <svg viewBox=\"0 0 24 24\" fill=\"currentColor\" width=\"24\" height=\"24\">\n        <path d=\"M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm-2 16l-4-4 1.41-1.41L10 14.17l6.59-6.59L18 9l-8 8z\"/>\n      </svg>\n    `;\n\n    button.addEventListener('click', () => this.toggleFilter());\n\n    // Insert before settings button\n    const settingsButton = container.querySelector('.ytp-settings-button');\n    if (settingsButton) {\n      container.insertBefore(button, settingsButton);\n    } else {\n      container.appendChild(button);\n    }\n  }\n\n  private async toggleFilter(): Promise<void> {\n    if (!this.videoController) return;\n\n    const state = this.videoController.getState();\n    const playerButton = document.querySelector('.safeplay-player-controls');\n\n    if (state.status === 'active') {\n      this.videoController.stop();\n      playerButton?.classList.remove('safeplay-active');\n      playerButton?.setAttribute('title', 'SafePlay Filter Paused - Click to resume');\n      this.updateButtonState({ state: 'idle', text: 'SafePlay' });\n    } else if (this.currentVideoId) {\n      // Resume filtering\n      this.videoController.resume();\n      playerButton?.classList.add('safeplay-active');\n      playerButton?.setAttribute('title', 'SafePlay Filter Active - Click to toggle');\n\n      const intervalCount = state.intervalCount || 0;\n      this.updateButtonState({\n        state: 'filtering',\n        text: `Filtering (${intervalCount})`,\n        intervalCount,\n      });\n    }\n  }\n\n  private onVideoStateChange(state: ReturnType<VideoController['getState']>): void {\n    log('Video state changed:', state);\n\n    // Notify popup of state change\n    chrome.runtime.sendMessage({\n      type: 'VIDEO_STATE_CHANGED',\n      payload: state,\n    }).catch(() => {\n      // Popup might not be open\n    });\n  }\n\n  private setupMessageListener(): void {\n    chrome.runtime.onMessage.addListener((message, _sender, sendResponse) => {\n      this.handleMessage(message).then(sendResponse);\n      return true; // Keep channel open for async response\n    });\n  }\n\n  private async handleMessage(message: { type: string; payload?: unknown }): Promise<unknown> {\n    switch (message.type) {\n      case 'PREFERENCES_UPDATED': {\n        const newPrefs = message.payload as UserPreferences;\n        this.preferences = newPrefs;\n        this.videoController?.updatePreferences(newPrefs);\n        return { success: true };\n      }\n\n      case 'GET_VIDEO_STATE': {\n        return {\n          success: true,\n          data: this.videoController?.getState() || null,\n        };\n      }\n\n      default:\n        return { success: false, error: 'Unknown message type' };\n    }\n  }\n\n  private setupNavigationListener(): void {\n    // YouTube SPA navigation\n    document.addEventListener('yt-navigate-finish', () => {\n      log('YouTube navigation detected');\n      this.onNavigation();\n    });\n\n    // Fallback: popstate\n    window.addEventListener('popstate', () => {\n      this.onNavigation();\n    });\n  }\n\n  private onNavigation(): void {\n    // Stop current filter if any\n    if (this.videoController) {\n      this.videoController.stop();\n    }\n\n    // Reset state\n    this.currentVideoId = null;\n    this.isProcessing = false;\n\n    // Remove player button\n    const playerButton = document.querySelector('.safeplay-player-controls');\n    if (playerButton) {\n      playerButton.remove();\n    }\n\n    // Update video ID if on watch page\n    if (this.isWatchPage()) {\n      this.currentVideoId = this.getVideoIdFromUrl();\n    }\n  }\n}\n\n// Initialize when DOM is ready\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', () => {\n    const safeplay = new SafePlayContentScript();\n    safeplay.initialize();\n  });\n} else {\n  const safeplay = new SafePlayContentScript();\n  safeplay.initialize();\n}\n"],"names":["BUTTON_CONTAINER_CLASS","BUTTON_STATES","idle","bg","hoverBg","text","shadow","connecting","downloading","transcribing","processing","filtering","error","ResilientInjector","constructor","options","observer","currentVideoId","injectionAttempts","maxAttempts","retryInterval","currentState","this","start","log","attemptInjection","setupMutationObserver","setupNavigationListener","stop","disconnect","clearInterval","isWatchPage","window","location","pathname","search","includes","getVideoId","URLSearchParams","get","videoId","isButtonPresent","subscribeButton","findSubscribeButton","injectButton","setInterval","selectors","selector","element","document","querySelector","existingButton","remove","container","createElement","className","style","cssText","setAttribute","button","title","stateConfig","progressBar","iconWrapper","innerHTML","getIconSVG","textSpan","textContent","appendChild","addEventListener","config","background","boxShadow","transform","e","preventDefault","stopPropagation","onButtonClick","parentElement","insertBefore","nextSibling","state","updateButtonState","stateInfo","displayText","undefined","progress","replace","Math","round","intervalCount","width","display","cursor","setButtonState","MutationObserver","mutations","mutation","type","addedNodes","length","node","HTMLElement","id","closest","observe","body","childList","subtree","originalPushState","history","pushState","originalReplaceState","replaceState","args","apply","onNavigation","setTimeout","getCurrentVideoId","debug","console","AudioFilter","video","muteIntervals","filterMode","isActive","checkIntervalId","isMuted","audioContext","bleepOscillator","bleepGain","onMuteStart","onMuteEnd","initialize","intervals","mode","sort","a","b","initializeAudioContext","AudioContext","createGain","gain","value","connect","destination","checkCurrentTime","unmute","close","currentTime","activeInterval","findActiveInterval","mute","time","low","high","mid","floor","interval","end","muted","startBleep","stopBleep","resume","createOscillator","frequency","setValueAtTime","linearRampToValueAtTime","updateIntervals","updateMode","getState","isFiltering","getIntervals","PROFANITY_MAP","Map","word","severity","map","item","toLowerCase","findEmbeddedProfanity","results","lowerText","index","indexOf","push","startIndex","endIndex","filtered","match","lastMatch","TranscriptParser","preferences","customBlacklistMap","customBlacklist","customWhitelistSet","Set","customWhitelist","shouldFilterSeverity","severityLevels","shouldFilterWord","lowerWord","has","getWordSeverity","findProfanityMatches","segments","matches","i","segment","normalizedText","trim","exactSeverity","segmentIndex","startTime","start_time","endTime","end_time","isPartialMatch","embeddedMatches","customWord","embedded","characters","startChar","endChar","matchedPortion","substring","createMuteIntervals","paddingSeconds","paddingMs","max","mergeIntervals","sorted","mergeThresholdSeconds","mergeThresholdMs","merged","current","last","severityRank","mild","moderate","severe","parse","transcript","parseTranscript","VideoController","youtubeId","status","statusOverlay","audioFilter","updateStatus","findVideoElement","waitForVideo","applyFilter","enabled","response","chrome","runtime","sendMessage","payload","success","Error","data","processTranscript","message","showStatusOverlay","onTranscriptReceived","onProcessingProgress","onProcessingError","hideStatusOverlay","updatePreferences","filterState","currentlyMuting","src","timeout","Promise","resolve","Date","now","check","requestAnimationFrame","onStateChange","playerContainer","classList","add","notifyStateChange","DEFAULT_PREFERENCES","DEBUG","SafePlayContentScript","videoController","isProcessing","injector","onFilterButtonClick","onVideoStateChange","loadPreferences","getVideoIdFromUrl","setupMessageListener","jobId","pollJobStatus","errorMessage","attempts","scaledProgress","injectPlayerControls","waitForControls","rightControls","createPlayerButton","toggleFilter","settingsButton","playerButton","catch","onMessage","addListener","_sender","sendResponse","handleMessage","then","newPrefs","readyState"],"ignoreList":[],"sourceRoot":""}