{"version":3,"file":"options.js","mappings":"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","sources":["webpack://safeplay-chrome-extension/./src/types/index.ts","webpack://safeplay-chrome-extension/./src/options/index.ts"],"sourcesContent":["// API Response Types\n\nexport interface TranscriptSegment {\n  text: string;\n  start_time: number;\n  end_time: number;\n}\n\nexport interface Transcript {\n  id: string;\n  youtube_id?: string; // May be set from context\n  full_text?: string;\n  segments: TranscriptSegment[];\n  duration?: number;\n  language?: string;\n  created_at?: string;\n}\n\n// Video metadata from preview endpoint\nexport interface VideoMetadata {\n  youtube_id: string;\n  title: string;\n  duration: number; // in seconds\n  thumbnail?: string;\n  channel?: string;\n}\n\n// Credit system types\nexport interface CreditInfo {\n  available: number;\n  used_this_period: number;\n  plan_allocation: number;\n  percent_consumed: number;\n  plan?: 'free' | 'base' | 'professional' | 'unlimited';\n  reset_date?: string;\n}\n\n// Preview response - check cost before filtering (matches actual API format)\nexport interface PreviewResponse {\n  youtube_id: string;\n  title: string;\n  channel_name?: string;\n  duration_seconds: number;\n  thumbnail_url?: string;\n  credit_cost: number;\n  user_credits: number;\n  has_sufficient_credits: boolean;\n  cached: boolean;\n  has_transcript: boolean;\n  credit_cost_note?: string; // Note when duration/cost is unknown\n  error?: string;\n  error_code?: 'AGE_RESTRICTED' | 'VIDEO_UNAVAILABLE' | 'UNAUTHORIZED' | string;\n}\n\n// Credit balance response\nexport interface CreditBalanceResponse {\n  success: boolean;\n  credits: CreditInfo;\n  error?: string;\n}\n\n// Filter start response\nexport interface FilterStartResponse {\n  success: boolean;\n  status: 'completed' | 'processing' | 'failed';\n  cached?: boolean;\n  transcript?: Transcript;\n  job_id?: string;\n  message?: string;\n  error?: string;\n  error_code?: 'INSUFFICIENT_CREDITS' | 'AGE_RESTRICTED' | 'VIDEO_UNAVAILABLE' | 'UNAUTHORIZED' | string;\n  credits_required?: number;\n  credits_available?: number;\n}\n\n// Job status response\nexport interface JobStatusResponse {\n  status: 'pending' | 'downloading' | 'transcribing' | 'completed' | 'failed';\n  progress: number;\n  message?: string;\n  transcript?: Transcript;\n  error?: string;\n  error_code?: 'AGE_RESTRICTED' | 'VIDEO_UNAVAILABLE' | string;\n  video?: {\n    youtube_id: string;\n    title?: string;\n  };\n}\n\n// Legacy FilterResponse - kept for compatibility during migration\nexport interface FilterResponse {\n  status: 'completed' | 'processing' | 'failed';\n  cached?: boolean;\n  transcript?: Transcript;\n  job_id?: string;\n  message?: string;\n  error?: string;\n  error_code?: string;  // 'AGE_RESTRICTED', 'VIDEO_UNAVAILABLE', etc.\n}\n\n// Button state for UX\nexport type ButtonState =\n  | 'idle'\n  | 'connecting'\n  | 'downloading'\n  | 'transcribing'\n  | 'processing'\n  | 'filtering'\n  | 'paused'  // Filter is paused (user can re-enable)\n  | 'error'\n  | 'age-restricted';  // Video is age-restricted and cannot be filtered\n\nexport interface ButtonStateInfo {\n  state: ButtonState;\n  text: string;\n  progress?: number;\n  intervalCount?: number;\n  error?: string;\n  videoId?: string; // Track which video this state belongs to (for Shorts)\n}\n\n// Profanity Types\n\nexport type SeverityLevel = 'mild' | 'moderate' | 'severe' | 'religious';\n\nexport interface ProfanityWord {\n  word: string;\n  severity: SeverityLevel;\n}\n\nexport interface MuteInterval {\n  start: number;\n  end: number;\n  word: string;\n  severity: SeverityLevel;\n}\n\nexport interface ProfanityMatch {\n  segmentIndex: number;\n  word: string;\n  severity: SeverityLevel;\n  startTime: number;\n  endTime: number;\n  isPartialMatch: boolean;\n  matchedPortion?: string;\n}\n\n// User Preferences\n\nexport type FilterMode = 'mute' | 'bleep';\n\nexport interface UserPreferences {\n  enabled: boolean;\n  filterMode: FilterMode;\n  severityLevels: {\n    mild: boolean;\n    moderate: boolean;\n    severe: boolean;\n    religious: boolean;\n  };\n  customBlacklist: string[];\n  customWhitelist: string[];\n  paddingMs: number; // Legacy/fallback symmetric padding\n  paddingBeforeMs?: number; // Padding before word starts (catches attack)\n  paddingAfterMs?: number; // Padding after word ends (catches release)\n  mergeThresholdMs: number;\n  autoEnableForFilteredVideos: boolean; // Auto-enable filter for previously filtered videos\n}\n\nexport const DEFAULT_PREFERENCES: UserPreferences = {\n  enabled: true,\n  filterMode: 'mute',\n  severityLevels: {\n    mild: false,\n    moderate: true,\n    severe: true,\n    religious: false, // Off by default - user opt-in\n  },\n  customBlacklist: [],\n  customWhitelist: [],\n  paddingMs: 50, // Legacy/fallback symmetric padding\n  paddingBeforeMs: 100, // Padding before word - smooth fade adds ~130ms effective lead time\n  paddingAfterMs: 30, // Padding after word ends\n  mergeThresholdMs: 100,\n  autoEnableForFilteredVideos: true, // Auto-enable filter for previously filtered videos\n};\n\n// Storage Types\n\nexport type SubscriptionTier = 'free' | 'base' | 'professional' | 'unlimited';\n\nexport interface StorageData {\n  preferences: UserPreferences;\n  authToken?: string;\n  userId?: string;\n  subscriptionTier?: SubscriptionTier;\n  creditInfo?: CreditInfo;\n  cachedTranscripts: Record<string, Transcript>;\n}\n\n// Message Types (between content script and background)\n\nexport type MessageType =\n  | 'GET_FILTER'\n  | 'GET_PREVIEW'\n  | 'START_FILTER'\n  | 'CHECK_JOB'\n  | 'GET_CREDITS'\n  | 'GET_PREFERENCES'\n  | 'SET_PREFERENCES'\n  | 'GET_AUTH_STATUS'\n  | 'CHECK_AUTH_STRICT'\n  | 'GET_USER_PROFILE'\n  | 'LOGOUT'\n  | 'OPEN_LOGIN'\n  | 'CLEAR_CACHE';\n\nexport interface Message<T = unknown> {\n  type: MessageType;\n  payload?: T;\n}\n\nexport interface MessageResponse<T = unknown> {\n  success: boolean;\n  data?: T;\n  error?: string;\n}\n\n// Preview data passed to content script\nexport interface PreviewData {\n  video: VideoMetadata;\n  creditCost: number;\n  creditCostNote?: string; // Note when cost is unknown (e.g., \"~1 credit per minute\")\n  creditCostUnknown?: boolean; // True when duration unavailable\n  userCredits: number;\n  hasSufficientCredits: boolean;\n  isCached: boolean;\n}\n\n// Filter confirmation payload from content script\nexport interface FilterConfirmPayload {\n  youtubeId: string;\n  filterType?: 'mute' | 'bleep';\n  customWords?: string[];\n}\n\n// User Profile Types\nexport interface UserProfile {\n  id: string;\n  email: string;\n  full_name?: string;\n  avatar_url?: string;\n  created_at?: string;\n}\n\nexport interface UserSubscription {\n  id: string;\n  user_id: string;\n  plan_id: string;\n  status: 'active' | 'canceled' | 'past_due' | 'paused';\n  current_period_start?: string;\n  current_period_end?: string;\n  plans?: {\n    id: string;\n    name: string;\n    monthly_credits: number;\n  };\n}\n\nexport interface UserCredits {\n  user_id: string;\n  available_credits: number;\n  used_this_period: number;\n  rollover_credits: number;\n  updated_at?: string;\n}\n\nexport interface UserProfileResponse {\n  user: UserProfile;\n  subscription: UserSubscription | null;\n  credits: UserCredits | null;\n}\n\nexport interface AuthState {\n  isAuthenticated: boolean;\n  user: UserProfile | null;\n  subscription: UserSubscription | null;\n  credits: UserCredits | null;\n  token: string | null;\n}\n","// SafePlay Options Page Script\nimport { UserPreferences, DEFAULT_PREFERENCES } from '../types';\nimport './options.css';\n\nclass OptionsController {\n  private preferences: UserPreferences = DEFAULT_PREFERENCES;\n\n  // DOM Elements\n  private customBlacklist!: HTMLTextAreaElement;\n  private customWhitelist!: HTMLTextAreaElement;\n  private paddingBefore!: HTMLInputElement;\n  private paddingAfter!: HTMLInputElement;\n  private mergeThreshold!: HTMLInputElement;\n  private autoEnableFiltered!: HTMLInputElement;\n  private cacheCount!: HTMLElement;\n  private clearCacheBtn!: HTMLButtonElement;\n  private saveBtn!: HTMLButtonElement;\n  private saveStatus!: HTMLElement;\n\n  async initialize(): Promise<void> {\n    // Get DOM elements\n    this.customBlacklist = document.getElementById('customBlacklist') as HTMLTextAreaElement;\n    this.customWhitelist = document.getElementById('customWhitelist') as HTMLTextAreaElement;\n    this.paddingBefore = document.getElementById('paddingBefore') as HTMLInputElement;\n    this.paddingAfter = document.getElementById('paddingAfter') as HTMLInputElement;\n    this.mergeThreshold = document.getElementById('mergeThreshold') as HTMLInputElement;\n    this.autoEnableFiltered = document.getElementById('autoEnableFiltered') as HTMLInputElement;\n    this.cacheCount = document.getElementById('cacheCount') as HTMLElement;\n    this.clearCacheBtn = document.getElementById('clearCacheBtn') as HTMLButtonElement;\n    this.saveBtn = document.getElementById('saveBtn') as HTMLButtonElement;\n    this.saveStatus = document.getElementById('saveStatus') as HTMLElement;\n\n    // Load preferences\n    await this.loadPreferences();\n\n    // Load cache count\n    await this.loadCacheCount();\n\n    // Set up event listeners\n    this.setupEventListeners();\n  }\n\n  private async loadPreferences(): Promise<void> {\n    try {\n      const response = await chrome.runtime.sendMessage({ type: 'GET_PREFERENCES' });\n      if (response.success && response.data) {\n        this.preferences = response.data;\n        this.updateUI();\n      }\n    } catch (error) {\n      console.error('Failed to load preferences:', error);\n    }\n  }\n\n  private updateUI(): void {\n    // Update custom word lists\n    this.customBlacklist.value = this.preferences.customBlacklist.join('\\n');\n    this.customWhitelist.value = this.preferences.customWhitelist.join('\\n');\n\n    // Update timing settings\n    this.paddingBefore.value = (this.preferences.paddingBeforeMs ?? this.preferences.paddingMs).toString();\n    this.paddingAfter.value = (this.preferences.paddingAfterMs ?? this.preferences.paddingMs).toString();\n    this.mergeThreshold.value = this.preferences.mergeThresholdMs.toString();\n\n    // Update behavior settings\n    this.autoEnableFiltered.checked = this.preferences.autoEnableForFilteredVideos !== false;\n  }\n\n  private async loadCacheCount(): Promise<void> {\n    try {\n      const storage = await chrome.storage.local.get('cachedTranscripts');\n      const cached = storage.cachedTranscripts || {};\n      const count = Object.keys(cached).length;\n      this.cacheCount.textContent = count.toString();\n    } catch (error) {\n      console.error('Failed to load cache count:', error);\n      this.cacheCount.textContent = '0';\n    }\n  }\n\n  private setupEventListeners(): void {\n    // Save button\n    this.saveBtn.addEventListener('click', () => {\n      this.saveSettings();\n    });\n\n    // Clear cache button\n    this.clearCacheBtn.addEventListener('click', () => {\n      this.clearCache();\n    });\n\n    // Listen for preference updates from other tabs\n    chrome.runtime.onMessage.addListener((message) => {\n      if (message.type === 'PREFERENCES_UPDATED' && message.payload) {\n        this.preferences = message.payload;\n        this.updateUI();\n      }\n    });\n  }\n\n  private parseWordList(text: string): string[] {\n    return text\n      .split('\\n')\n      .map(word => word.trim().toLowerCase())\n      .filter(word => word.length > 0);\n  }\n\n  private async saveSettings(): Promise<void> {\n    try {\n      const updates: Partial<UserPreferences> = {\n        customBlacklist: this.parseWordList(this.customBlacklist.value),\n        customWhitelist: this.parseWordList(this.customWhitelist.value),\n        paddingBeforeMs: parseInt(this.paddingBefore.value, 10) || 100,\n        paddingAfterMs: parseInt(this.paddingAfter.value, 10) || 30,\n        mergeThresholdMs: parseInt(this.mergeThreshold.value, 10) || 100,\n        autoEnableForFilteredVideos: this.autoEnableFiltered.checked,\n      };\n\n      const response = await chrome.runtime.sendMessage({\n        type: 'SET_PREFERENCES',\n        payload: updates,\n      });\n\n      if (response.success) {\n        this.preferences = response.data;\n        this.showSaveStatus('Settings saved successfully!', 'success');\n      } else {\n        this.showSaveStatus('Failed to save settings', 'error');\n      }\n    } catch (error) {\n      console.error('Failed to save settings:', error);\n      this.showSaveStatus('Failed to save settings', 'error');\n    }\n  }\n\n  private async clearCache(): Promise<void> {\n    try {\n      const response = await chrome.runtime.sendMessage({ type: 'CLEAR_CACHE' });\n\n      if (response.success) {\n        this.cacheCount.textContent = '0';\n        this.showSaveStatus('Cache cleared!', 'success');\n      } else {\n        this.showSaveStatus('Failed to clear cache', 'error');\n      }\n    } catch (error) {\n      console.error('Failed to clear cache:', error);\n      this.showSaveStatus('Failed to clear cache', 'error');\n    }\n  }\n\n  private showSaveStatus(message: string, type: 'success' | 'error'): void {\n    this.saveStatus.textContent = message;\n    this.saveStatus.className = `save-status ${type}`;\n\n    // Clear after 3 seconds\n    setTimeout(() => {\n      this.saveStatus.textContent = '';\n      this.saveStatus.className = 'save-status';\n    }, 3000);\n  }\n}\n\n// Initialize when DOM is ready\ndocument.addEventListener('DOMContentLoaded', () => {\n  const options = new OptionsController();\n  options.initialize();\n});\n"],"names":["DEFAULT_PREFERENCES","enabled","filterMode","severityLevels","mild","moderate","severe","religious","customBlacklist","customWhitelist","paddingMs","paddingBeforeMs","paddingAfterMs","mergeThresholdMs","autoEnableForFilteredVideos","OptionsController","preferences","initialize","this","document","getElementById","paddingBefore","paddingAfter","mergeThreshold","autoEnableFiltered","cacheCount","clearCacheBtn","saveBtn","saveStatus","loadPreferences","loadCacheCount","setupEventListeners","response","chrome","runtime","sendMessage","type","success","data","updateUI","error","console","value","join","toString","checked","cached","storage","local","get","cachedTranscripts","count","Object","keys","length","textContent","addEventListener","saveSettings","clearCache","onMessage","addListener","message","payload","parseWordList","text","split","map","word","trim","toLowerCase","filter","updates","parseInt","showSaveStatus","className","setTimeout"],"ignoreList":[],"sourceRoot":""}