{"version":3,"file":"options.js","mappings":"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","sources":["webpack://safeplay-chrome-extension/./src/types/index.ts","webpack://safeplay-chrome-extension/./src/options/index.ts"],"sourcesContent":["// API Response Types\n\nexport interface CharacterTiming {\n  char: string;\n  start: number;\n  end: number;\n}\n\nexport interface TranscriptSegment {\n  text: string;\n  start_time: number;\n  end_time: number;\n  characters: CharacterTiming[];\n}\n\nexport interface Transcript {\n  id: string;\n  youtube_id?: string; // May be set from context\n  full_text?: string;\n  segments: TranscriptSegment[];\n  duration?: number;\n  language?: string;\n  created_at?: string;\n}\n\n// Video metadata from preview endpoint\nexport interface VideoMetadata {\n  youtube_id: string;\n  title: string;\n  duration: number; // in seconds\n  thumbnail?: string;\n  channel?: string;\n}\n\n// Credit system types\nexport interface CreditInfo {\n  available: number;\n  used_this_period: number;\n  plan_allocation: number;\n  percent_consumed: number;\n  plan?: 'free' | 'base' | 'professional' | 'unlimited';\n  reset_date?: string;\n}\n\n// Preview response - check cost before filtering\nexport interface PreviewResponse {\n  success: boolean;\n  video: VideoMetadata;\n  credit_cost: number;\n  user_credits: number;\n  has_sufficient_credits: boolean;\n  cached: boolean;\n  has_transcript: boolean;\n  message?: string;\n  error?: string;\n  error_code?: 'AGE_RESTRICTED' | 'VIDEO_UNAVAILABLE' | 'UNAUTHORIZED' | string;\n}\n\n// Credit balance response\nexport interface CreditBalanceResponse {\n  success: boolean;\n  credits: CreditInfo;\n  error?: string;\n}\n\n// Filter start response\nexport interface FilterStartResponse {\n  success: boolean;\n  status: 'completed' | 'processing' | 'failed';\n  cached?: boolean;\n  transcript?: Transcript;\n  job_id?: string;\n  message?: string;\n  error?: string;\n  error_code?: 'INSUFFICIENT_CREDITS' | 'AGE_RESTRICTED' | 'VIDEO_UNAVAILABLE' | 'UNAUTHORIZED' | string;\n  credits_required?: number;\n  credits_available?: number;\n}\n\n// Job status response\nexport interface JobStatusResponse {\n  status: 'pending' | 'downloading' | 'transcribing' | 'completed' | 'failed';\n  progress: number;\n  message?: string;\n  transcript?: Transcript;\n  error?: string;\n  error_code?: 'AGE_RESTRICTED' | 'VIDEO_UNAVAILABLE' | string;\n  video?: {\n    youtube_id: string;\n    title?: string;\n  };\n}\n\n// Legacy FilterResponse - kept for compatibility during migration\nexport interface FilterResponse {\n  status: 'completed' | 'processing' | 'failed';\n  cached?: boolean;\n  transcript?: Transcript;\n  job_id?: string;\n  message?: string;\n  error?: string;\n  error_code?: string;  // 'AGE_RESTRICTED', 'VIDEO_UNAVAILABLE', etc.\n}\n\n// Button state for UX\nexport type ButtonState =\n  | 'idle'\n  | 'connecting'\n  | 'downloading'\n  | 'transcribing'\n  | 'processing'\n  | 'filtering'\n  | 'paused'  // Filter is paused (user can re-enable)\n  | 'error'\n  | 'age-restricted';  // Video is age-restricted and cannot be filtered\n\nexport interface ButtonStateInfo {\n  state: ButtonState;\n  text: string;\n  progress?: number;\n  intervalCount?: number;\n  error?: string;\n  videoId?: string; // Track which video this state belongs to (for Shorts)\n}\n\n// Profanity Types\n\nexport type SeverityLevel = 'mild' | 'moderate' | 'severe' | 'religious';\n\nexport interface ProfanityWord {\n  word: string;\n  severity: SeverityLevel;\n}\n\nexport interface MuteInterval {\n  start: number;\n  end: number;\n  word: string;\n  severity: SeverityLevel;\n}\n\nexport interface ProfanityMatch {\n  segmentIndex: number;\n  word: string;\n  severity: SeverityLevel;\n  startTime: number;\n  endTime: number;\n  isPartialMatch: boolean;\n  matchedPortion?: string;\n}\n\n// User Preferences\n\nexport type FilterMode = 'mute' | 'bleep';\n\nexport interface UserPreferences {\n  enabled: boolean;\n  filterMode: FilterMode;\n  severityLevels: {\n    mild: boolean;\n    moderate: boolean;\n    severe: boolean;\n    religious: boolean;\n  };\n  customBlacklist: string[];\n  customWhitelist: string[];\n  paddingMs: number; // Legacy/fallback symmetric padding\n  paddingBeforeMs?: number; // Padding before word starts (catches attack)\n  paddingAfterMs?: number; // Padding after word ends (catches release)\n  mergeThresholdMs: number;\n  autoEnableForFilteredVideos: boolean; // Auto-enable filter for previously filtered videos\n}\n\nexport const DEFAULT_PREFERENCES: UserPreferences = {\n  enabled: true,\n  filterMode: 'mute',\n  severityLevels: {\n    mild: false,\n    moderate: true,\n    severe: true,\n    religious: false, // Off by default - user opt-in\n  },\n  customBlacklist: [],\n  customWhitelist: [],\n  paddingMs: 50, // Legacy/fallback symmetric padding\n  paddingBeforeMs: 100, // Padding before word - smooth fade adds ~130ms effective lead time\n  paddingAfterMs: 30, // Padding after word ends\n  mergeThresholdMs: 100,\n  autoEnableForFilteredVideos: true, // Auto-enable filter for previously filtered videos\n};\n\n// Storage Types\n\nexport type SubscriptionTier = 'free' | 'base' | 'professional' | 'unlimited';\n\nexport interface StorageData {\n  preferences: UserPreferences;\n  authToken?: string;\n  userId?: string;\n  subscriptionTier?: SubscriptionTier;\n  creditInfo?: CreditInfo;\n  cachedTranscripts: Record<string, Transcript>;\n}\n\n// Message Types (between content script and background)\n\nexport type MessageType =\n  | 'GET_FILTER'\n  | 'GET_PREVIEW'\n  | 'START_FILTER'\n  | 'CHECK_JOB'\n  | 'GET_CREDITS'\n  | 'GET_PREFERENCES'\n  | 'SET_PREFERENCES'\n  | 'GET_AUTH_STATUS'\n  | 'CLEAR_CACHE';\n\nexport interface Message<T = unknown> {\n  type: MessageType;\n  payload?: T;\n}\n\nexport interface MessageResponse<T = unknown> {\n  success: boolean;\n  data?: T;\n  error?: string;\n}\n\n// Preview data passed to content script\nexport interface PreviewData {\n  video: VideoMetadata;\n  creditCost: number;\n  userCredits: number;\n  hasSufficientCredits: boolean;\n  isCached: boolean;\n}\n\n// Filter confirmation payload from content script\nexport interface FilterConfirmPayload {\n  youtubeId: string;\n  filterType?: 'mute' | 'bleep';\n  customWords?: string[];\n}\n","// SafePlay Options Page Script\nimport { UserPreferences, DEFAULT_PREFERENCES } from '../types';\nimport './options.css';\n\nclass OptionsController {\n  private preferences: UserPreferences = DEFAULT_PREFERENCES;\n\n  // DOM Elements\n  private customBlacklist!: HTMLTextAreaElement;\n  private customWhitelist!: HTMLTextAreaElement;\n  private paddingBefore!: HTMLInputElement;\n  private paddingAfter!: HTMLInputElement;\n  private mergeThreshold!: HTMLInputElement;\n  private cacheCount!: HTMLElement;\n  private clearCacheBtn!: HTMLButtonElement;\n  private saveBtn!: HTMLButtonElement;\n  private saveStatus!: HTMLElement;\n\n  async initialize(): Promise<void> {\n    // Get DOM elements\n    this.customBlacklist = document.getElementById('customBlacklist') as HTMLTextAreaElement;\n    this.customWhitelist = document.getElementById('customWhitelist') as HTMLTextAreaElement;\n    this.paddingBefore = document.getElementById('paddingBefore') as HTMLInputElement;\n    this.paddingAfter = document.getElementById('paddingAfter') as HTMLInputElement;\n    this.mergeThreshold = document.getElementById('mergeThreshold') as HTMLInputElement;\n    this.cacheCount = document.getElementById('cacheCount') as HTMLElement;\n    this.clearCacheBtn = document.getElementById('clearCacheBtn') as HTMLButtonElement;\n    this.saveBtn = document.getElementById('saveBtn') as HTMLButtonElement;\n    this.saveStatus = document.getElementById('saveStatus') as HTMLElement;\n\n    // Load preferences\n    await this.loadPreferences();\n\n    // Load cache count\n    await this.loadCacheCount();\n\n    // Set up event listeners\n    this.setupEventListeners();\n  }\n\n  private async loadPreferences(): Promise<void> {\n    try {\n      const response = await chrome.runtime.sendMessage({ type: 'GET_PREFERENCES' });\n      if (response.success && response.data) {\n        this.preferences = response.data;\n        this.updateUI();\n      }\n    } catch (error) {\n      console.error('Failed to load preferences:', error);\n    }\n  }\n\n  private updateUI(): void {\n    // Update custom word lists\n    this.customBlacklist.value = this.preferences.customBlacklist.join('\\n');\n    this.customWhitelist.value = this.preferences.customWhitelist.join('\\n');\n\n    // Update timing settings\n    this.paddingBefore.value = (this.preferences.paddingBeforeMs ?? this.preferences.paddingMs).toString();\n    this.paddingAfter.value = (this.preferences.paddingAfterMs ?? this.preferences.paddingMs).toString();\n    this.mergeThreshold.value = this.preferences.mergeThresholdMs.toString();\n  }\n\n  private async loadCacheCount(): Promise<void> {\n    try {\n      const storage = await chrome.storage.local.get('cachedTranscripts');\n      const cached = storage.cachedTranscripts || {};\n      const count = Object.keys(cached).length;\n      this.cacheCount.textContent = count.toString();\n    } catch (error) {\n      console.error('Failed to load cache count:', error);\n      this.cacheCount.textContent = '0';\n    }\n  }\n\n  private setupEventListeners(): void {\n    // Save button\n    this.saveBtn.addEventListener('click', () => {\n      this.saveSettings();\n    });\n\n    // Clear cache button\n    this.clearCacheBtn.addEventListener('click', () => {\n      this.clearCache();\n    });\n\n    // Listen for preference updates from other tabs\n    chrome.runtime.onMessage.addListener((message) => {\n      if (message.type === 'PREFERENCES_UPDATED' && message.payload) {\n        this.preferences = message.payload;\n        this.updateUI();\n      }\n    });\n  }\n\n  private parseWordList(text: string): string[] {\n    return text\n      .split('\\n')\n      .map(word => word.trim().toLowerCase())\n      .filter(word => word.length > 0);\n  }\n\n  private async saveSettings(): Promise<void> {\n    try {\n      const updates: Partial<UserPreferences> = {\n        customBlacklist: this.parseWordList(this.customBlacklist.value),\n        customWhitelist: this.parseWordList(this.customWhitelist.value),\n        paddingBeforeMs: parseInt(this.paddingBefore.value, 10) || 100,\n        paddingAfterMs: parseInt(this.paddingAfter.value, 10) || 30,\n        mergeThresholdMs: parseInt(this.mergeThreshold.value, 10) || 100,\n      };\n\n      const response = await chrome.runtime.sendMessage({\n        type: 'SET_PREFERENCES',\n        payload: updates,\n      });\n\n      if (response.success) {\n        this.preferences = response.data;\n        this.showSaveStatus('Settings saved successfully!', 'success');\n      } else {\n        this.showSaveStatus('Failed to save settings', 'error');\n      }\n    } catch (error) {\n      console.error('Failed to save settings:', error);\n      this.showSaveStatus('Failed to save settings', 'error');\n    }\n  }\n\n  private async clearCache(): Promise<void> {\n    try {\n      const response = await chrome.runtime.sendMessage({ type: 'CLEAR_CACHE' });\n\n      if (response.success) {\n        this.cacheCount.textContent = '0';\n        this.showSaveStatus('Cache cleared!', 'success');\n      } else {\n        this.showSaveStatus('Failed to clear cache', 'error');\n      }\n    } catch (error) {\n      console.error('Failed to clear cache:', error);\n      this.showSaveStatus('Failed to clear cache', 'error');\n    }\n  }\n\n  private showSaveStatus(message: string, type: 'success' | 'error'): void {\n    this.saveStatus.textContent = message;\n    this.saveStatus.className = `save-status ${type}`;\n\n    // Clear after 3 seconds\n    setTimeout(() => {\n      this.saveStatus.textContent = '';\n      this.saveStatus.className = 'save-status';\n    }, 3000);\n  }\n}\n\n// Initialize when DOM is ready\ndocument.addEventListener('DOMContentLoaded', () => {\n  const options = new OptionsController();\n  options.initialize();\n});\n"],"names":["DEFAULT_PREFERENCES","enabled","filterMode","severityLevels","mild","moderate","severe","religious","customBlacklist","customWhitelist","paddingMs","paddingBeforeMs","paddingAfterMs","mergeThresholdMs","autoEnableForFilteredVideos","OptionsController","preferences","initialize","this","document","getElementById","paddingBefore","paddingAfter","mergeThreshold","cacheCount","clearCacheBtn","saveBtn","saveStatus","loadPreferences","loadCacheCount","setupEventListeners","response","chrome","runtime","sendMessage","type","success","data","updateUI","error","console","value","join","toString","cached","storage","local","get","cachedTranscripts","count","Object","keys","length","textContent","addEventListener","saveSettings","clearCache","onMessage","addListener","message","payload","parseWordList","text","split","map","word","trim","toLowerCase","filter","updates","parseInt","showSaveStatus","className","setTimeout"],"ignoreList":[],"sourceRoot":""}